<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional Programming in Lean</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">
        <link rel="stylesheet" href="pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Leanにおける関数型プログラミング</a></li><li class="chapter-item expanded affix "><a href="introduction.html">イントロダクション</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">謝辞</a></li><li class="chapter-item expanded "><a href="getting-to-know.html"><strong aria-hidden="true">1.</strong> Leanの基本を学ぶ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 式の評価</a></li><li class="chapter-item expanded "><a href="getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 型</a></li><li class="chapter-item expanded "><a href="getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 関数と定義</a></li><li class="chapter-item expanded "><a href="getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="getting-to-know/datatypes-patterns-and-pattern.html"><strong aria-hidden="true">1.5.</strong> データタイプ、パターン、そして再帰</a></li><li class="chapter-item expanded "><a href="getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多相性</a></li><li class="chapter-item expanded "><a href="getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> プログラムの実行</a></li><li class="chapter-item expanded "><a href="hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> ステップバイステップ</a></li><li class="chapter-item expanded "><a href="hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> プロジェクトの始め方</a></li><li class="chapter-item expanded "><a href="hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 実例:cat</a></li><li class="chapter-item expanded "><a href="hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 小休止: 命題、証明、そして索引</a></li><li class="chapter-item expanded "><a href="type-classes.html"><strong aria-hidden="true">4.</strong> オーバーロードと型クラス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正の数</a></li><li class="chapter-item expanded "><a href="type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 型クラスと多相性</a></li><li class="chapter-item expanded "><a href="type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> インスタンス検索の制御</a></li><li class="chapter-item expanded "><a href="type-classes/arrays-and-indexing.html"><strong aria-hidden="true">4.4.</strong> 配列とインデックス化</a></li><li class="chapter-item expanded "><a href="type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 標準クラス</a></li><li class="chapter-item expanded "><a href="type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 強制変換</a></li><li class="chapter-item expanded "><a href="type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="monads.html"><strong aria-hidden="true">5.</strong> モナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/monad-type-class.html"><strong aria-hidden="true">5.1.</strong> モナド型クラス</a></li><li class="chapter-item expanded "><a href="monads/arithmetic-in-monads.html"><strong aria-hidden="true">5.2.</strong> 例: モナドでの算術</a></li><li class="chapter-item expanded "><a href="monads/do-notation-for-monads.html"><strong aria-hidden="true">5.3.</strong> モナド用do記法</a></li><li class="chapter-item expanded "><a href="monads/io-monad.html"><strong aria-hidden="true">5.4.</strong> IOモナド</a></li><li class="chapter-item expanded "><a href="monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="monads/summary.html"><strong aria-hidden="true">5.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 関手、アプリカティブ関手、そしてモナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functor-applicative-monad/structure-and-inheritance.html"><strong aria-hidden="true">6.1.</strong> 構造と継承</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-functors.html"><strong aria-hidden="true">6.2.</strong> アプリカティブ関手</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> アプリカティブの契約</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 代替物</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/complete-definitions.html"><strong aria-hidden="true">6.6.</strong> 完全な定義</a></li><li class="chapter-item expanded "><a href="functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="monad-transformers.html"><strong aria-hidden="true">7.</strong> モナドトランスフォーマ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> IOとReaderの組み合わせ</a></li><li class="chapter-item expanded "><a href="monad-transformers/transformers-kit.html"><strong aria-hidden="true">7.2.</strong> モナド構築キット</a></li><li class="chapter-item expanded "><a href="monad-transformers/order-of-monad-transformers.html"><strong aria-hidden="true">7.3.</strong> モナドトランスフォーマの並び順</a></li><li class="chapter-item expanded "><a href="monad-transformers/enhanced-do.html"><strong aria-hidden="true">7.4.</strong> doの機能強化</a></li><li class="chapter-item expanded "><a href="monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="dependent-types.html"><strong aria-hidden="true">8.</strong> 依存型を使用したプログラミング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> インデックス付きファミリー</a></li><li class="chapter-item expanded "><a href="dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙デザインパターン</a></li><li class="chapter-item expanded "><a href="dependent-types/typed-queries-examples.html"><strong aria-hidden="true">8.3.</strong> 実例: 型指定されたクエリ</a></li><li class="chapter-item expanded "><a href="dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> インデックス、パラメータ、そして宇宙レベル</a></li><li class="chapter-item expanded "><a href="dependent-types/pitfalls-of-programming-with-dependent-types.html"><strong aria-hidden="true">8.5.</strong> 依存型を使ったプログラミングの落とし穴</a></li><li class="chapter-item expanded "><a href="dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 小休止: 戦術、帰納、そして証明</a></li><li class="chapter-item expanded "><a href="programs-proofs.html"><strong aria-hidden="true">10.</strong> プログラミング、証明、そしてパフォーマンス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 末尾再帰</a></li><li class="chapter-item expanded "><a href="programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 同一性の証明</a></li><li class="chapter-item expanded "><a href="programs-proofs/arrays-and-termination.html"><strong aria-hidden="true">10.3.</strong> 配列と終了性</a></li><li class="chapter-item expanded "><a href="programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> その他の不等式</a></li><li class="chapter-item expanded "><a href="programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全な配列インデックス</a></li><li class="chapter-item expanded "><a href="programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 挿入ソートと配列の変更</a></li><li class="chapter-item expanded "><a href="programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊な型</a></li><li class="chapter-item expanded "><a href="programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="next-steps.html">次のステップ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="leanにおける関数型プログラミング"><a class="header" href="#leanにおける関数型プログラミング">Leanにおける関数型プログラミング</a></h1>
<p><em>著者: デイビッド・スレーン・クリスチャンセン</em></p>
<p><em>マイクロソフト コーポレーション著作権 2023年</em></p>
<p>これは、プログラミング言語Lean 4を使用するための無料の書籍です。すべてのコードサンプルはLean 4リリース <code>4.1.0</code> でテストされています。</p>
<h2 id="リリース履歴"><a class="header" href="#リリース履歴">リリース履歴</a></h2>
<h3 id="2023年10月"><a class="header" href="#2023年10月">2023年10月</a></h3>
<p>この最初のメンテナンスリリースでは、いくつかの小さな問題が修正され、テキストがLeanの最新リリースに合わせて更新されました。</p>
<h3 id="2023年5月"><a class="header" href="#2023年5月">2023年5月</a></h3>
<p>この本は現在完成しています！ 4月のプレリリースに比べ、多くの細部が改善され、小さな間違いが修正されました。</p>
<h3 id="2023年4月"><a class="header" href="#2023年4月">2023年4月</a></h3>
<p>このリリースは、戦術を使った証明の中間章と、終わりとプログラム同等性の証明の組み合わせに関するパフォーマンスとコストモデルの議論を含む最終章を追加します。これは最終リリース前の最後のリリースです。</p>
<h3 id="2023年3月"><a class="header" href="#2023年3月">2023年3月</a></h3>
<p>このリリースは、依存型とインデックス付きファミリーを使用したプログラミングに関する章を追加します。</p>
<h3 id="2023年1月"><a class="header" href="#2023年1月">2023年1月</a></h3>
<p>このリリースは、<code>do</code>-記法で利用可能な命令型機能の解説を含むモナドトランスフォーマーに関する章を追加します。</p>
<h3 id="2022年12月"><a class="header" href="#2022年12月">2022年12月</a></h3>
<p>このリリースは、構造と型クラスに関する詳細な説明を追加したアプリカティブ関手に関する章を追加します。これにはモナドの説明も改善させています。2022年12月のリリースは冬休みのため2023年1月まで遅れました。</p>
<h3 id="2022年11月"><a class="header" href="#2022年11月">2022年11月</a></h3>
<p>このリリースは、モナドを用いたプログラミングに関する章を追加します。加えて、依存セクションでのJSONの利用例が完全なコードを含むように更新されました。</p>
<h3 id="2022年10月"><a class="header" href="#2022年10月">2022年10月</a></h3>
<p>このリリースは、型クラスに関する章を完成させました。その前に、命題、証明、戦術を紹介する短い中間章を追加しました。なぜなら、これらの概念を少し理解しておくことが、標準ライブラリの型クラスを理解するのに役立つからです。</p>
<h3 id="2022年9月"><a class="header" href="#2022年9月">2022年9月</a></h3>
<p>このリリースは、演算子のオーバーロードとコードおよびライブラリー構造を整理する上での重要な手段であるLeanの型クラスについての章の前半を追加します。さらに、LeanのストリームAPIへの変更に対応した第二章の更新が含まれます。</p>
<h3 id="2022年8月"><a class="header" href="#2022年8月">2022年8月</a></h3>
<p>この3番目の公開リリースは、コンパイルとプログラムの実行、およびLeanの副作用モデルを説明する第二章を追加します。</p>
<h3 id="2022年7月"><a class="header" href="#2022年7月">2022年7月</a></h3>
<p>この第二の公開リリースは、第一章を完成させます。</p>
<h3 id="2022年6月"><a class="header" href="#2022年6月">2022年6月</a></h3>
<p>これは第一章の序章と一部を含む最初の公開リリースでした。</p>
<h2 id="著者について"><a class="header" href="#著者について">著者について</a></h2>
<p>デイビッド・スレーン・クリスチャンセンは、20年以上にわたる関数型言語の使用経験があり、10年以上の依存型の使用経験があります。彼はダニエル・P・フリードマンと共に、依存型理論の重要なアイディアを紹介する<a href="https://thelittletyper.com/"><em>The Little Typer</em></a>を共著しました。彼はコペンハーゲンIT大学で博士号を取得し、学習中にはIdris言語の最初のバージョンへの重要な貢献をしました。アカデミアを離れた後は、オレゴン州ポートランドのGalois、デンマークのコペンハーゲンやDeon Digitalでソフトウェア開発者として働き、Haskell Foundationの運営委員を務めました。執筆時点では、<a href="https://lean-fro.org">Lean Focused Research Organization</a>でフルタイムにLeanの研究に携わっています。</p>
<h2 id="ライセンス"><a class="header" href="#ライセンス">ライセンス</a></h2>
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="クリエイティブ・コモンズ・ライセンス" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />この作品は<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">クリエイティブ・コモンズ 表示 4.0 国際 ライセンス</a>に基づいて提供されています。</p>
<h2 id="訳者脚注"><a class="header" href="#訳者脚注">訳者脚注</a></h2>
<p>この文書は非公式の日本語訳です。以下の点にご注意ください。</p>
<ul>
<li><strong>非公式の翻訳:</strong> この文書は公式のものではなく、非公式に翻訳されたものです。</li>
<li><strong>原文の参照:</strong> 翻訳に疑問がある場合は、必要に応じて原文を参照してください。</li>
<li><strong>翻訳ツールの使用:</strong> この翻訳はGPT-4を用いて機械的に行われました。</li>
<li><strong>翻訳の不備:</strong> 機械翻訳のため、不備が存在する可能性があります。現在、手動での補完作業を行っています。</li>
<li><strong>訂正の依頼:</strong> 訳に問題を見つけた場合は、<a href="https://github.com/ondanaoto/fp-lean-ja">GitHub</a>のissueで報告するか、pull requestを通じて訂正をリクエストしてください。welcomeです！</li>
</ul>
<h2 id="翻訳の進捗"><a class="header" href="#翻訳の進捗">翻訳の進捗</a></h2>
<h3 id="2023年11月"><a class="header" href="#2023年11月">2023年11月</a></h3>
<ul>
<li>暫定版のリリース</li>
<li>訳者脚注の追記</li>
</ul>
<p>ご協力いただき、ありがとうございます。</p>
<div style="break-before: page; page-break-before: always;"></div><p>以下は、指定された <code>.md</code> ファイルの日本語への翻訳です：</p>
<p>Lean（リーン）は、依存型理論に基づいて開発されたMicrosoft Researchによる対話型の定理証明器です。
依存型理論とは、プログラムと証明の世界を統合するものです。従って、Leanはプログラミング言語としても機能します。
Leanはこの二重性を重視しており、汎用プログラミング言語として使用するのに適した設計となっています。Leanは自分自身でさえその中で実装されています。
この書籍は、Leanでのプログラミングに焦点を当てています。</p>
<p>プログラミング言語としてのLeanは、厳格な純粋関数型言語であり、依存型を持っています。
Leanを用いたプログラミング学習の大きな部分は、これらの特性がプログラムの書き方に与える影響を学び、関数型プログラマーの思考方法を理解することです。
<em>厳格さ</em> は、Leanにおける関数呼び出しが、多くの言語と同様に動くことを意味します：引数は関数の本体が実行される前に完全に計算されます。
<em>純粋さ</em> とは、Leanのプログラムが、たとえばメモリの位置を変更したり、メールを送信したり、ファイルを削除するような副作用を持たないことを指します。プログラムの型がそう言わない限り、それは不可能です。
Leanが <em>関数型</em> 言語であるというのは、関数が他の任意の値と同じように一級の値であるということであり、実行モデルが数学的表現評価に刺激を受けていることを意味します。
<em>依存型</em> は、Leanの最も独特な特徴であり、型を言語の一級市民とし、プログラムを含めた型を扱うこと、またはプログラムによる型計算を可能にします。</p>
<p>この書籍は、これまで関数型プログラム言語を使った経験がなくても、Leanを学びたいと願うプログラマーのために用意されています。
Haskell、OCaml、F#のような関数型言語に精通している必要はありませんが、ループや関数、データ構造など、ほとんどのプログラミング言語で共通の概念についての知識を仮定しています。
この書籍は関数型プログラミングへの良い導入書であることを意図していますが、プログラミング一般についての入門書としては適していません。</p>
<p>数学者の中には、Leanを証明アシスタントとして使用し、いずれカスタム証明自動化ツールの作成が必要になる人もいます。
この書籍はそうした目的にも役立ちます。
これらのツールは関数型言語内のプログラムに類似して洗練されていきますが、多くの実践数学者はPythonやMathematicaのような言語に慣れています。
この書籍はその知識のギャップを埋めるのに役立ち、より多くの数学者に持続可能でわかりやすい証明自動化ツールの作成能力を提供することができます。</p>
<p>この書籍は前から順に読むことを意図しています。
コンセプトは一つずつ紹介され、後のセクションでは前のセクションに詳しいことが前提とされています。
時には、早期の章で簡単に扱われたトピックが後の章で深掘りされることがあります。
いくつかのセクションには演習問題が含まれており、それらをこなすことでセクションの内容を固めることができます。
また、本を読みながらLeanを探求し、学んだことを新しい方法で適用することも有益です。</p>
<h1 id="leanをはじめよう"><a class="header" href="#leanをはじめよう">Leanをはじめよう</a></h1>
<p>Leanでプログラムを書いて実行する前に、Leanをご自身のコンピューターにセットアップする必要があります。
Leanツールキットは以下を含みます：</p>
<ul>
<li><code>elan</code> は、<code>rustup</code>や<code>ghcup</code>と同様に、Leanコンパイラツールチェーンを管理します。</li>
<li><code>lake</code> は、<code>cargo</code>、<code>make</code>、Gradleに似て、Leanパッケージとその依存関係をビルドします。</li>
<li><code>lean</code> は、個々のLeanファイルの型チェックとコンパイルを行います。また、プログラマーツールに現在書いているファイルについて情報を提供します。
通常、<code>lean</code>は直接ユーザーによって呼ばれるのではなく、他のツールによって呼ばれます。</li>
<li>Visual Studio CodeやEmacsなどのエディタプラグインは、<code>lean</code>と通信して便利な情報を表示します。</li>
</ul>
<p>Leanのインストールに関する最新の説明は、<a href="https://leanprover.github.io/lean4/doc/quickstart.html">Leanマニュアル</a>を参照してください。</p>
<h1 id="約物の規約"><a class="header" href="#約物の規約">約物の規約</a></h1>
<p>Leanに入力されるコードの例は以下のようにフォーマットされます：</p>
<pre><code class="language-lean">def add1 (n : Nat) : Nat := n + 1

#eval add1 7
</code></pre>
<p>上記の例の最後の行（<code>#eval</code>で始まる行）は、Leanに答えの計算を命令するコマンドです。
Leanの返答は以下のようにフォーマットされます：</p>
<pre><code class="language-output info">8
</code></pre>
<p>Leanが返すエラーメッセージは以下のようにフォーマットされます：</p>
<pre><code class="language-output error">application type mismatch
  add1 &quot;seven&quot;
argument
  &quot;seven&quot;
has type
  String : Type
but is expected to have type
  Nat : Type
</code></pre>
<p>警告は、以下のようにフォーマットされます：</p>
<pre><code class="language-output warning">declaration uses 'sorry'
</code></pre>
<h1 id="ユニコード"><a class="header" href="#ユニコード">ユニコード</a></h1>
<p>慣用的なLeanコードには、ASCIIには含まれない様々なUnicode文字が使用されます。
たとえば、この本の第1章ではギリシャ文字の <code>α</code> や <code>β</code>、矢印 <code>→</code> が登場します。
これにより、Leanコードは標準的な数学的表記法に近づきます。</p>
<p>デフォルトのLeanの設定では、Visual Studio CodeとEmacsの両方でこれらの文字をバックスラッシュ (<code>\</code>) に続けて名前を入力することでタイプできます。
例えば、<code>α</code> を入力するには、<code>\alpha</code> とタイプします。
Visual Studio Codeで文字の入力方法を知りたい場合は、マウスでその文字を指し、ツールチップを見てください。
Emacsでは、対象の文字の上で <code>C-c C-k</code> を使用します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="謝辞"><a class="header" href="#謝辞">謝辞</a></h1>
<p>この無料のオンラインブックは、マイクロソフトリサーチの寛大なサポートにより可能となりました。彼らは資金を提供し、無料で配布することを支えてくれました。
執筆の過程で、Lean開発チームの専門知識が私の質問に答え、Leanをより使いやすくするために活用されました。
特に、レオナルド・デ・モウラがプロジェクトを立ち上げ、私がスタートするのを手助けしてくれました。クリス・ラベットはCIとデプロイオートメーションを設定し、テストリーダーとして素晴らしいフィードバックを提供しました。ガブリエル・エブナーは技術的なレビュー、サラ・スミスは運営面で、そしてヴァネッサ・ロドリゲスはiOS上のSafariの特定のバージョンとソースコードハイライトライブラリの難しい相互作用の診断において手を貸してくれました。</p>
<p>この本を書くことは、通常の勤務時間を超える多大な労力を要しました。
私の妻、エリー・スレーン・クリスチャンセンは、家族を支えるために通常以上に負担を引き受けてくれました。彼女がそうしてくれなければ、この本は完成しませんでした。
毎週の追加労働日は家族にとって簡単ではなかったです—執筆期間中も辛抱強く支えてくれて、本当に感謝しています。</p>
<p>Leanコミュニティのメンバーは、このプロジェクトに対し、技術的な支援だけでなく、心情的なサポートも熱心に提供してくれました。
特に、Sebastian Ullrichは、エラーメッセージのテキストをCIでチェックし、Leanのメタプログラミングシステムを学びながらサポートコードを書く際に非常に役立ちました。
新版を投稿すると、数時間以内に熱心な読者たちが間違いを指摘し、改善提案をしてくれ、優しさを示してくれました。
スタイルと技術の両面で多くの提案をくれたArien Malec, Asta Halkjær From, Bulhwi Cha, Craig Stuntz, Daniel Fabian, Evgenia Karunus, eyelash, Floris van Doorn, František Silváši, Henrik Böving, Ian Young, Jeremy Salwen, Jireh Loreaux, Kevin Buzzard, Lars Ericson, Liu Yuxi, Mac Malone, Malcolm Langfield, Mario Carneiro, Newell Jensen, Patrick Massot, Paul Chisholm, Pietro Monticone, Tomas Puverle, Yaël Dillies, Zhiyuan Bao, Zyad Hassanからも感謝の意を表します。</p>
<div style="break-before: page; page-break-before: always;"></div><p>伝統に従い、プログラミング言語の紹介時には、
コンソールに「&quot;Hello, world!&quot;」と出力するプログラムをコンパイルして実行することが推奨されます。
この単純なプログラムによって、言語のツールが適切にインストールされていること、
そしてプログラマーがコンパイルしたコードを実行できる状態であることが確認できます。</p>
<p>しかし、1970年代以降、プログラミングは進化してきました。
今日では、コンパイラは通常テキストエディタに統合され、
プログラムを書いている最中にプログラミング環境からフィードバックが得られます。
Leanも例外ではなく、LeanはLanguage Server Protocolを拡張したバージョンを実装しており、
テキストエディタと通信してユーザがタイピングする際にフィードバックを提供することができます。</p>
<p>Python、Haskell、JavaScriptなどの様々な言語は、
read-eval-print-loop（REPL）やインタラクティブなトップレベル、
あるいはブラウザコンソールとして知られている機能を提供し、
ユーザーが式や文を入力できるようにしています。
その後で、言語はユーザーの入力の計算結果を表示します。
Leanはこれらの機能をエディタとの対話に統合し、
テキストエディタがプログラムテキスト自体にフィードバックを表示するコマンドを提供します。
この章では、エディタでLeanを使う入門的なガイドを提供していますが、<a href="">Hello, World!</a>では、
バッチモードでコマンドラインから従来の方法でLeanを使う方法について説明しています。</p>
<p>この本を読む際にはエディタでLeanを開き、
各例を進めるごとにタイピングして実践してみてください。
例を試しながら遊んで、何が起きるか見てみましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><p>以下は、指定された <code>.md</code> ファイルを日本語に翻訳したものです。</p>
<hr />
<h1 id="式の評価"><a class="header" href="#式の評価">式の評価</a></h1>
<p>プログラマーとしてLeanを学ぶ際に理解すべき最も重要なことは、
評価とはどのように機能するかです。評価は、算数のように、
式の値を見つけるプロセスです。例えば、
15 - 6の値は9であり、2 × (3 + 1)の値は8です。
後者の式の値を見つけるためには、まず3 + 1が4に置き換えられ、
次に2 × 4が求められ、最終的に8に還元されます。
時には、数学的な式に変数が含まれることもあります：<em>x</em> + 1の値は、
_x_の値がわかるまで計算することはできません。
Leanでは、プログラムはまず何よりも式であり、
計算について考える主要な方法はその式を評価してその値を見つけることです。</p>
<p>ほとんどのプログラミング言語は_命令型_であり、プログラムは
プログラムの結果を見つけるために実行されるべき
一連の文で構成されています。プログラムは変更可能なメモリに
アクセスできるため、変数によって参照される値は
時間と共に変わることがあります。変更可能な状態に加えて、
プログラムはファイルの削除、外部ネットワークへの接続、
例外のスローまたはキャッチ、データベースからのデータ読み取りなど、
他の副作用を持つこともあります。&quot;副作用&quot;とは、実質的に、
数学的な式の評価モデルに従わないプログラムで
発生することがあるものを説明するための総称です。</p>
<p>しかし、Leanでは、プログラムは数学的な式のように機能します。
変数に値が与えられると、それは再割り当てされることはありません。
式の評価は副作用を持ちえません。もし二つの式が同じ値を持てば、
それらを入れ替えてもプログラムは異なる結果を計算することはありません。
これはLeanを使って<code>Hello, world!</code>をコンソールに出力することが
できないという意味ではありませんが、
I/Oを実行することはLeanを使用する際の
核となる部分ではありません。したがって、
この章はLeanと対話的に式を評価する方法に焦点を置いていますが、
次の章では<code>Hello, world!</code>プログラムを書き、
コンパイルし、そして実行する方法について説明します。</p>
<p>Leanに式を評価させるには、エディターで式の前に<code>#eval</code>を書きます。
すると、結果が報告されます。一般的に、結果はカーソルやマウスポインタを
<code>#eval</code>の上に置くことで見つかります。例えば、</p>
<pre><code class="language-lean">#eval 1 + 2
</code></pre>
<p>は値 <code>3</code> を出力します。</p>
<p>Leanは、算数演算子の通常の優先順位と結合規則に従います。つまり、</p>
<pre><code class="language-lean">#eval 1 + 2 * 5
</code></pre>
<p>は値 <code>11</code> を出力し、
<code>15</code> ではありません。</p>
<p>通常の数学の記法とほとんどのプログラミング言語では、
関数をその引数に適用するために括弧を使用します（例えば、<code>f(x)</code>）が、
Leanでは単に関数をその引数の隣に書きます（例えば、<code>f x</code>）。
関数の適用は最も一般的な操作の一つなので、それを簡潔に保つことが重要です。
<code>String.append(&quot;Hello, &quot;, &quot;Lean!&quot;)</code>と書いて
<code>&quot;Hello, Lean!&quot;</code>を計算するのではなく、
代わりに次のように書きます。</p>
<pre><code class="language-Lean">#eval String.append &quot;Hello, &quot; &quot;Lean!&quot;
</code></pre>
<p>関数の二つの引数は、単にスペースで隣に書かれています。</p>
<p>算数の演算子の順序の規則では、式<code>(1 + 2) * 5</code>で括弧が必要であるように、
関数の引数が他の関数呼び出しによって計算されるべきときは括弧も同様に必要です。
例えば、</p>
<pre><code class="language-Lean">#eval String.append &quot;great &quot; (String.append &quot;oak &quot; &quot;tree&quot;)
</code></pre>
<p>括弧が必要なのは、そうでないと第二の<code>String.append</code>が、
最初のものの引数として解釈されるのではなく、
<code>&quot;oak &quot;</code>と<code>&quot;tree&quot;</code>を引数として渡される関数になるためです。
内側の<code>String.append</code>呼び出しの値を最初に見つけた後、
それを<code>&quot;great &quot;</code>に追加することができ、最終的な値
<code>&quot;great oak tree&quot;</code>が得られます。</p>
<p>命令型言語にはしばしば、条件に基づいてどの命令を実行するか決定する
条件文と、どちらの式を評価するかをブール値に基づいて決定する
条件式の2種類の条件があります。例えば、CおよびC++では、
条件文は<code>if</code>と<code>else</code>を使って書かれ、条件式は
三項演算子<code>?</code>と<code>:</code>を使って書かれます。Pythonでは、
条件文は<code>if</code>で始められますが、条件式では<code>if</code>が
中間に置かれます。
Leanは式指向の関数型言語なので、条件文は存在せず、
条件式のみが存在します。それらは<code>if</code>、<code>then</code>、<code>else</code>を使って書かれます。
例えば、</p>
<pre><code class="language-Lean">String.append &quot;it is &quot; (if 1 &gt; 2 then &quot;yes&quot; else &quot;no&quot;)
</code></pre>
<p>は</p>
<pre><code class="language-Lean">String.append &quot;it is &quot; (if false then &quot;yes&quot; else &quot;no&quot;)
</code></pre>
<p>に評価され、それは</p>
<pre><code class="language-lean">String.append &quot;it is &quot; &quot;no&quot;
</code></pre>
<p>に評価され、最終的には<code>&quot;it is no&quot;</code>に評価されます。</p>
<p>簡潔にするために、このような一連の評価ステップは時には矢印で書かれることがあります：</p>
<pre><code class="language-lean">String.append &quot;it is &quot; (if 1 &gt; 2 then &quot;yes&quot; else &quot;no&quot;)
===&gt;
String.append &quot;it is &quot; (if false then &quot;yes&quot; else &quot;no&quot;)
===&gt;
String.append &quot;it is &quot; &quot;no&quot;
===&gt;
&quot;it is no&quot;
</code></pre>
<h2 id="遭遇する可能性のあるメッセージ"><a class="header" href="#遭遇する可能性のあるメッセージ">遭遇する可能性のあるメッセージ</a></h2>
<p>引数が足りない関数の適用をLeanに評価させると、エラーメッセージが出ます。
特に、例</p>
<pre><code class="language-lean">#eval String.append &quot;it is &quot;
</code></pre>
<p>はかなり長いエラーメッセージを出力します：</p>
<pre><code class="language-output error">expression
  String.append &quot;it is &quot;
has type
  String → String
but instance
  Lean.MetaEval (String → String)
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>このメッセージは、引数の一部だけに適用されたLean関数が、
残りの引数を待機している新しい関数を返すために発生します。
Leanは関数をユーザーに表示することはできず、そのため表示を求められたときにエラーを返します。</p>
<h2 id="練習問題"><a class="header" href="#練習問題">練習問題</a></h2>
<p>以下の式の値は何でしょうか？手作業で計算し、
その後Leanに入力して作業を確認してください。</p>
<ul>
<li><code>42 + 19</code></li>
<li><code>String.append &quot;A&quot; (String.append &quot;B&quot; &quot;C&quot;)</code></li>
<li><code>String.append (String.append &quot;A&quot; &quot;B&quot;) &quot;C&quot;</code></li>
<li><code>if 3 == 3 then 5 else 7</code></li>
<li><code>if 3 == 4 then &quot;equal&quot; else &quot;not equal&quot;</code></li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="型"><a class="header" href="#型">型</a></h1>
<p>型はプログラムを、計算することのできる値に基づいて分類します。型はプログラムの中で多くの役割を果たします：</p>
<ol>
<li>
<p>値がメモリ内でどのように表現されるかについてコンパイラが決定を下すのを可能にします。</p>
</li>
<li>
<p>プログラマが他者に自分の意図を伝える助けとなり、関数の入出力に関する軽量な仕様として機能し、プログラムがそれに従うことをコンパイラが保証できます。</p>
</li>
<li>
<p>数値を文字列に加算するなどの様々な潜在的なミスを防ぎ、プログラムに必要なテストの数を減らします。</p>
</li>
<li>
<p>Leanコンパイラが補助コードの生成を自動化するのを助け、ボイラープレートを削減することができます。</p>
</li>
</ol>
<p>Leanの型システムは異常なほど表現力が高いです。
型は「このソート関数はその入力の順列を返す」のような強い仕様や、「この関数は引数の値に応じて異なる戻り値を持つ」のような柔軟な仕様をエンコードすることができます。
型システムは、数学定理を証明するための完全な論理としても使うことができます。
この最先端の表現力は、簡素な型の必要性をなくすものではありませんが、より高度な特徴を使うための前提としてこれらの簡素な型を理解することが必要です。</p>
<p>Lean内の全てのプログラムは型を持たなければなりません。特に、評価が行われる前には全ての式が型を持っていなければなりません。ここまでの例では、Lean自身が型を発見することができましたが、時には明示的に型を指定する必要があります。これはコロン演算子を用いて行われます：</p>
<pre><code class="language-lean">#eval (1 + 2 : Nat)
</code></pre>
<p>ここでの <code>Nat</code> は <em>自然数</em> の型であり、任意精度の符号なし整数です。
Leanでは、<code>Nat</code> が非負の整数リテラルのデフォルトの型です。
このデフォルトの型が常に最適な選択であるとは限りません。
例えばC言語では、符号なし整数の減算で結果がゼロ未満になる場合、最大表現可能数に対するアンダーフローによって減算されます。
しかし、<code>Nat</code> は任意に大きな符号なし数を表現できるため、アンダーフローする最大の数が存在しません。
そのため、<code>Nat</code> 上の減算は、答えがそうでなければ負になる場合には <code>0</code> を返します。
例えば、</p>
<pre><code class="language-lean">#eval 1 - 2
</code></pre>
<p>は <code>-1</code> ではなく <code>0</code> と評価されます。負の整数を表すことができる型を使うには直接指定します：</p>
<pre><code class="language-lean">#eval (1 - 2 : Int)
</code></pre>
<p>この型を使うと、結果は期待通り <code>-1</code> になります。</p>
<p>式の型を評価せずに確認するには、<code>#eval</code> の代わりに <code>#check</code> を使います。例えば：</p>
<pre><code class="language-lean">#check (1 - 2 : Int)
</code></pre>
<p>は実際に減算を行わずに <code>1 - 2 : Int</code> を報告します。</p>
<p>プログラムに型を与えることができない場合、<code>#check</code> および <code>#eval</code> からエラーが返されます。例えば：</p>
<pre><code class="language-lean">#check String.append &quot;hello&quot; [&quot; &quot;, &quot;world&quot;]
</code></pre>
<p>は以下の出力をします</p>
<pre><code class="language-output error">application type mismatch
  String.append &quot;hello&quot; [&quot; &quot;, &quot;world&quot;]
argument
  [&quot; &quot;, &quot;world&quot;]
has type
  List String : Type
but is expected to have type
  String : Type
</code></pre>
<p><code>String.append</code> の第二引数は文字列が期待されるのに対し、文字列のリストが提供されたためです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="関数と定義"><a class="header" href="#関数と定義">関数と定義</a></h1>
<p>Leanでは、<code>def</code>キーワードを使用して定義を導入します。例えば、文字列 <code>&quot;Hello&quot;</code> を参照する名前 <code>hello</code> を定義するには、以下のように書きます：</p>
<pre><code class="language-lean">def hello := &quot;Hello&quot;
</code></pre>
<p>Leanでは、新しい名前を定義するときは等号<code>=</code>ではなくコロンイコール演算子<code>:=</code>を使用します。これは<code>=</code>が既存の式間の等式を表すのに使われ、二つの異なる演算子を使用することで混乱を防ぐためです。</p>
<p><code>hello</code>の定義では、式 <code>&quot;Hello&quot;</code> が十分に単純なので、Leanは自動的に定義のタイプを決定できます。
しかし、ほとんどの定義はこれほど単純ではないので、通常はタイプを追加する必要があります。
これは、定義されている名前の後にコロンを使用することで行われます。</p>
<pre><code class="language-lean">def lean : String := &quot;Lean&quot;
</code></pre>
<p>名前が定義されたら、以下のように使用することができます。</p>
<pre><code class="language-Lean">#eval String.append hello (String.append &quot; &quot; lean)
</code></pre>
<p>出力としては、</p>
<pre><code class="language-Lean info">&quot;Hello Lean&quot;
</code></pre>
<p>Leanでは、定義された名前はその定義の後にのみ使用することができます。</p>
<p>多くの言語では、関数の定義は他の値の定義とは異なる構文を使用します。
たとえば、Pythonの関数定義は<code>def</code>キーワードで始まりますが、他の定義は等号で定義されます。
Leanでは、関数は他の値と同様に<code>def</code>キーワードを使用して定義されます。
それでも、<code>hello</code>のような定義は、それぞれ呼び出されるたびに同じ結果を返すゼロ引数関数を参照するのではなく、<em>直接</em> その値を参照する名前を導入します。</p>
<h2 id="関数の定義"><a class="header" href="#関数の定義">関数の定義</a></h2>
<p>Leanで関数を定義する方法は様々です。最も単純な方法は、関数の引数を定義のタイプの前にスペースで区切って配置することです。例えば、引数に1を加える関数は以下のように書かれます：</p>
<pre><code class="language-lean">def add1 (n : Nat) : Nat := n + 1
</code></pre>
<p>この関数を<code>#eval</code>でテストすると、期待通りの <code>8</code> を得ます：</p>
<pre><code class="language-lean">#eval add1 7
</code></pre>
<p>関数が複数の引数に適用される場合には、各引数の間にスペースを配置するように、複数の引数を受け取る関数は、引数の名前とタイプの間にスペースを配置して定義されます。関数 <code>maximum</code>は、2つの<code>Nat</code>引数<code>n</code>と<code>k</code>を取り、最も大きい方の引数と等しい結果を返します。</p>
<pre><code class="language-lean">def maximum (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    k
  else n
</code></pre>
<p><code>maximum</code>のような定義された関数に引数が与えられると、結果はまず引数名を提供された値で本体内で置き換え、次に結果の本体を評価することによって決定されます。例えば：</p>
<pre><code class="language-lean">maximum (5 + 8) (2 * 7)
===&gt;
maximum 13 14
===&gt;
if 13 &lt; 14 then 14 else 13
===&gt;
14
</code></pre>
<p>自然数、整数、および文字列に評価される式には、これを言うタイプがあります（それぞれ<code>Nat</code>、<code>Int</code>、および<code>String</code>）。
これは関数にも当てはまります。
<code>Nat</code>を受け取り<code>Bool</code>を返す関数は<code>Nat → Bool</code>型を持ち、二つの<code>Nat</code>を受け取り<code>Nat</code>を返す関数は<code>Nat → Nat → Nat</code>型を持ちます。</p>
<p>特別なケースとして、Leanは関数の名前が直接<code>#check</code>と共に使用されたときに、その関数のシグネチャを返します。
<code>#check add1</code> を入力すると <code>add1 (n : Nat) : Nat</code> を得ます。
しかし、関数の名前を括弧で囲むことでLeanを「だます」ことができ、通常の式として処理されるため、<code>#check (add1)</code> を入力すると <code>add1 : Nat → Nat</code> となり、<code>#check (maximum)</code> を入力すると <code>maximum : Nat → Nat → Nat</code> を得ます。
この矢印はASCII代替矢印 <code>-&gt;</code> としても書かれることができるので、上記の関数タイプはそれぞれ <code>Nat -&gt; Nat</code> および <code>Nat -&gt; Nat -&gt; Nat</code> として書かれます。</p>
<p>内部的には、すべての関数は実際には正確に1つの引数を期待しています。
<code>maximum</code>のように複数の引数を取るように見える関数は、実際には1つの引数を取り、その後新しい関数を返す関数です。
この新しい関数は次の引数を取り、それ以上の引数が期待されなくなるまでプロセスが続きます。
これは、<code>#check maximum 3</code> を提供すると <code>maximum 3 : Nat → Nat</code> を得、<code>#check String.append &quot;Hello &quot;</code> を提供すると <code>String.append &quot;Hello &quot; : String → String</code> を得ることによって見ることができます。
複数の引数を持つ関数を実装するために関数を返す関数を使用することは、数学者ハスケル・カリーに因んで <em>カリー化</em> と呼ばれます。
関数の矢印は右に結合するため、<code>Nat → Nat → Nat</code> は<code>Nat → (Nat → Nat)</code>と括弧で囲むべきです。</p>
<h3 id="練習問題-1"><a class="header" href="#練習問題-1">練習問題</a></h3>
<ul>
<li><code>String -&gt; String -&gt; String -&gt; String</code>型の関数<code>joinStringsWith</code>を定義して、最初の引数を2番目と3番目の引数の間に配置して新しい文字列を作成します。<code>joinStringsWith &quot;, &quot; &quot;one&quot; &quot;and another&quot;</code>は<code>&quot;one, and another&quot;</code>と同じ結果になるはずです。</li>
<li><code>joinStringsWith &quot;: &quot;</code>のタイプは何ですか？Leanで答えを確認してください。</li>
<li>与えられた高さ、幅、奥行きで直方体の体積を計算する、<code>Nat → Nat → Nat → Nat</code>型の関数<code>volume</code>を定義します。</li>
</ul>
<h2 id="型の定義"><a class="header" href="#型の定義">型の定義</a></h2>
<p>ほとんどの型付きプログラミング言語には、Cの<code>typedef</code>のように型に別名を定義する手段があります。
しかし、Leanでは、型は言語のファーストクラスに属しています - それらは他のどのような式と同じです。
これは、定義が他の値だけでなく型を参照することもできることを意味します。</p>
<p>例えば、もし<code>String</code>とタイピングするのが面倒であれば、より短い略称<code>Str</code>を定義することができます：</p>
<pre><code class="language-lean">def Str : Type := String
</code></pre>
<p>それから、<code>Str</code>を<code>String</code>の代わりに定義のタイプとして使用することが可能になります：</p>
<pre><code class="language-lean">def aStr : Str := &quot;This is a string.&quot;
</code></pre>
<p>これが機能する理由は、型がLeanの残りの部分と同じ規則に従うためです。
型は式であり、式では、定義済みの名前はその定義と置き換えることができます。
<code>Str</code>が<code>String</code>を意味するように定義されているため、<code>aStr</code>の定義は理にかなっています。</p>
<h3 id="出会うかもしれないメッセージ"><a class="header" href="#出会うかもしれないメッセージ">出会うかもしれないメッセージ</a></h3>
<p>型のための定義を使用することで実験することは、Leanが整数リテラルのオーバーロードをサポートする方法によってより複雑になります。
もし<code>Nat</code>が短すぎる場合、より長い名前<code>NaturalNumber</code>が定義されることができます：</p>
<pre><code class="language-lean">def NaturalNumber : Type := Nat
</code></pre>
<p>しかし、<code>Nat</code>の代わりに<code>NaturalNumber</code>を定義のタイプとして使用すると、期待された効果はありません。
特に、定義：</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := 38
</code></pre>
<p>は以下のエラーを生じます：</p>
<pre><code class="language-output error">failed to synthesize instance
  OfNat NaturalNumber 38
</code></pre>
<p>このエラーは、Leanが数値リテラルを_オーバーロード_することを許可しているために発生します。
意味があるとき、自然数リテラルは新しいタイプについても使用することができます。まるでそれらのタイプがシステムに組み込まれているかのようです。
これは数学を表現する上で便利にするLeanのミッションの一部であり、異なる分野の数学は非常に異なる目的で数値表記を使用します。
このオーバーロードを可能にする特定の機能は、オーバーロードを探す前にすべての定義済みの名前をその定義に置き換えるわけではありません。これが上記のエラーメッセージにつながります。</p>
<p>この制限を回避する方法の1つは、定義の右側に<code>Nat</code>のタイプを提供し、<code>Nat</code>のオーバーロードルールを<code>38</code>に使用させることです：</p>
<pre><code class="language-lean">def thirtyEight : NaturalNumber := (38 : Nat)
</code></pre>
<p>定義はまだタイプが正しいです。なぜなら<code>NaturalNumber</code>は<code>Nat</code>と同じタイプです—定義によって！</p>
<p>また、<code>Nat</code>に対して行われるのと同等に機能する<code>NaturalNumber</code>のオーバーロードを定義するという解決策もあります。
ただし、これにはLeanのより進んだ機能が必要になります。</p>
<p>最後に、<code>def</code>の代わりに<code>abbrev</code>を使用して<code>Nat</code>のための新しい名前を定義すると、オーバーロード解決中に定義済みの名前をその定義に置き換えることができます。
<code>abbrev</code>を使用して書かれた定義は常に展開されます。
例えば、</p>
<pre><code class="language-lean">abbrev N : Type := Nat
</code></pre>
<p>および</p>
<pre><code class="language-lean">def thirtyNine : N := 39
</code></pre>
<p>は問題なく受け入れられます。</p>
<p>内部的には、一部の定義はオーバーロード解決中に展開可能として内部的にマークされているものがあり、他はそうではありません。
展開されるべき定義は_還元可能_と呼ばれます。
還元可能性に対する制御は、Leanがスケールすることを可能にするために不可欠です：全ての定義を完全に展開すると、マシンが処理するのに時間がかかる非常に大きなタイプが生じ、ユーザーが理解するのが難しくなります。
<code>abbrev</code>で生成された定義は還元可能としてマークされます。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 構造体

プログラムを書く際の最初のステップは、問題領域の概念を特定し、それらをコードで適切に表現することです。
時には、領域の概念が他の、よりシンプルな概念の集まりである場合があります。
その場合、これらのシンプルなコンポーネントを一つの&quot;パッケージ&quot;にまとめて、意味のある名前を付けることが便利です。
Leanでは、C言語やRustの`struct`、C#の`record`に相当する _構造体_ を使ってこれを実現します。

構造体を定義すると、Leanに他のどのタイプにも還元できない完全に新しいタイプが導入されます。
これは便利です。なぜなら、同じデータを含んでいても異なる概念を表す複数の構造体が存在するかもしれないからです。
例えば、ポイントはカルテシアン座標または極座標を使って表されるかもしれません。どちらも浮動小数点数のペアで表されます。
別々の構造体を定義することで、APIの利用者が一方を他方と混同することを防ぐことができます。

Leanの浮動小数点数の型は`Float`と呼ばれ、浮動小数点数は通常の表記法で記述されます。
```lean
#check 1.2
</code></pre>
<pre><code class="language-output info">1.2 : Float
</code></pre>
<pre><code class="language-lean">#check -454.2123215
</code></pre>
<pre><code class="language-output info">-454.2123215 : Float
</code></pre>
<pre><code class="language-lean">#check 0.0
</code></pre>
<pre><code class="language-output info">0.0 : Float
</code></pre>
<p>小数点を含む浮動小数点数を書くとき、Leanは型<code>Float</code>を推論します。小数点を含まない場合、型注釈が必要になるかもしれません。</p>
<pre><code class="language-lean">#check 0
</code></pre>
<pre><code class="language-output info">0 : Nat
</code></pre>
<pre><code class="language-lean">#check (0 : Float)
</code></pre>
<pre><code class="language-output info">0 : Float
</code></pre>
<p>カルテシアンポイントは、<code>x</code>と<code>y</code>という名前の2つの<code>Float</code>フィールドを持つ構造体です。
これは<code>structure</code>キーワードを使って宣言されます。</p>
<pre><code class="language-lean">structure Point where
  x : Float
  y : Float
deriving Repr
</code></pre>
<p>この宣言の後、<code>Point</code>は新しい構造体タイプとなります。
最後の行は<code>deriving Repr</code>と記述されており、型<code>Point</code>の値を表示するためのコードの生成をLeanに依頼しています。
このコードは、プログラマーによる評価結果のレンダリングに<code>#eval</code>によって使われます。これはPythonの<code>repr</code>関数に類似しています。
また、コンパイラが生成した表示コードをオーバーライドすることも可能です。</p>
<p>構造体タイプの値を作成する典型的な方法は、中括弧内にすべてのフィールドの値を指定することです。
カルテシアン平面の原点は<code>x</code>と<code>y</code>が共にゼロのところです：</p>
<pre><code class="language-lean">def origin : Point := { x := 0.0, y := 0.0 }
</code></pre>
<p>もし<code>Point</code>の定義で<code>deriving Repr</code>行が省略されたら、<code>#eval origin</code>を試みると、関数の引数を省略した場合に発生するエラーに似たエラーが発生します：</p>
<pre><code class="language-output error">expression
  origin
has type
  Point
but instance
  Lean.MetaEval Point
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>そのメッセージは、評価機構が評価結果をユーザーに伝える方法を知らないことを意味しています。</p>
<p>幸いにも、<code>deriving Repr</code>により、<code>#eval origin</code>の結果は<code>origin</code>の定義に非常によく似ています。</p>
<pre><code class="language-output info">{ x := 0.000000, y := 0.000000 }
</code></pre>
<p>構造体はデータの集まりを&quot;束ねて&quot;、名前を付けて一つの単位として扱うために存在するので、構造体から個々のフィールドを抽出することも重要です。
これはC言語、Python、Rustのようなドット記法を使用して行われます。</p>
<pre><code class="language-lean">#eval origin.x
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<pre><code class="language-lean">#eval origin.y
</code></pre>
<pre><code class="language-output info">0.000000
</code></pre>
<p>これを使用して、構造体を引数として取る関数を定義することができます。
たとえば、ポイントの加算は、基礎となる座標値を加えることによって行われます。
<code>#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }</code>は</p>
<pre><code class="language-output info">{ x := -6.500000, y := 32.200000 }
</code></pre>
<p>となるべきです。
関数自体は、<code>p1</code>と<code>p2</code>と呼ばれる2つの<code>Points</code>を引数として取ります。
結果として得られるポイントは、<code>p1</code>と<code>p2</code>の<code>x</code>と<code>y</code>フィールドに基づいています：</p>
<pre><code class="language-lean">def addPoints (p1 : Point) (p2 : Point) : Point :=
  { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>同様に、2つのポイント間の距離は、それぞれの<code>x</code>と<code>y</code>成分の差の二乗の合計の平方根で表されます。これは以下のように記述されます：</p>
<pre><code class="language-lean">def distance (p1 : Point) (p2 : Point) : Float :=
  Float.sqrt (((p2.x - p1.x) ^ 2.0) + ((p2.y - p1.y) ^ 2.0))
</code></pre>
<p>たとえば、(1, 2)と(5, -1)の距離は5です：</p>
<pre><code class="language-lean">#eval distance { x := 1.0, y := 2.0 } { x := 5.0, y := -1.0 }
</code></pre>
<pre><code class="language-output info">5.000000
</code></pre>
<p>複数の構造体は、同じ名前のフィールドを持つことがあります。
たとえば、3次元ポイントのデータ型は<code>x</code>と<code>y</code>のフィールドを共通して持ち、同じフィールド名でインスタンス化されるかもしれません：</p>
<pre><code class="language-lean">structure Point3D where
  x : Float
  y : Float
  z : Float
deriving Repr

def origin3D : Point3D := { x := 0.0, y := 0.0, z := 0.0 }
</code></pre>
<p>つまり、中括弧構文を使用するためには構造体の期待されるタイプがわかっている必要があります。
タイプが不明な場合、Leanは構造体をインスタンス化することができません。
たとえば、</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 }
</code></pre>
<p>は次のエラーにつながります</p>
<pre><code class="language-output error">invalid {...} notation, expected type is not known
</code></pre>
<p>通常どおり、状況は型注釈を提供することで解決されます。</p>
<pre><code class="language-lean">#check ({ x := 0.0, y := 0.0 } : Point)
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<p>プログラムをより簡潔にするために、Leanは中括弧の中で構造体の型注釈を許可しています。</p>
<pre><code class="language-lean">#check { x := 0.0, y := 0.0 : Point}
</code></pre>
<pre><code class="language-output info">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<h2 id="構造体の更新"><a class="header" href="#構造体の更新">構造体の更新</a></h2>
<p><code>Point</code>の<code>x</code>フィールドを<code>0.0</code>に置き換える関数<code>zeroX</code>を想像してください。
ほとんどのプログラミング言語コミュニティでは、この文章は<code>x</code>を指しているメモリ位置が新しい値に上書きされることを意味します。
しかし、Leanには変更可能な状態がありません。
関数型プログラミングコミュニティでは、この種の表現によってほとんど常に意味されることは、新しい<code>Point</code>がアロケートされて<code>x</code>フィールドが新しい値を指し、他のすべてのフィールドが入力からの元の値を指すことです。
<code>zeroX</code>を文字通りに記述する一つの方法は、<code>x</code>に新しい値を記入し、<code>y</code>を手動で転送することです：</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { x := 0, y := p.y }
</code></pre>
<p>しかし、このスタイルのプログラミングには欠点があります。
まず、構造体に新しいフィールドが追加された場合、どのフィールドを更新する場所でも更新する必要があり、メンテナンスが難しくなります。
第二に、構造体が同じタイプの複数のフィールドを含んでいる場合、コピーアンドペーストのコーディングによってフィールドの内容が複製されたり切り替えられたりするリスクがあります。
最後に、プログラムが長くて官僚的になります。</p>
<p>Leanは構造体のいくつかのフィールドを置き換える一方で他をそのままにしておくための便利な構文を提供しています。
これは構造体の初期化で<code>with</code>キーワードを使用することにより行われます。
変更されないフィールドのソースは<code>with</code>の前に、新しいフィールドがその後に配置されます。
例えば、<code>zeroX</code>は新しい<code>x</code>値だけで記述することができます：</p>
<pre><code class="language-lean">def zeroX (p : Point) : Point :=
  { p with x := 0 }
</code></pre>
<p>この構造体の更新構文は既存の値を変更しないことを忘れないでください。それは新しい値を作り出し、古い値といくつかのフィールドを共有します。
例えば、ポイント<code>fourAndThree</code>があるとします：</p>
<pre><code class="language-lean">def fourAndThree : Point :=
  { x := 4.3, y := 3.4 }
</code></pre>
<p>それを評価してから、<code>zeroX</code>を使ってそれを更新してから、もう一度評価すると、元の値が返されます：</p>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval zeroX fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 0.000000, y := 3.400000 }
</code></pre>
<pre><code class="language-lean">#eval fourAndThree
</code></pre>
<pre><code class="language-output info">{ x := 4.300000, y := 3.400000 }
</code></pre>
<p>構造体の更新が元の構造を変更しないという事実は、古いものから新しい値を計算する場合に推論を容易にします。
古い構造体を参照するすべての参照は、提供された新しい値のすべてで同じフィールド値を示し続けます。</p>
<h2 id="裏側での動作"><a class="header" href="#裏側での動作">裏側での動作</a></h2>
<p>すべての構造体には <em>コンストラクタ</em> があります。
ここで、「コンストラクタ」という用語は混乱の元になるかもしれません。
JavaやPythonなどの言語でのコンストラクタとは異なり、Leanのコンストラクタはデータタイプが初期化される際に実行される任意のコードではありません。
コンストラクタは単に新しくアロケートされたデータ構造に格納されるデータを集めるだけです。
データを前処理したり無効な引数を拒否するカスタムコンストラクタを提供することはできません。
これは本当に、二つの文脈で「コンストラクタ」という語が異なるが関連する意味を持つというケースです。</p>
<p>デフォルトでは、<code>S</code>という名前の構造体のコンストラクタは<code>S.mk</code>という名前になります。
ここで、<code>S</code>は名前空間の修飾子であり、<code>mk</code>はコンストラクタ自体の名前です。
中括弧初期化構文の代わりに、コンストラクタは直接適用することができます。</p>
<pre><code class="language-lean">#check Point.mk 1.5 2.8
</code></pre>
<p>しかし、これは一般的に良いLeanのスタイルとは考えられておらず、Leanは標準の構造体初期化構文を使用してフィードバックを返すことさえあります。</p>
<pre><code class="language-output info">{ x := 1.5, y := 2.8 } : Point
</code></pre>
<p>コンストラクタには関数タイプがあるため、関数が期待されるどこでも使用することができます。
例えば、<code>Point.mk</code>は2つの<code>Float</code>（それぞれ<code>x</code>と<code>y</code>に対応する）を受け取り、新しい<code>Point</code>を返します。</p>
<pre><code class="language-lean">#check (Point.mk)
</code></pre>
<pre><code class="language-output info">Point.mk : Float → Float → Point
</code></pre>
<p>構造体のコンストラクタ名を上書きするには、冒頭に二つのコロンを使って書きます。
たとえば、<code>Point.mk</code>の代わりに<code>Point.point</code>を使用するには、次のように書きます：</p>
<pre><code class="language-lean">structure Point where
  point ::
  x : Float
  y : Float
deriving Repr
</code></pre>
<p>コンストラクタに加えて、構造体の各フィールドに対してアクセサ関数が定義されます。
これらは構造体の名前空間の中でフィールドと同じ名前を持っています。
<code>Point</code>については、アクセサ関数<code>Point.x</code>と<code>Point.y</code>が生成されます。</p>
<pre><code class="language-lean">#check (Point.x)
</code></pre>
<pre><code class="language-output info">Point.x : Point → Float
</code></pre>
<pre><code class="language-lean">#check (Point.y)
</code></pre>
<pre><code class="language-output info">{{#example_out Examples/Intro.leanPointy}}
</code></pre>
<p>ここで、実際には、構造体の構築構文で使用される中括弧構文は、背後では構造体のコンストラクターを呼び出す形に変換されます。先の<code>addPoints</code>の定義における<code>p1.x</code>という構文も、<code>Point.x</code>アクセス関数を呼び出す形に変換されます。つまり、<code>#eval origin.x</code>と<code>#eval Point.x origin</code>の両方が同じ結果を生成します。</p>
<pre><code class="language-output info">0.000000
</code></pre>
<p>アクセスドット記法は、単純な構造体のフィールド以外にも使えます。任意の引数を取る関数にも使えるのです。より一般的には、アクセス記法は<code>TARGET.f ARG1 ARG2 ...</code>の形を取ります。<code>TARGET</code>が<code>T</code>型の場合、名前が<code>T.f</code>の関数が呼び出されます。<code>TARGET</code>は<code>T</code>型の最も左の引数になりますが、これは必ずしも最初の引数とは限りません。そして、残りの引数<code>ARG1 ARG2 ...</code>は順に提供されます。例えば、<code>String.append</code>は、<code>String</code>が<code>append</code>フィールドを有する構造体ではなくても、ドット記法を用いて文字列から呼び出すことができます。</p>
<pre><code class="language-lean">#eval &quot;one string&quot;.append &quot; and another&quot;
</code></pre>
<pre><code class="language-output info">&quot;one string and another&quot;
</code></pre>
<p>その例では、<code>TARGET</code>は<code>&quot;one string&quot;</code>を表し、<code>ARG1</code>は<code>&quot; and another&quot;</code>を表します。</p>
<p>関数<code>Point.modifyBoth</code>（つまり<code>Point</code>名前空間で定義された<code>modifyBoth</code>）は<code>Point</code>の両方のフィールドに関数を適用します。</p>
<pre><code class="language-lean">def Point.modifyBoth (f : Float → Float) (p : Point) : Point :=
  { x := f p.x, y := f p.y }
</code></pre>
<p><code>Point</code>引数が関数引数の後に来ていても、ドット記法で使用することが可能です。</p>
<pre><code class="language-lean">#eval fourAndThree.modifyBoth Float.floor
</code></pre>
<pre><code class="language-output info">{ x := 4.000000, y := 3.000000 }
</code></pre>
<p>このケースでは、<code>TARGET</code>は<code>fourAndThree</code>を表し、<code>ARG1</code>は<code>Float.floor</code>です。アクセスドット記法のターゲットは必ずしも最初の引数ではなく、型が一致する最初の引数として使われます。</p>
<h2 id="練習問題-2"><a class="header" href="#練習問題-2">練習問題</a></h2>
<ul>
<li><code>Float</code>型の高さ、幅、奥行きを持つ直方体を表す<code>RectangularPrism</code>という名前の構造体を定義してください。</li>
<li>直方体の体積を計算する<code>volume : RectangularPrism → Float</code>という名前の関数を定義してください。</li>
<li>端点によって線分を表す<code>Segment</code>という名前の構造体を定義し、線分の長さを計算する<code>length : Segment → Float</code>という関数を定義してください。<code>Segment</code>には最大で二つのフィールドを持つべきです。</li>
<li><code>RectangularPrism</code>の宣言によって導入される名前は何ですか？</li>
<li>次の<code>Hamster</code>および<code>Book</code>の宣言によって導入される名前は何ですか？それぞれの型は何ですか？</li>
</ul>
<pre><code class="language-lean">structure Hamster where
  name : String
  fluffy : Bool
</code></pre>
<pre><code class="language-lean">structure Book where
  makeBook ::
  title : String
  author : String
  price : Float
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="データタイプパターンそして再帰"><a class="header" href="#データタイプパターンそして再帰">データタイプ、パターン、そして再帰</a></h1>
<p>構造体は、複数の独立したデータピースを組み合わせて、新しい型によって代表される一貫性のある全体を形成することを可能にします。
値のコレクションをまとめてグループ化するような構造体のような型は、_積型（product types）_と呼ばれます。
しかし、多くのドメイン概念は構造体として自然に表現することができません。
たとえば、アプリケーションがユーザー権限を追跡する必要があり、ユーザーにはドキュメントの所有者、ドキュメントの編集者、そしてドキュメントの読み取りのみが可能な者といった区別があります。
計算機は、加算、減算、乗算などの複数の二項演算子を持っています。
構造体では、複数の選択肢をエンコードする簡単な方法はありません。</p>
<p>同様に、構造体は固定のフィールドセットを追跡する優れた方法ですが、多くのアプリケーションでは任意の数の要素を含むデータが必要です。
木やリストのような最も古典的なデータ構造の多くは再帰的な構造を持っており、リストの尾はそれ自体がリストであり、二分木の左右の枝がそれ自体が二分木です。
先述の計算機では、式自体の構造が再帰的です。
加算式の加数がそれ自体が乗算式であることがあります。</p>
<p>選択肢を許すデータ型は、_和型（sum types）_と呼ばれ、自分自身のインスタンスを含むことができるデータ型は_再帰データ型（recursive datatypes）_と呼ばれます。
再帰型の和型は_帰納データ型（inductive datatypes）_と呼ばれ、それに関するステートメントを証明するために数学的帰納法を使用することができます。
プログラミングするときは、帰納データ型はパターンマッチングと再帰関数を通じて処理されます。</p>
<p>標準ライブラリの組み込み型の多くは実際には帰納データ型です。
例えば、<code>Bool</code>は帰納データ型です：</p>
<pre><code class="language-lean">inductive Bool where
  | false : Bool
  | true : Bool
</code></pre>
<p>この定義には2つの主要な部分があります。
最初の行は新しい型の名前を提供し（<code>Bool</code>）、残りの行はそれぞれ構築子を記述しています。
構造体の構築子と同じように、帰納データ型の構築子も他のデータを受け取り、保持するだけの単なる受動的な場所であり、任意の初期化や検証コードを挿入する場所ではありません。
構造体とは異なり、帰納データ型には複数の構築子があります。
ここでは、<code>true</code>と<code>false</code>の2つの構築子があり、どちらも引数を取りません。
構造体宣言がその名前を宣言した型の後に名前付けられた名前空間に配置するように、帰納データ型はその構築子の名前を名前空間に配置します。
Lean標準ライブラリでは、<code>true</code>と<code>false</code>はこの名前空間から再エクスポートされるため、<code>Bool.true</code>と<code>Bool.false</code>としてではなく、単独で書くことができます。</p>
<p>データモデリングの観点から、帰納データ型は、他の言語ではシールされた抽象クラスが使用される多くの同じ文脈で使用されます。
C#やJavaなどの言語では、<code>Bool</code>の類似の定義を次のように書くかもしれません：</p>
<pre><code class="language-C#">abstract class Bool {}
class True : Bool {}
class False : Bool {}
</code></pre>
<p>ただし、これらの表現の詳細はかなり異なります。特に、非抽象クラスは新しいタイプとデータの新しい割り当て方法の両方を作ります。オブジェクト指向の例では、<code>True</code>と<code>False</code>は<code>Bool</code>よりも具体的な型でありますが、Leanの定義では新しい型<code>Bool</code>のみが導入されます。</p>
<p>非負整数の型<code>Nat</code>は帰納データ型です：</p>
<pre><code class="language-lean">inductive Nat where
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<p>ここでは、<code>zero</code>は0を表し、<code>succ</code>は他のいくつかの数の後継を表します。
<code>succ</code>の宣言で言及されている<code>Nat</code>は、ちょうど定義中にある同じ型<code>Nat</code>です。
_後継者_とは「それよりも1大きい」という意味であり、5の後継者は6、32,185の後継者は32,186です。
この定義を使うと、<code>4</code>は<code>Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))</code>として表されます。
この定義は<code>Bool</code>の定義に似ていますが、名前が少し違います。
唯一の本当の違いは、<code>succ</code>の後に<code>(n : Nat)</code>が続き、これは構築子<code>succ</code>が型<code>Nat</code>の引数を取り、その引数は偶然<code>n</code>という名前であることを指定します。
名前<code>zero</code>と<code>succ</code>はそれらの型にちなんで名付けられた名前空間にあり、それゆえにそれぞれ<code>Nat.zero</code>と<code>Nat.succ</code>として参照されなければなりません。</p>
<p>引数名、例えば<code>n</code>は、Leanのエラーメッセージや数学的証明を書く際に提供されるフィードバックに表示されます。
Leanには名前によって引数を提供するオプショナルな構文もあります。
一般的には、引数名の選択は構造体のフィールド名の選択ほど重要ではなく、APIの大部分を形成しないためです。</p>
<p>C#やJavaでは、<code>Nat</code>は次のように定義できます：</p>
<pre><code class="language-C#">abstract class Nat {}
class Zero : Nat {}
class Succ : Nat {
  public Nat n;
  public Succ(Nat pred) {
	n = pred;
  }
}
</code></pre>
<p>上で述べた<code>Bool</code>の例と同様に、これはLeanの同等物よりも多くの型を定義します。
さらに、この例は、Leanのデータ型構築子がC#やJavaのコンストラクタとは異なり、抽象クラスのサブクラスに非常に似ていることを強調しています。というのも、ここで示されているコンストラクタには実行される初期化コードが含まれているからです。</p>
<h1 id="パターンマッチング"><a class="header" href="#パターンマッチング">パターンマッチング</a></h1>
<p>多くの言語では、これらの種類のデータは、最初にインスタンスオブ演算子を使用してどのサブクラスを受け取ったかをチェックし、その後、与えられたサブクラスで使用可能なフィールドの値を読み取ることによって消費されます。
インスタンスオブチェックはどのコードを実行するかを決定し、このコードに必要なデータが利用可能であることを保証し、フィールド自体はデータを提供します。
Leanでは、これらの両方の目的は_パターンマッチング_によって同時に提供されます。</p>
<p>パターンマッチングを使用する関数の例は、その引数が<code>Nat.zero</code>の場合に<code>true</code>を返す<code>isZero</code>関数です。</p>
<pre><code class="language-lean">def isZero (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; false
</code></pre>
<p><code>match</code>式は関数の引数<code>n</code>を分解するために与えられます。
もし<code>n</code>が<code>Nat.zero</code>によって構築された場合、パターンマッチの最初の分岐が取られ、結果は<code>true</code>です。
もし<code>n</code>が<code>Nat.succ</code>によって構築された場合、2番目の分岐が取られ、結果は<code>false</code>です。</p>
<p>例えば、<code>isZero Nat.zero</code>の評価は次のように進行します：</p>
<pre><code class="language-lean">isZero Nat.zero
===&gt;
match Nat.zero with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
true
</code></pre>
<p><code>isZero 5</code>の評価も同様に進行します：</p>
<pre><code class="language-lean">isZero 5
===&gt;
isZero (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))
===&gt;
match Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))) with
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
false
</code></pre>
<p><code>isZero</code>のパターンの2番目の分岐における<code>k</code>は装飾的なものではありません。
これにより、<code>succ</code>への引数の<code>Nat</code>が見えるようになり、提供された名前を使って指定できます。
そのより小さな数を使用して、式の最終結果を計算することができます。</p>
<p>例えば、ある数 \( n \) の後継者が \( n \) よりも1大きい（\( n + 1\)）のと同じように、数の前者はそれよりも1小さいです。
もし<code>pred</code>が<code>Nat</code>の前者を見つける関数であるならば、以下の例が期待される結果を見つけることになるでしょう：</p>
<pre><code class="language-lean">#eval pred 5
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<pre><code class="language-lean">#eval pred 839
</code></pre>
<pre><code class="language-output info">838
</code></pre>
<p><code>Nat</code>は負の数を表すことができないため、<code>0</code>は少し問題です。
通常、<code>Nat</code>を使用する際には、通常負の数を生じさせるような演算子は、<code>0</code>自体を生成するように再定義されます：</p>
<pre><code class="language-lean">#eval pred 0
</code></pre>
<pre><code class="language-output info">0
</code></pre>
<p><code>Nat</code>の前者を見つけるためには、最初にそれを作成するためにどの構築子が使用されたかをチェックする必要があります。
もし<code>Nat.zero</code>であれば、結果は<code>Nat.zero</code>です。
もし<code>Nat.succ</code>であれば、<code>k</code>という名前を使用してその下の<code>Nat</code>を参照します。
そして、この<code>Nat</code>が望ましい前者なので、<code>Nat.succ</code>の分岐の結果は<code>k</code>です。</p>
<pre><code class="language-lean">def pred (n : Nat) : Nat :=
  match n with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k =&gt; k
</code></pre>
<p>この関数を<code>5</code>に適用すると、以下のステップが得られます：</p>
<pre><code class="language-lean">pred 5
===&gt;
pred (Nat.succ 4)
===&gt;
match Nat.succ 4 with
| Nat.zero =&gt; Nat.zero
| Nat.succ k =&gt; k
===&gt;
4
</code></pre>
<p>構造体と和型の両方でパターンマッチングが使用されます。
例えば、<code>Point3D</code>から3番目の次元を抽出する関数は次のように書かれます：</p>
<pre><code class="language-lean">def depth (p : Point3D) : Float :=
  match p with
  | { x:= h, y := w, z := d } =&gt; d
</code></pre>
<p>この場合、単に<code>z</code>アクセサーを使う方がはるかに簡単でしたが、構造パターンは時々関数を書く一番簡単な方法です。</p>
<h2 id="再帰関数"><a class="header" href="#再帰関数">再帰関数</a></h2>
<p>定義されている名前を参照する定義は_再帰定義_と呼ばれます。
帰納データ型は再帰的であることが許され、実際に<code>Nat</code>は<code>succ</code>が別の<code>Nat</code>を要求するためそのようなデータ型の例です。
再帰データ型は技術的な要因（利用可能なメモリなど）によってのみ制限される任意に大きなデータを表すことができます。
データ型定義内で各自然数のための構造体を書き留めることは不可能であるように、また、各可能性のためのパターンマッチケースを書き留めることも不可能です。</p>
<p>再帰データ型は再帰関数によってうまく補完されます。
<code>Nat</code>上の単純な再帰関数はその引数が偶数かどうかをチェックします。
この場合、<code>zero</code>は偶数です。
このような非再帰ブランチのコードは_ベースケース_と呼ばれます。
奇数の後継者は偶数であり、偶数の後継者は奇数です。
これは、<code>succ</code>で構築された数が、その引数が偶数でない場合にのみ偶数であることを意味します。</p>
<pre><code class="language-lean">def even (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<p>これは、<code>Nat</code>上の再帰関数を書くための典型的な思考パターンです。
最初に<code>zero</code>に対して何をするかを特定します。
次に、任意の<code>Nat</code>に対する結果をその後継者に対する結果に変換する方法を決定し、この変換を再帰呼び出しの結果に適用します。
このパターンは_構造的再帰_と呼ばれます。</p>
<p>多くの言語とは異なり、Leanはデフォルトで、すべての再帰関数が最終的にベースケースに到達することを保証します。
プログラミングの観点から、これにより偶発的な無限ループが除外されます。
しかし、特に定理を証明する際には、この機能は特に重要であり、無限ループは大きな困難を引き起こします。
その結果として、Leanは元の数に対して自身を再帰的に呼び出そうとする<code>even</code>のバージョンを受け付けません。</p>
<pre><code class="language-lean">def evenLoops (n : Nat) : Bool :=
  match n with
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (evenLoops n)
</code></pre>
<p>エラーメッセージの重要な部分は、Leanが再帰関数が常にベースケースに到達することを判定できなかったということです（なぜなら、実際には到達しないからです）。</p>
<pre><code class="language-output error">fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
</code></pre>
<p>足し算は二つの引数を取りますが、調べる必要があるのはそのうちの一つだけです。数\(n\)にゼロを足すときは、単に\(n\)を返します。\(k\)の後継者に\(n\)を足すときは、\(k\)に\(n\)を足した結果の後継者を取ります。</p>
<pre><code class="language-lean">def plus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; Nat.succ (plus n k')
</code></pre>
<p><code>plus</code>の定義で、<code>k'</code>という名前が選ばれているのは、それが引数<code>k</code>と関連してはいるものの、同一ではないことを示すためです。例えば、<code>plus 3 2</code>の評価を追っていくと、以下のステップになります：</p>
<pre><code class="language-lean">plus 3 2
===&gt;
plus 3 (Nat.succ (Nat.succ Nat.zero))
===&gt;
match Nat.succ (Nat.succ Nat.zero) with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')
===&gt;
Nat.succ (plus 3 (Nat.succ Nat.zero))
===&gt;
Nat.succ (match Nat.succ Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k'))
===&gt;
Nat.succ (Nat.succ (plus 3 Nat.zero))
===&gt;
Nat.succ (Nat.succ (match Nat.zero with
| Nat.zero =&gt; 3
| Nat.succ k' =&gt; Nat.succ (plus 3 k')))
===&gt;
Nat.succ (Nat.succ 3)
===&gt;
5
</code></pre>
<p>足し算とは、\(n + k\)が\(n\)に対して<code>Nat.succ</code>を\(k\)回適用することと考えることもできます。同様に、かけ算\(n × k\)は\(n\)を自分自身に\(k\)回足し、引き算\(n - k\)は\(n\)の前任者を\(k\)回取ることです。</p>
<pre><code class="language-lean">def times (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k' =&gt; plus n (times n k')

def minus (n : Nat) (k : Nat) : Nat :=
  match k with
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; pred (minus n k')
</code></pre>
<p>すべての関数を構造的再帰を使って簡単に書くことができるわけではありません。 足し算を<code>Nat.succ</code>の繰り返し、かけ算を足し算の繰り返し、引き算を前任者の繰り返しとする理解から、割り算を引き算の繰り返しとして実装することを思いつくかもしれません。この場合、分子が除数より小さい場合、結果はゼロです。それ以外の場合は、結果は分子から除数を引いたものを除数で割った結果の後継者になります。</p>
<pre><code class="language-lean">def div (n : Nat) (k : Nat) : Nat :=
  if n &lt; k then
    0
  else Nat.succ (div (n - k) k)
</code></pre>
<p>二番目の引数が<code>0</code>でない限り、このプログラムは終了します。なぜなら常にベースケースに進むための進捗を作っているからです。しかし、それは構造的再帰ではありません。なぜなら、ゼロのための結果を見つけ、任意の<code>Nat</code>の結果をその後継者の結果に変換するというパターンに従っていないからです。 特に、関数の再帰的呼び出しが入力コンストラクタの引数に対してではなく別の関数呼び出しの結果に適用されるためです。したがって、Leanは次のメッセージを出してそれを拒否します：</p>
<pre><code class="language-output error">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>このメッセージは、<code>div</code>が手動での終了証明を必要とすることを意味しています。このトピックは<a href="getting-to-know/../programs-proofs/inequalities.html#division-as-iterated-subtraction">最終章</a>で詳しく探究されています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多相性"><a class="header" href="#多相性">多相性</a></h1>
<p>Leanにおいてもほとんどの言語と同様に、型は引数を取ることができます。
例えば、型 <code>List Nat</code> は自然数のリストを、<code>List String</code> は文字列のリストを、<code>List (List Point)</code> は点のリストのリストを表しています。
これはC#やJavaのような言語での <code>List&lt;Nat&gt;</code>、<code>List&lt;String&gt;</code>、あるいは <code>List&lt;List&lt;Point&gt;&gt;</code> によく似ています。
Leanでは関数に引数を渡すのに空白を使うのと同様に、型に引数を渡すのにも空白を使います。</p>
<p>関数型プログラミングにおいて、「<em>多相性（polymorphism）</em>」という用語は通常、型を引数として取るデータ型や定義を指します。
これはオブジェクト指向プログラミングコミュニティにおける用語の使い方とは異なります。オブジェクト指向プログラミングでは、スーパークラスの一部の振る舞いをオーバーライドするサブクラスを指しています。
この書籍では、「多相性」という言葉は常に最初の意味で使います。
これらの型引数は、データ型または定義内で使用され、引数の名前を他の型に置換することで、同じデータ型や定義を任意の型で使用することを可能にします。</p>
<p><code>Point</code> 構造体は <code>x</code> および <code>y</code> のフィールドが <code>Float</code> であることを要求します。
しかし、各座標に特定の表現を要求するものは何もありません。
型を引数として取る多相的な <code>Point</code> バージョン、それを <code>PPoint</code> と呼びますが、これはその両方のフィールドの型として引数の型を使用することができます。</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>関数定義の引数が定義された直後に書かれるのと同様に、構造体の引数は構造体の名前の直後に書かれます。
型引数の名前としてギリシャ文字を使用するのがLeanでは慣例ですが、それ以上に具体的な名前が思いつかない場合に限ります。
<code>Type</code> は他の型を記述する型ですので、<code>Nat</code>、<code>List String</code>、および <code>PPoint Int</code> はすべて <code>Type</code> 型を持っています。</p>
<p><code>List</code> と同様に、<code>PPoint</code> は特定の型を引数として提供することで使用できます。</p>
<pre><code class="language-lean">def natOrigin : PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }
</code></pre>
<p>この例では、両方のフィールドが <code>Nat</code> であることが期待されます。
関数がその引数変数を引数値に置き換えて呼び出されるように、<code>PPoint</code> に型 <code>Nat</code> を引数として提供すると、そのフィールド <code>x</code> と <code>y</code> の型が <code>Nat</code> になる構造体が得られます。これは引数名 <code>α</code> が引数型 <code>Nat</code> に置き換えられるからです。
型はLeanにおける普通の式なので、多相的型（<code>PPoint</code> のような）に引数を渡す際に特殊な構文は必要ありません。</p>
<p>定義もまた、型を引数として取ることができ、多相的になります。
<code>replaceX</code> 関数は <code>PPoint</code> の <code>x</code> フィールドを新しい値に置き換えます。
<code>replaceX</code> が <em>任意</em> の多相的な点で機能するためには、それ自体が多相的でなければなりません。
これは最初の引数が点のフィールドの型であり、後続の引数が最初の引数の名前を参照することで達成されます。</p>
<pre><code class="language-lean">def replaceX (α : Type) (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>言い換えれば、<code>point</code> と <code>newX</code> の型の引数が <code>α</code> を述べるとき、それらは <em>最初に提供された型であるどの型を指している</em> のです。
これは関数引数の名前がその関数の本体中に提供されたとき値を参照する方法と似ています。</p>
<p>これは <code>replaceX</code> の型をLeanにチェックさせた後、<code>replaceX Nat</code> の型をチェックさせることで確認できます。</p>
<pre><code class="language-lean">#check (replaceX)
</code></pre>
<pre><code class="language-output info">replaceX : (α : Type) → PPoint α → α → PPoint α
</code></pre>
<p>この関数型は最初の引数の <em>名前</em> を含み、型内の後続の引数はこの名前を参照します。
関数適用の値は、関数の本体内で提供される引数値に引数名を置き換えて見つかるように、関数適用の型は、関数の戻り型で提供される引数値に引数名を置き換えて見つかります。
最初の引数 <code>Nat</code> を提供することで、型の残りの部分にあるすべての <code>α</code> の出現が <code>Nat</code> に置き換えられます：</p>
<pre><code class="language-lean">#check replaceX Nat
</code></pre>
<pre><code class="language-output info">replaceX Nat : PPoint Nat → Nat → PPoint Nat
</code></pre>
<p>残りの引数が明示的に名付けられていないため、追加の引数が提供されてもさらなる置換は発生しません。</p>
<pre><code class="language-lean">#check replaceX Nat natOrigin
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin : Nat → PPoint Nat
</code></pre>
<pre><code class="language-lean">#check replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin 5 : PPoint Nat
</code></pre>
<p>型を引数として渡したという事実は、それを評価する能力には何の影響も与えません。</p>
<pre><code class="language-lean">#eval replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>多相的な関数は、名前付きの型引数を取り、後続の型が引数の名前を参照することによって機能します。
しかし、名前を付けることができるという特別なことは型引数にはありません。
前向きおよび後ろ向きのサインを示すデータ型が与えられた場合：</p>
<pre><code class="language-lean">inductive Sign where
  | pos
  | neg
</code></pre>
<p>サインが引数である関数を書くことができます。
引数が前向きの場合、関数は <code>Nat</code> を返し、後ろ向きの場合は <code>Int</code> を返します：</p>
<pre><code class="language-lean">def posOrNegThree (s : Sign) : match s with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
  match s with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)
</code></pre>
<p>型は第一級であり、Lean言語の通常のルールを使用して計算できるため、データ型に対するパターンマッチングによって計算することができます。
Leanがこの関数をチェックするとき、関数の本体での <code>match</code> 式を型での <code>match</code> 式に対応させることによって、<code>pos</code> の場合には <code>Nat</code> を予想される型とし、<code>neg</code> の場合には <code>Int</code> を予想される型とすることを使用します。</p>
<p><code>posOrNegThree</code> を <code>Sign.pos</code> に適用すると、関数の本体と戻り型にある引数名 <code>s</code> が <code>Sign.pos</code> に置き換えられます。
式とその型の両方で評価が行われることができます：</p>
<pre><code class="language-lean">(posOrNegThree Sign.pos : match Sign.pos with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((match Sign.pos with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)) :
 match Sign.pos with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((3 : Nat) : Nat)
===&gt;
3
</code></pre>
<h2 id="連結リスト"><a class="header" href="#連結リスト">連結リスト</a></h2>
<p>Leanの標準ライブラリには、<code>List</code> と呼ばれる正統的な連結リストのデータ型が含まれており、それを使用するのに便利な特殊な構文があります。
リストは角括弧で書かれます。
例えば、10未満の素数を含むリストは次のように書けます:</p>
<pre><code class="language-lean">def primesUnder10 : List Nat := [2, 3, 5, 7]
</code></pre>
<p>背後では、<code>List</code> は次のように定義された帰納的なデータ型です:</p>
<pre><code class="language-lean">inductive List (α : Type) where
  | nil : List α
  | cons : α → List α → List α
</code></pre>
<p>標準ライブラリにある実際の定義は少し異なりますが、まだ紹介されていない機能を使用しているためです。しかし、本質的には非常に似ています。
この定義によれば、<code>List</code> は<code>PPoint</code> と同様に単一の型を引数として取ります。
この型はリストに格納されるエントリの型です。
コンストラクタに従って、<code>List α</code> は <code>nil</code> または <code>cons</code> で作成できます。
コンストラクタ <code>nil</code> は空のリストを表し、<code>cons</code> コンストラクタは空でないリストに使用されます。
<code>cons</code> の最初の引数はリストの頭部であり、二番目の引数はその尾部です。
\( n \) 個のエントリを含むリストには \( n \) 個の <code>cons</code> コンストラクタが含まれ、最後のものには <code>nil</code> がその尾部になります。</p>
<p><code>primesUnder10</code> の例は、<code>List</code> のコンストラクタを直接使用してより明確に書くことができます:</p>
<pre><code class="language-lean">def explicitPrimesUnder10 : List Nat :=
  List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
</code></pre>
<p>これら二つの定義は完全に同等ですが、<code>primesUnder10</code> の方が <code>explicitPrimesUnder10</code> より読みやすいです。</p>
<p><code>List</code> を消費する関数は、<code>Nat</code> を消費する関数とほとんど同じように定義できます。
実際には、連結リストを考えるときには、それぞれの <code>succ</code> コンストラクタに余分なデータフィールドがぶら下がっている <code>Nat</code> としてそれを考えることができます。
この観点から、リストの長さを計算することは、それぞれの <code>cons</code> を <code>succ</code> に置き換え、最後の <code>nil</code> を <code>zero</code> に置き換えるプロセスです。
<code>replaceX</code> がポイントのフィールドの型を引数として取ったように、<code>length</code> はリストのエントリの型を引数として取ります。
たとえば、リストが文字列を含む場合、最初の引数は <code>String</code> です: <code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]</code>.
次のように計算すべきです:</p>
<pre><code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]
===&gt;
length String (List.cons &quot;Sourdough&quot; (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (length String (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (Nat.succ (length String List.nil))
===&gt;
Nat.succ (Nat.succ Nat.zero)
===&gt;
2
</code></pre>
<p><code>length</code> の定義は、リストエントリ型を引数として取るため多相的であり（多相性）、それ自体を参照するため再帰的です（再帰性）。
一般的に、関数はデータの形に従います：再帰的なデータ型は再帰的な関数を導き、多相的なデータ型は多相的な関数を導きます。</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | List.nil =&gt; Nat.zero
  | List.cons y ys =&gt; Nat.succ (length α ys)
</code></pre>
<p>変数の名前は <code>xs</code> や <code>ys</code> のように慣例的に使用され、不明な値のリストを意味します。
名前に <code>s</code> が付いていることで、それらが複数形であることを示し、それゆえ &quot;exes&quot; や &quot;whys&quot; と発音されるので、&quot;x s&quot; や &quot;y s&quot; ではなく発音されます。</p>
<p>リストの関数を読みやすくするために、<code>[]</code> のブラケット表記を <code>nil</code> に一致するパターンマッチに使用し、<code>cons</code> の代わりに接頭辞 <code>::</code> を使うことができます：</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length α ys)
</code></pre>
<h2 id="暗黙の引数"><a class="header" href="#暗黙の引数">暗黙の引数</a></h2>
<p><code>replaceX</code> や <code>length</code> は使用するのにやや官僚的です。なぜなら、型の引数は通常、後続の値によって一意に決定されるからです。
実際、ほとんどの言語ではコンパイラが自動的に型の引数を決定することができ、時々ユーザからの助けを必要とします。
Leanでも同様です。
関数定義時に、丸括弧の代わりに中括弧で引数を宣言することで引数を <em>暗黙的な</em> ものにすることができます。
たとえば、暗黙的な型引数を持つ <code>replaceX</code> のバージョンは以下のようになります：</p>
<pre><code class="language-lean">def replaceX {α : Type} (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>それは <code>natOrigin</code> を明示的に <code>Nat</code> を提供せず使用できます。なぜならLeanは後続の引数から <code>α</code> の値を <em>推論</em> できるからです：</p>
<pre><code class="language-lean">#eval replaceX natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>同様に、<code>length</code> を再定義してエントリ型を暗黙的に取ることができます：</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>この <code>length</code> 関数は <code>primesUnder10</code> に直接適用できます：</p>
<pre><code class="language-lean">#eval length primesUnder10
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>標準ライブラリでは、Leanはこの関数を <code>List.length</code> と呼びます。これは、構造体のフィールドアクセスに使用されるドット構文がリストの長さを見つけるためにも使用できることを意味します：</p>
<pre><code class="language-lean">#eval primesUnder10.length
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>Leanが常に暗黙の引数を見つけることができるわけではないため、C#やJavaと同様に、時には型引数を明示的に指定する必要があります。これらの場合、名前を使って提供することができます。
例えば、整数リスト専用の <code>List.length</code> を使用する場合、<code>α</code> を <code>Int</code> に設定して指定することができます：</p>
<pre><code class="language-lean">#check List.length (α := Int)
</code></pre>
<pre><code class="language-output info">List.length : List Int → Nat
</code></pre>
<h2 id="組み込みデータ型のさらなる活用"><a class="header" href="#組み込みデータ型のさらなる活用">組み込みデータ型のさらなる活用</a></h2>
<p>リストに加えて、Leanの標準ライブラリには様々なコンテキストで使用できる他の構造体や帰納的データ型が含まれています。</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p>全てのリストに最初のエントリが存在するわけではありません。一部のリストは空です。
コレクション上の操作は、探しているものを見つけられないことがあります。
例えば、リスト内の最初のエントリを探す関数が、そのようなエントリを見つけられない場合があるのです。
そのため、最初のエントリがない場合の信号を送る方法が必要です。</p>
<p>多くの言語には <code>null</code> 値があり、これは値が存在しないことを表します。
既存の型に特別な <code>null</code> 値を装備する代わりに、Leanは <code>Option</code> というデータ型を提供しており、他の型に欠落値の指標を備え付けます。
例えば、<code>Option Int</code> は <code>Int</code> のnull許容型を表し、<code>Option (List String)</code> は文字列のリストのnull許容型を表します。
新しい型を導入してnull可能性を表すことで、型システムは <code>null</code> のチェックを忘れることがないように保証します。なぜなら、<code>Option Int</code> は <code>Int</code> が期待されるコンテキストで使用することはできないからです。</p>
<p><code>Option</code> には、それぞれ非nullバージョンとnullバージョンを表す <code>some</code> および <code>none</code> という2つのコンストラクタがあります。
非nullコンストラクタである <code>some</code> には下層の値が含まれますが、<code>none</code> には引数がありません：</p>
<pre><code class="language-lean">inductive Option (α : Type) : Type where
  | none : Option α
  | some (val : α) : Option α
</code></pre>
<p><code>Option</code> 型は、C# や Kotlin などの言語における nullable 型ととても似ていますが、同一ではありません。
これらの言語では、ある型（例えば<code>Boolean</code>）が常にその型の実際の値（<code>true</code> および <code>false</code>）を指す場合、<code>Boolean?</code> や <code>Nullable&lt;Boolean&gt;</code> の型は追加で <code>null</code> 値を許容します。
型チェッカーと他のツールがnullのチェックを覚えているのを助けるこのシステムの追跡は非常に有用です。また、型署名を介してnull可能性を明示的に記述するAPIは、そうでないものよりも情報が豊富です。
しかし、これらのnullableな型は、Leanの <code>Option</code> と一つ非常に重要な方法で異なります。それは、複数のオプションの層を許さないということです。
<code>Option (Option Int)</code> を <code>none</code>、<code>some none</code>、または <code>some (some 360)</code> を使って構築することができます。
一方、C#は <code>?</code> を非null許容型にのみ加えることができるために、複数のnull許容層を禁じていますが、Kotlinは <code>T??</code> を <code>T?</code> と同等とみなしています。
この微妙な違いは実際にはほとんど関連性がありませんが、時々重要になることがあります。</p>
<p>リストの最初のエントリを、存在する場合に限って探すには <code>List.head?</code> を使用します。
クエスチョンマークは名称の一部であり、C# や Kotlin での nullable 型を示すクエスチョンマークの使用とは関係ありません。
<code>List.head?</code> の定義において、リストの尾部を表すためにアンダースコアが使用されています。
パターンでは、アンダースコアは一切のものにマッチしますが、マッチしたデータを参照するための変数を導入することはありません。
アンダースコアを代わりに名前として使用することで、入力の一部が無視されることを明確に読者に伝える方法です。</p>
<pre><code class="language-lean">def List.head? {α : Type} (xs : List α) : Option α :=
  match xs with
  | [] =&gt; none
  | y :: _ =&gt; some y
</code></pre>
<p>ヒント: コンテンツは多すぎるため、翻訳プロセスはここで完了していません。次に進むには、追加の指示をお願いします。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 追加の便利機能

Leanには、プログラムをより簡潔にするための便利機能が数多く含まれています。

## 自動的な暗黙の引数

Leanで多相関数を書くとき、通常はすべての暗黙の引数を列挙する必要はありません。
代わりに、単に言及することが可能です。
Leanがその型を判断できる場合は、自動的に暗黙の引数として挿入されます。
言い換えれば、以前の`length`の定義：
```lean
def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>は、<code>{α : Type}</code>を書かずに以下のように記述できます：</p>
<pre><code class="language-lean">def length (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>これは、多くの暗黙の引数を取る高度に多相的な定義を大幅に簡略化することができます。</p>
<h2 id="パターンマッチングによる定義"><a class="header" href="#パターンマッチングによる定義">パターンマッチングによる定義</a></h2>
<p><code>def</code>を使って関数を定義する際、引数に名前を付けてただちにパターンマッチングで使用することがよくあります。
例えば、<code>length</code>では、<code>xs</code>という引数が<code>match</code>内でのみ使用されます。
このような場面では、引数に名前を付けることなく、<code>match</code>式のケースを直接記述することができます。</p>
<p>最初のステップは、引数の型をコロンの右側に移動し、返り値の型が関数の型になるようにすることです。
例えば、<code>length</code>の型は<code>List α → Nat</code>です。
次に、<code>:=</code>の代わりにパターンマッチの各ケースを置き換えます：</p>
<pre><code class="language-lean">def length : List α → Nat
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>この構文は複数の引数を取る関数を定義するのにも使用できます。
この場合、そのパターンはコンマで区切られます。
例えば、<code>drop</code>は数\( n \)とリストを取り、リストから最初の\( n \)項目を削除したものを返します。</p>
<pre><code class="language-lean">def drop : Nat → List α → List α
  | Nat.zero, xs =&gt; xs
  | _, [] =&gt; []
  | Nat.succ n, x :: xs =&gt; drop n xs
</code></pre>
<p>名前付きの引数とパターンを同じ定義で使用することもできます。
例えば、デフォルト値とオプショナル値を取り、オプショナル値が<code>none</code>の場合にデフォルトを返す関数は次のように書けます：</p>
<pre><code class="language-lean">def fromOption (default : α) : Option α → α
  | none =&gt; default
  | some x =&gt; x
</code></pre>
<p>この関数は標準ライブラリでは<code>Option.getD</code>と呼ばれ、ドット記法を使って呼び出すことができます：</p>
<pre><code class="language-lean">#eval (some &quot;salmonberry&quot;).getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;salmonberry&quot;
</code></pre>
<pre><code class="language-lean">#eval none.getD &quot;&quot;
</code></pre>
<pre><code class="language-output info">&quot;&quot;
</code></pre>
<h2 id="ローカル定義"><a class="header" href="#ローカル定義">ローカル定義</a></h2>
<p>計算では、中間的なステップに名前を付けることがしばしば有用です。
多くの場合、中間値はそれ自体で有用な概念を表しており、明示的に名前を付けることでプログラムを読みやすくすることができます。
他の場合、中間値は複数回使用されます。
他のほとんどの言語と同じように、Leanでは同じコードを2回記述すると計算が2回行われますが、変数に結果を保存すると計算の結果が保存され再利用されます。</p>
<p>例えば、<code>unzip</code>はペアのリストをペアのリストに変換する関数です。
ペアのリストが空の場合、<code>unzip</code>の結果は空のリストのペアです。
ペアのリストの先頭にペアがある場合、そのペアの2つのフィールドはリストの残りの部分のunzipの結果に追加されます。
この<code>unzip</code>の定義はその説明に完全に従っています：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    (x :: (unzip xys).fst, y :: (unzip xys).snd)
</code></pre>
<p>残念ながら問題があります：このコードは必要以上に遅いです。
リストのペアの各エントリは2回の再帰呼び出しにつながり、この関数は指数的な時間を要します。
しかし、両方の再帰呼び出しは同じ結果になるため、再帰呼び出しを2回行う理由はありません。</p>
<p>Leanでは、<code>let</code>を使用することで再帰呼び出しの結果に名前を付け、保存することができます。
ローカル定義に使われる<code>let</code>は<code>def</code>を使ったトップレベル定義に似ています：ローカルで定義される名前、必要に応じて引数、型シグネチャがあり、その後に<code>:=</code>に続く本体が続きます。
ローカル定義が有効な式（<code>let</code>式の_body_と呼ばれる）は新しい行に書かれ、その行はファイル内の<code>let</code>キーワードのカラム以下である必要があります。
例えば、<code>unzip</code>では<code>let</code>を次のように使用できます：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let unzipped : List α × List β := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>単一行に<code>let</code>を使用するには、ローカル定義を本体からセミコロンで区切ります。</p>
<p>ローカル定義には、データ型のすべてのケースに一致する足りなるときにパターンマッチングを使用することもできます。
<code>unzip</code>のケースでは、再帰呼び出しの結果はペアです。
ペアには単一のコンストラクタしかないため、<code>unzipped</code>という名前をペアパターンで置き換えることができます：</p>
<pre><code class="language-lean">def unzip : List (α × β) → List α × List β
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    let (xs, ys) : List α × List β := unzip xys
    (x :: xs, y :: ys)
</code></pre>
<p><code>let</code>とパターンを慎重に使用することで、手作業でアクセサ呼び出しを書くよりもコードが読みやすくなることがあります。</p>
<p><code>let</code>と<code>def</code>の最大の違いは、再帰的な<code>let</code>定義は<code>let rec</code>と書くことによって明示的に示されなければならないことです。
例えば、リストを逆順にする一つの方法は再帰的なヘルパー関数を使用することです。この定義でのように：</p>
<pre><code class="language-lean">def reverse (xs : List α) : List α :=
  let rec helper : List α → List α → List α
    | [], soFar =&gt; soFar
    | y :: ys, soFar =&gt; helper ys (y :: soFar)
  helper xs []
</code></pre>
<p>ヘルパー関数は入力リストを下に進むと、一度に一つのエントリを<code>soFar</code>に移動します。
入力リストの終わりに到達すると、<code>soFar</code>は入力の逆順バージョンを含んでいます。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 要旨

## 式の評価

Leanでは、式を評価すると計算が行われます。
これは通常の数学的な式のルールに従い、サブ式が値に置き換えられ、操作の通常の順序に従って、式全体が値になるまで進む過程です。
`if` や `match` を評価する場合、分岐内の式は条件またはマッチ対象の値が得られるまで評価されません。

変数に一度値が与えられると、それは決して変わることはありません。
数学のように（しかし多くのプログラミング言語とは異なり）、Leanの変数は単に値のプレースホルダーであり、新しい値を書き込むアドレスではありません。
変数の値は、`def` を使ったグローバル定義、`let` を使ったローカル定義、関数への名前付き引数、またはパターンマッチングから得ることができます。

## 関数

Leanの関数は第一級の値であり、つまり他の関数への引数として渡されたり、変数に保存したり、他のどんな値と同じように使用することができます。
Leanの関数は正確にひとつの引数を取ります。
複数の引数を取る関数をエンコードするために、Leanはカリー化と呼ばれる技術を使用し、最初の引数を提供することで残りの引数を期待する関数を返します。
引数を取らない関数をエンコードするために、Leanは`Unit`型を使用します。これは最も情報量の少ない可能な引数です。

関数を作成する主な3つの方法は次のとおりです：
1. 匿名関数は `fun` を使用して書かれます。
   例えば、`Point` のフィールドを交換する関数は `fun (point : Point) =&gt; { x := point.y, y := point.x : Point }` として書かれることができます。
2. 非常に単純な匿名関数は、一つまたは複数の中点 `·` を括弧内に置いて書かれます。
   各中点は関数への引数となり、括弧はその本体を区切ります。
   例えば、引数から1を引く関数は、`fun x =&gt; x - 1` ではなく `(· - 1)` として書かれるかもしれません。
3. `def` や `let` を使用して、引数リストを追加したり、パターンマッチング記法を使用することで関数を定義することができます。

## 型

Leanは、すべての式が型を持っていることを確認します。
`Int`、`Point`、`{α : Type} → Nat → α → List α`、`Option (String ⊕ (Nat × String))` などの型は、式に最終的に見つかる可能性のある値を記述します。
他の言語のように、Leanの型はプログラムに対して軽量の仕様を表し、これによってLeanコンパイラーによってチェックされ、特定のクラスのユニットテストの必要性がなくなります。
しかしほとんどの言語とは異なり、Leanの型では任意の数学を表現することもでき、プログラミングと定理証明の世界を統一します。
本書では主にLeanを使用して定理を証明することは範囲外ですが、_[Theorem Proving in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)_ にはこのトピックに関する詳細情報が含まれています。

ある式には複数の型が与えられることがあります。
例えば、`3` は `Int` または `Nat` になり得ます。
Leanでは、これを同じ方法で書かれた `Nat` 型と `Int` 型の2つの別々の式として理解すべきであり、別々の型である同一のものとは考えないほうが良いです。

Leanは時々自動的に型を決定することができますが、しばしばユーザーによって型を提供される必要があります。
これはLeanの型システムが非常に表現力豊かであるからです。
Leanが型を見つけることができたとしても、望ましい型を見つけるとは限りません。`3`が`Int`として使われることを意図していても、それ以上の制約がなければLeanは`Nat`の型を与えます。
一般に、非常に明白な型を除き、ほとんどの型を明示的に書くことが賢明です。
これによりLeanのエラーメッセージが改善され、プログラマーの意図がより明確になります。

いくつかの関数やデータ型は型を引数として取ります。
これらは _多相的_ であると呼ばれます。
多相性は、リストの種類に関係なくリストの長さを計算するなどのプログラムを可能にします。
型はLeanでは第一級であるので、多相性は特別な構文を必要とせず、他の引数と同様に渡されます。
関数型に引数に名前を付けると、後の型がその引数を参照することができるようになり、その関数に引数を適用した型は、引数の名前を引数の値に置き換えることによって見つかります。

## 構造体と帰納型

新しいデータ型は、`structure` や `inductive` 機能を使用してLeanに導入することができます。
これらの新しい型は、定義が他と同一であったとしても、他のいかなる型とも等価だとは考えられません。
データ型には、その値を構築する方法を説明する _コンストラクタ_ があり、各コンストラクタはいくつかの引数を取ります。
Leanのコンストラクタはオブジェクト指向言語のコンストラクタと同じではありません：Leanのコンストラクタはデータの不活性な保持者であり、割り当てられたオブジェクトを初期化するアクティブなコードではありません。

典型的には、`structure` は積型（つまり、任意の数の引数を取るただ1つのコンストラクタを持つ型）を導入するために使用され、`inductive` は和型（つまり、多くの異なるコンストラクタを持つ型）を導入するために使用されます。
`structure` で定義されたデータ型は、コンストラクタの各引数に対して一つのアクセサ関数が提供されます。
構造体および帰納型データ型は、それらのコンストラクタに保持される値を露出するパターンマッチングを使用して消費することができ、パターンマッチングはそのコンストラクタを呼び出すために使用された構文の一部を使用します。
パターンマッチングは、値を作成する方法を知っていれば、それを消費する方法を知ることを意味します。

## 再帰

定義が再帰的であるとは、定義されている名前がその定義自体で使用されるときを指します。
Leanはプログラミング言語に加えて対話型定理証明器であるため、再帰的な定義にはある制限が課されます。
Leanの論理的な側面では、循環的な定義は論理的な矛盾につながる可能性があります。

再帰的な定義がLeanの論理的側面を損なうことがないように、Leanは、それがどのような引数で呼び出されても、すべての再帰的な関数が終了することを証明できなければなりません。
実践的には、これは再帰的な呼び出しがすべて入力の構造的に小さい部分に対して行われることを意味し、これにより常に基底ケースに向かって進行することが保証されるか、またはユーザーが関数が絶えず終了することを証明する他の何らかの証拠を提供しなければなりません。
同様に、帰納型は、型 _から_ 関数を引数として取るコンストラクタを持つことが許可されていません。なぜなら、これにより非終了する関数をエンコードすることができるからです。

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="こんにちは世界"><a class="header" href="#こんにちは世界">こんにちは、世界！</a></h1>
<p>Leanは豊かなインタラクティブ環境を備えており、プログラマは自分のお気に入りテキストエディタから離れることなく、言語から豊富なフィードバックを受け取ることができます。また、実際のプログラムを書くための言語でもあります。
つまり、バッチモードでのコンパイラ、ビルドシステム、パッケージマネージャ、およびプログラムを作成するためのその他の必要なツールを含んでいるわけです。</p>
<p><a href="./getting-to-know.html">前の章</a>で、Leanにおける関数型プログラミングの基本を紹介しましたが、この章ではプログラミングプロジェクトの開始、コンパイル、そしてその結果の実行方法について詳しく説明します。
標準入力からのデータを読み込んだりファイルを生成したりするなど、環境との対話を行いながら機能するプログラムは、計算を単なる数学的表現の評価として扱うことにはそぐわないことがあります。
そこでこの章では、Leanのビルドツールについて説明するだけでなく、世界と対話する関数型プログラムの考え方についても解説します。</p>
<div style="break-before: page; page-break-before: always;"></div><p>以下は、指定された <code>.md</code> ファイルを日本語に翻訳したものです。</p>
<hr />
<h1 id="プログラムの実行方法"><a class="header" href="#プログラムの実行方法">プログラムの実行方法</a></h1>
<p>Leanプログラムを実行するもっとも簡単な方法は、Lean実行ファイルに <code>--run</code> オプションを使用することです。
<code>Hello.lean</code> という名前のファイルを作成し、次の内容を入力します：</p>
<pre><code class="language-lean">def main : IO Unit := IO.println &quot;Hello, world!&quot;
</code></pre>
<p>次に、コマンドラインから以下を実行します：</p>
<pre><code>lean --run Hello.lean
</code></pre>
<p>プログラムは <code>Hello, world!</code> を表示して終了します。</p>
<h2 id="挨拶の構造"><a class="header" href="#挨拶の構造">挨拶の構造</a></h2>
<p><code>--run</code> オプションでLeanが呼び出されると、プログラムの <code>main</code> 定義を呼び出します。
コマンドライン引数を取らないプログラムでは、<code>main</code> は <code>IO Unit</code> 型であるべきです。
これは <code>main</code> が関数ではないことを意味しています。なぜなら、型に矢印（<code>→</code>）がないからです。
副作用を持つ関数であるのではなく、<code>main</code> は実行されるべき効果の説明です。</p>
<p><a href="hello-world/../getting-to-know/polymorphism.html">前の章</a>で議論されたように、<code>Unit</code> はもっともシンプルな帰納的型です。
引数を取らない単一のコンストラクタ <code>unit</code> を持っています。
C言語の伝統における言語は、値を全く返さない <code>void</code> 関数の概念を持っています。
Leanでは、すべての関数は引数を取り、値を返します。そして、興味深い引数や返り値がないことを表すために <code>Unit</code> 型を使用できます。
<code>Bool</code> が1ビットの情報を表すのに対し、<code>Unit</code> は0ビットの情報を表します。</p>
<p><code>IO α</code> は、実行されたときに、例外を投げるか型 <code>α</code> の値を返すプログラムの型です。
実行中、このプログラムは副作用を持つことがあります。
これらのプログラムは <code>IO</code> <em>アクション</em> と呼ばれます。
Leanは、副作用なしで変数の値の代数的置換と部分式の還元に厳密に従って式の <em>評価</em> と、世界とのやり取りに外部システムに依存する <code>IO</code> アクションの <em>実行</em> を区別します。
<code>IO.println</code> は、実行されると指定された文字列を標準出力に書き込む <code>IO</code> アクションへの文字列からの関数です。
このアクションは文字列を出力する過程で環境から興味深い情報を読み取らないため、<code>IO.println</code> は <code>String → IO Unit</code> 型です。
もし興味深いものを返すならば、それは <code>IO</code> アクションが <code>Unit</code> 以外の型を持っていると示されるでしょう。</p>
<h2 id="関数型プログラミング-vs-効果"><a class="header" href="#関数型プログラミング-vs-効果">関数型プログラミング vs 効果</a></h2>
<p>Leanの計算モデルは、変数が時間が経っても変わらない具体的な単一の値を与えられる数学的表現の評価に基づいています。
表現の評価結果は変わらず、同じ表現を再度評価しても常に同じ結果が得られます。</p>
<p>その一方で、実用的なプログラムは世界との相互作用が必要です。
入出力を行わないプログラムは、ユーザーからデータを要求したり、ディスク上にファイルを作成したり、ネットワーク接続を開始したりすることはできません。
そしてLean自体もLeanで記述されています。Leanコンパイラは確かにファイルを読み取り、ファイルを作成し、テキストエディタと対話しています。
同じ表現が常に同じ結果をもたらす言語は、ディスクから読み取るファイルの内容が時間とともに変わることがあるため、どのようにしてこれらのプログラムをサポートできるのでしょうか？</p>
<p>この明らかな矛盾は、副作用について少し異なる考え方をすることによって解決できます。
コーヒーやサンドイッチを売っているカフェを想像してください。
このカフェには、注文を満たすコックと顧客と対応し注文伝票を出すカウンターの従業員の2人がいます。
コックは気難しい性格で、外界との接触を本当に望まないが、カフェの看板商品である食べ物と飲み物を一貫して提供するのが得意です。しかしながら、このためには静かな環境が必要で、会話で邪魔されてはいけません。
カウンターの従業員は親しみやすいが、キッチンでは全く無能です。
顧客はカウンターの従業員と相互作用し、実際の調理をすべてコックに委託しています。
もしコックが顧客に質問がある場合、例えばアレルギーについて明確にしたい場合は、小さなメモをカウンターの従業員に送り、その従業員は顧客と相互作用し、結果をメモにしてコックに返すのです。</p>
<p>この例えで、コックはLean言語です。
注文があれば、コックは忠実かつ一貫して要求されたものを提供します。
カウンター従業員は、支払いを受け取り、食べ物を配布し、顧客と会話できる周囲のランタイムシステムです。
二人で協力することで、レストランのすべての機能を果たしていますが、それぞれの役割が分かれていて、自分が得意な仕事を実行しています。
顧客を遠ざけておくことでコックは本当に優れたコーヒーやサンドイッチ作りに集中できるように、Leanの副作用の欠如は、正式な数学的証明の一部としてプログラムが使われることを可能にします。
また、隠された状態変化がコンポーネント間で微妙なカップリングを作り出すことがないため、プログラマーは部品を互いに独立して理解することを助けます。
コックのメモは、Leanの式を評価することで生成される <code>IO</code> アクションを表し、カウンター従業員の返信は、効果から渡された値です。</p>
<p>この副作用のモデルは、Lean言語、そのコンパイラ、ランタイムシステム（RTS）の全体像と非常によく似ています。
ランタイムシステムにあるC言語で記述されたプリミティブは、すべての基本的な効果を実装しています。
プログラムを実行する際、RTSは <code>main</code> アクションを呼び出し、実行のための新しい <code>IO</code> アクションをRTSに返します。
RTSはこれらのアクションを実行し、計算を行うためにユーザーのLeanコードを使って委託します。
Leanの内部視点からは、プログラムは副作用がなく、<code>IO</code> アクションは実行されるべき仕事の単なる説明です。
プログラムのユーザーからの外部視点からは、プログラムの中核ロジックへのインターフェースを作成する副作用の層があります。</p>
<h2 id="実世界の関数型プログラミング"><a class="header" href="#実世界の関数型プログラミング">実世界の関数型プログラミング</a></h2>
<p>Leanにおける副作用について別の有益な考え方は、<code>IO</code> アクションを、全世界を引数として取り、新しい世界とペアになった値とする関数と考えることです。
この場合、標準入力からのテキスト行の読み取りは、毎回異なる世界が引数として提供されるため、純粋な関数です。
標準出力へのテキスト行の書き込みは、関数が始まった世界とは異なる世界を返すため、純粋な関数です。
プログラムは、決して世界を再利用したり、新しい世界を返却しないように注意する必要があります。これは結局、時間旅行または世界の終わりに他なりません。
注意深い抽象化の境界線は、このスタイルのプログラミングを安全にすることができます。
もしすべてのプリミティブ <code>IO</code> アクションが一つの世界を受け取り、新しいものを返し、そしてそれらがこの不変性を維持するツールでのみ組み合わせることができるならば、問題は発生しません。</p>
<p>このモデルは実装することはできません。
結局のところ、宇宙全体をLeanの値に変換してメモリに配置することはできません。
しかしながら、世界の抽象トークンを使ったこのモデルの変形を実装することは可能です。
プログラムが始まると、それに世界トークンが提供されます。
次に、このトークンはIOプリミティブに渡され、返されたトークンは次のステップに渡されます。
プログラムの末尾で、トークンはオペレーティングシステムに返却されます。</p>
<p>この副作用のモデルは、RTSによって実行されるタスクとしての <code>IO</code> アクションの説明がLean内部でどのように表現されるかの良い説明です。
実際の世界を変換する実際の関数は抽象化のバリアの後ろにあります。
しかし、実際のプログラムは通常、ただ一つではなく一連の効果から構成されています。
複数の効果を使用できるようにするために、<code>do</code>表記と呼ばれるLeanのサブ言語があり、これを使ってこれらのプリミティブな <code>IO</code> アクションをより大きく有用なプログラムに安全に組み合わせることができます。</p>
<h2 id="io-アクションの組み合わせ"><a class="header" href="#io-アクションの組み合わせ"><code>IO</code> アクションの組み合わせ</a></h2>
<p>ほとんどの有用なプログラムは出力を生成するだけでなく、入力も受け付けます。
さらに、入力に基づいて決定を下し、入力データを計算の一部として使用する場合があります。
以下のプログラムは <code>HelloName.lean</code> と呼ばれ、ユーザーに名前を尋ねてから挨拶します：</p>
<pre><code class="language-lean">def main : IO Unit := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace

  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>このプログラムでは、<code>main</code> アクションは <code>do</code> ブロックで構成されています。
このブロックは <em>ステートメント</em> のシーケンスを含んでおり、ローカル変数（<code>let</code> を使用して導入）と実行されるアクションの両方があります。
SQLがデータベースとの相互作用のための専用言語と考えることができるように、<code>do</code> 構文は命令型プログラムをモデル化するためにLean内の専用サブ言語と考えることができます。
<code>do</code> ブロックで構築された <code>IO</code> アクションは、順番にステートメントを実行することで実行されます。</p>
<p>このプログラムは、前のプログラムと同じ方法で実行できます：</p>
<pre><code>lean --run HelloName.lean
</code></pre>
<p>ユーザーが <code>David</code> と応答する場合、プログラムとのやり取りのセッションは以下のようになります：</p>
<pre><code>How would you like to be addressed?
David
Hello, David!
</code></pre>
<p>型シグネチャ行は <code>Hello.lean</code> に対するものと全く同じです：</p>
<pre><code class="language-lean">def main : IO Unit := do
</code></pre>
<p>唯一の違いは、命令のシーケンスを開始するキーワード <code>do</code> で終わることです。
キーワード <code>do</code> の後に続くインデントされた各行は、同じ命令のシーケンスの一部です。</p>
<p>最初の2行は以下の通りです：</p>
<pre><code class="language-lean">  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
</code></pre>
<p>それぞれライブラリのアクション <code>IO.getStdin</code> と <code>IO.getStdout</code> を実行することで <code>stdin</code> と <code>stdout</code> のハンドルを取得します。
<code>do</code> ブロック内では、<code>let</code> は通常の式の中での意味とは少し異なります。
通常、<code>let</code> のローカル定義は直後に続く一つの表現内でのみ使用できますが、<code>do</code> ブロックでは <code>let</code> によって導入されたローカル束縛は <code>do</code> ブロックの残りのすべてのステートメントで利用可能です。そして、通常、定義を行う際に<code>:=</code>を使って名前とその定義を結び付けますが、<code>do</code>ブロック内でのいくつかの<code>let</code>束縛は左矢印（<code>←</code>または<code>&lt;-</code>）を使用します。矢印を使用するということは、式の値が実行されるべき<code>IO</code>アクションであり、アクションの結果がローカル変数に保存されるべきだという意味です。つまり、矢印の右側の式が<code>IO α</code>型であれば、その変数は<code>do</code>ブロックの残りで<code>α</code>型として扱われます。<code>IO.getStdin</code>と<code>IO.getStdout</code>が<code>IO</code>アクションである理由は、プログラム内で<code>stdin</code>と<code>stdout</code>をローカルにオーバーライドできるようにするためです。これがC言語のようなグローバル変数だった場合、これらを意味ある方法でオーバーライドする手段はありませんが、<code>IO</code>アクションは実行のたびに異なる値を返すことができます。</p>
<p><code>do</code> ブロックの次の部分は、ユーザーから名前を尋ねるためのものです：</p>
<pre><code class="language-lean">  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
</code></pre>
<p>最初の行は質問を<code>stdout</code>に書き込み、次の行は<code>stdin</code>からの入力を求め、三番目の行は入力された行末の改行（およびその他の末尾の空白）を削除します。
<code>name</code>の定義は<code>←</code>ではなく<code>:=</code>を使用しています。それは<code>String.dropRightWhile</code>が<code>IO</code>アクションではなく、文字列に対する普通の関数だからです。</p>
<p>最後に、プログラムの最後の行は：</p>
<pre><code>  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>これは<a href="hello-world/../getting-to-know/conveniences.html#string-interpolation">string interpolation</a>を使用して提供された名前を挨拶文に挿入し、結果を<code>stdout</code>に書き込みます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ステップバイステップ"><a class="header" href="#ステップバイステップ">ステップ・バイ・ステップ</a></h1>
<p><code>do</code> ブロックは、1行ずつ実行することができます。
前のセクションからプログラムを始めましょう：</p>
<pre><code class="language-lean">  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<h2 id="標準io"><a class="header" href="#標準io">標準IO</a></h2>
<p>最初の行は <code>  let stdin ← IO.getStdin</code> ですが、残りは以下の通りです：</p>
<pre><code class="language-lean">  let stdout ← IO.getStdout
  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p><code>←</code> を使用している <code>let</code> 文を実行するには、まず矢印の右側にある表現（この場合は <code>IO.getStdIn</code>）を評価します。
この表現は単なる変数なので、その値は検索されます。
結果として得られる値は組み込みの基本的な <code>IO</code> アクションです。
次のステップは、この <code>IO</code> アクションを実行し、標準入力ストリームを表す値を得ることです。このタイプは <code>IO.FS.Stream</code> です。
標準入力は、矢印の左にある名前（ここでは <code>stdin</code>）に関連付けられ、<code>do</code> ブロックの残りの間使用されます。</p>
<p>二番目の行 <code>  let stdout ← IO.getStdout</code> の実行も同様に進みます。
まず、表現 <code>IO.getStdout</code> が評価され、標準出力を返す <code>IO</code> アクションが生成されます。
次に、このアクションが実行され、実際に標準出力が返されます。
最後に、この値は <code>do</code> ブロックの残りの間に名前 <code>stdout</code> に関連付けられます。</p>
<h2 id="質問をする"><a class="header" href="#質問をする">質問をする</a></h2>
<p><code>stdin</code> と <code>stdout</code> が見つかったので、ブロックの残りは質問とその答えから成り立っています：</p>
<pre><code class="language-lean">  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let input ← stdin.getLine
  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>ブロック内の最初の文 <code>  stdout.putStrLn &quot;How would you like to be addressed?&quot;</code> は表現から成っています。
表現を実行するには、まず評価されます。
この場合、<code>IO.FS.Stream.putStrLn</code> は <code>IO.FS.Stream → String → IO Unit</code> という型を持っています。
これは、ストリームと文字列を受け取り、<code>IO</code> アクションを返す関数です。
この表現は関数呼び出しに<a href="hello-world/../getting-to-know/structures.html#behind-the-scenes">アクセッサ記法</a>を使用しています。
この関数は二つの引数、標準出力ストリームと文字列を受け取って適用されます。
表現の値は、文字列と改行文字を出力ストリームに書き込む <code>IO</code> アクションです。
この値が見つかった次のステップは、それを実行し、文字列と改行が実際に <code>stdout</code> に書き込まれることです。
表現のみから成る文では、新しい変数は導入されません。</p>
<p>次の文 <code>  let input ← stdin.getLine</code> では、<code>IO.FS.Stream.getLine</code> は <code>IO.FS.Stream → IO String</code> という型を持っており、これはストリームから文字列を返す <code>IO</code> アクションへの関数を意味します。
これもアクセッサ記法の例です。
この <code>IO</code> アクションが実行され、プログラムはユーザーが入力行を完了するまで待ちます。
ユーザーが「<code>David</code>」と書いたと仮定します。
結果として得られた行（<code>&quot;David\n&quot;</code>）は <code>input</code> と関連付けられ、エスケープシーケンス <code>\n</code> は改行を示します。</p>
<pre><code class="language-lean">  let name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>次の行 <code>  let name := input.dropRightWhile Char.isWhitespace</code> は <code>let</code> 文です。
このプログラムの他の <code>let</code> 文とは異なり、<code>:=</code> を使用して <code>←</code> ではありません。
これは表現が評価されることを意味し、結果として得られる値は <code>IO</code> アクションである必要はなく、実行されません。
このケースでは、<code>String.dropRightWhile</code> は文字列と文字に対する述語を取り、述語を満たす文字がすべて取り除かれた新しい文字列を返します。
たとえば、</p>
<pre><code class="language-lean">#eval &quot;Hello!!!&quot;.dropRightWhile (· == '!')
</code></pre>
<p>は</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<p>を生成し、</p>
<pre><code class="language-lean">#eval &quot;Hello...   &quot;.dropRightWhile (fun c =&gt; not (c.isAlphanum))
</code></pre>
<p>は</p>
<pre><code class="language-output info">&quot;Hello&quot;
</code></pre>
<p>を生成します。この例では、文字列の右側からすべての非英数字文字が取り除かれます。
現在のプログラムの行では、空白文字（改行を含む）が入力文字列の右側から取り除かれ、「&quot;David&quot;」が結果として得られ、ブロックの残りの間 <code>name</code> と関連付けられます。</p>
<h2 id="ユーザーに挨拶する"><a class="header" href="#ユーザーに挨拶する">ユーザーに挨拶する</a></h2>
<p><code>do</code> ブロックで実行される残りの文は、単一の文です：</p>
<pre><code class="language-lean">  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p><code>putStrLn</code> への文字列引数は文字列補間を介して構築され、「&quot;Hello, David!&quot;」という文字列が生成されます。
この文が表現であるため、それは改行付きの標準出力にこの文字列を印刷する <code>IO</code> アクションを生成するための評価されます。
表現が評価された後、結果として得られる <code>IO</code> アクションが実行され、挨拶する結果になります。</p>
<h2 id="io-アクションの値として"><a class="header" href="#io-アクションの値として"><code>IO</code> アクションの値として</a></h2>
<p>上記の説明では、表現を評価すると「IO」アクションを実行するという区別が必要な理由を見るのが難しい可能性があります。
結局のところ、各アクションは生成された直後に実行されます。
他の言語で行われているように、評価中に効果を単に持ち出すのではないでしょうか？</p>
<p>答えは二つあります。
まず第一に、評価と実行を分けることで、プログラムはどの関数が副作用を持つことができるかについて明確にする必要があります。
プログラムの効果がない部分は、プログラマーの頭の中であれリーンのフォーマルプルーフの機能を使用している場合であれ、数学的推論により適しているため、この分離はバグを避けるのに役立つ可能性があります。
第二に、全ての <code>IO</code> アクションが存在する時に実行される必要はありません。
言及されたアクションを実行せずに済む機能により、普通の関数が制御構造として使用されます。</p>
<p>たとえば、関数 <code>twice</code> は <code>IO</code> アクションを引数としてとり、最初のものを2回実行する新しいアクションを返します。</p>
<pre><code class="language-lean">def twice (action : IO Unit) : IO Unit := do
  action
  action
</code></pre>
<p>たとえば、</p>
<pre><code class="language-lean">twice (IO.println &quot;shy&quot;)
</code></pre>
<p>を実行すると</p>
<pre><code class="language-output info">shy
shy
</code></pre>
<p>が印刷されます。
これは、基礎となるアクションを任意の回数実行するバージョンに一般化することができます：</p>
<pre><code class="language-lean">def nTimes (action : IO Unit) : Nat → IO Unit
  | 0 =&gt; pure ()
  | n + 1 =&gt; do
    action
    nTimes action n
</code></pre>
<p><code>Nat.zero</code> の基本ケースでは、結果は <code>pure ()</code> です。
関数 <code>pure</code> は副作用がない <code>IO</code> アクションを作成しますが、この場合は <code>pure</code> の引数、つまり <code>Unit</code> のコンストラクタを返します。
何もしないアクションとして何も興味深いものを返さない <code>pure ()</code> は、同時に完全につまらないと同時に非常に役立つものです。
再帰ステップでは、<code>do</code> ブロックを使用して、最初に <code>action</code> を実行し、次に再帰呼び出しの結果を実行するアクションを作成します。
<code>nTimes (IO.println &quot;Hello&quot;) 3</code> の実行は、次の出力を引き起こします:</p>
<pre><code class="language-output info">Hello
Hello
Hello
</code></pre>
<p>関数を制御構造として使用することに加えて、<code>IO</code> アクションが第一級の値である事実は、それらが後で実行するためにデータ構造に保存されることを意味します。
たとえば、関数 <code>countdown</code> は <code>Nat</code> を取り、各 <code>Nat</code> に対する未実行の <code>IO</code> アクションのリストを返します：</p>
<pre><code class="language-lean">def countdown : Nat → List (IO Unit)
  | 0 =&gt; [IO.println &quot;Blast off!&quot;]
  | n + 1 =&gt; IO.println s!&quot;{n + 1}&quot; :: countdown n
</code></pre>
<p>この関数には副作用がなく、何も印刷しません。
例えば、それは引数に適用され、結果のアクションリストの長さをチェックすることができます：</p>
<pre><code class="language-lean">def from5 : List (IO Unit) := countdown 5
</code></pre>
<p>このリストには6つの要素（各数字に1つずつ、そしてゼロのために「&quot;Blast off!&quot;」アクション）が含まれています：</p>
<pre><code class="language-lean">#eval from5.length
</code></pre>
<pre><code class="language-output info">6
</code></pre>
<p>関数 <code>runActions</code> はアクションのリストを取り、それらをすべて順番に実行する単一のアクションを構築します：</p>
<pre><code class="language-lean">def runActions : List (IO Unit) → IO Unit
  | [] =&gt; pure ()
  | act :: actions =&gt; do
    act
    runActions actions
</code></pre>
<p>その構造は <code>nTimes</code> のものと実質的に同じですが、<code>Nat.succ</code> の各々に実行されるのは1つのアクションではなく、<code>List.cons</code> の下にあるアクションが実行されることです。
同様に、<code>runActions</code> 自体はアクションを実行しません。
それはアクションを実行する新しいアクションを作成し、そのアクションは <code>main</code> の一部として実行される位置に置かれる必要があります：</p>
<pre><code class="language-lean">def main : IO Unit := runActions from5
</code></pre>
<p>このプログラムを実行すると、次の出力が得られます：</p>
<pre><code class="language-output info">5
4
3
2
1
Blast off!
</code></pre>
<p>このプログラムが実行されると、何が起こるでしょうか？
最初のステップは <code>main</code> を評価することです。それは次のようになります：</p>
<pre><code class="language-lean">main
===&gt;
runActions from5
===&gt;
runActions (countdown 5)
===&gt;
runActions
  [IO.println &quot;5&quot;,
   IO.println &quot;4&quot;,
   IO.println &quot;3&quot;,
   IO.println &quot;2&quot;,
   IO.println &quot;1&quot;,
   IO.println &quot;Blast off!&quot;]
===&gt;
do IO.println &quot;5&quot;
   IO.println &quot;4&quot;
   IO.println &quot;3&quot;
   IO.println &quot;2&quot;
   IO.println &quot;1&quot;
   IO.println &quot;Blast off!&quot;
   pure ()
</code></pre>
<p>結果として得られる <code>IO</code> アクションは <code>do</code> ブロックです。
<code>do</code> ブロックの各ステップは、次々に実行され、期待される出力が得られます。
最後のステップ、<code>pure ()</code> には効果がなく、<code>runActions</code> の定義に基本ケースが必要だからだけに存在します。</p>
<h2 id="練習問題-3"><a class="header" href="#練習問題-3">練習問題</a></h2>
<p>次のプログラムの実行を紙に書き出して、ステップごとにたどりましょう：</p>
<pre><code class="language-lean">def main : IO Unit := do
  let englishGreeting := IO.println &quot;Hello!&quot;
  IO.println &quot;Bonjour!&quot;
  englishGreeting
</code></pre>
<p>プログラムの実行を追跡している間に、表現が評価されている時と <code>IO</code> アクションが実行されている時を識別します。
<code>IO</code> アクションの実行が副作用を引き起こす場合は、それを書き留めます。
これを行った後、Leanでプログラムを実行し、副作用に関してあなたの予測が正しかったかを再確認してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プロジェクトの開始"><a class="header" href="#プロジェクトの開始">プロジェクトの開始</a></h1>
<p>Leanで書かれたプログラムがより本格的になるにつれて、事前にコンパイルされたワークフローで実行ファイルを生成する方法が魅力的になってきます。
他の言語と同じように、Leanには複数のファイルパッケージをビルドし依存関係を管理するツールがあります。
標準のLeanビルドツールはLake（&quot;Lean Make&quot;の略称）と呼ばれ、Leanで設定されています。
Leanに効果的なプログラミングを行うための特殊言語（<code>do</code>言語）があるように、Lakeにはビルドを設定するための特別な言語が含まれています。
これらの言語は_埋め込みドメイン固有言語_ （または時々 <em>ドメイン固有埋め込み言語</em>、EDSLまたはDSELと略されます）と呼ばれます。
これらはドメイン固有の意味で、ある特定の目的のために使用され、あるサブドメインの概念を利用し、通常は汎用プログラミングには適さないものです。
そして、これらは他の言語の構文の中に埋め込まれるため_埋め込み型_です。
LeanにはEDSLを作成するための豊富な機能が含まれていますが、それらはこの本の範囲を超えています。</p>
<h2 id="最初のステップ"><a class="header" href="#最初のステップ">最初のステップ</a></h2>
<p>Lakeを使ったプロジェクトを始めるには、<code>greeting</code>という名前のファイルやディレクトリが既に存在しないディレクトリで <code>lake new greeting</code> コマンドを使用します。
これにより、以下のファイルが含まれる <code>greeting</code> というディレクトリが作成されます：</p>
<ul>
<li><code>Main.lean</code> は、Leanコンパイラが <code>main</code> アクションを探すファイルです。</li>
<li><code>Greeting.lean</code> および <code>Greeting/Basic.lean</code> はプログラムのサポートライブラリの基盤です。</li>
<li><code>lakefile.lean</code> には、アプリケーションをビルドするために <code>lake</code> が必要とする構成が含まれています。</li>
<li><code>lean-toolchain</code> には、プロジェクトに使用されるLeanの特定のバージョンが識別子として含まれています。</li>
</ul>
<p>また、<code>lake new</code> はプロジェクトをGitリポジトリとして初期化し、その <code>.gitignore</code> ファイルを設定してビルドの中間生成物を無視するように構成します。
通常、アプリケーションロジックの大部分はプログラムのライブラリコレクションにあり、<code>Main.lean</code> にはコマンドラインを解析したり中心的なアプリケーションロジックを実行するなどのことを行う小さなラッパーが含まれています。
既存のディレクトリでプロジェクトを作成するには、<code>lake new</code> の代わりに <code>lake init</code> を実行します。</p>
<p>デフォルトでは、ライブラリファイル <code>Greeting/Basic.lean</code> には1つの定義が含まれています：</p>
<pre><code class="language-lean">def hello := &quot;world&quot;
</code></pre>
<p>ライブラリファイル <code>Greeting.lean</code> は <code>Greeting/Basic.lean</code> をインポートします：</p>
<pre><code class="language-lean">{{#file_contents {lake} {first-lake/greeting/Greet</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="実例-cat"><a class="header" href="#実例-cat">実例: <code>cat</code></a></h1>
<p>標準的なUnixユーティリティ<code>cat</code>は、いくつかのコマンドラインオプションを受け取り、続いてゼロ個以上の入力ファイルを受け取ります。
ファイルが提供されていない場合、またはいずれかがダッシュ（<code>-</code>）である場合、ファイルを読み込む代わりに標準入力を対応する入力として受け取ります。
入力の内容は、一つずつ、標準出力に書きだされます。
指定された入力ファイルが存在しない場合、そのことは標準エラーに表示されますが、<code>cat</code>は残りの入力の連結を続けます。
どれかの入力ファイルが存在しない場合は、非ゼロの終了コードが返されます。</p>
<p>このセクションでは、<code>cat</code>の簡易版である<code>feline</code>について説明します。
一般的に使用される<code>cat</code>とは異なり、<code>feline</code>には行番号を付ける、印刷不可能な文字を示す、ヘルプテキストを表示するなどのコマンドラインオプションはありません。
さらに、端末デバイスに関連付けられている標準入力から複数回読み取ることはできません。</p>
<p>このセクションを最大限活用するには、自分で一緒に行うことをお勧めします。
コード例をコピー＆ペーストするのでも構いませんが、手でタイピングする方がさらに良いでしょう。
これにより、コードをタイピングするプロセスを学び、ミスから回復し、コンパイラーからのフィードバックを解釈することが容易になります。</p>
<h2 id="始め方"><a class="header" href="#始め方">始め方</a></h2>
<p><code>feline</code>を実装する最初のステップは、パッケージを作成し、コードをどのように構成するかを決めることです。
この場合、プログラムが非常にシンプルなため、すべてのコードを<code>Main.lean</code>に配置します。
最初のステップは、<code>lake new feline</code>を実行することです。
Lakefileを編集してライブラリを削除し、生成されたライブラリコードとその参照を<code>Main.lean</code>から削除します。
これが完了すると、<code>lakefile.lean</code>は以下を含んでいる必要があります：</p>
<pre><code class="language-lean">import Lake
open Lake DSL

package «feline» {
  -- add package configuration options here
}

@[default_target]
lean_exe «feline» {
  root := `Main
}
</code></pre>
<p>そして<code>Main.lean</code>には以下のような内容が含まれているはずです：</p>
<pre><code class="language-lean">def main : IO Unit :=
  IO.println s!&quot;Hello, cats!&quot;
</code></pre>
<p>代わりに、<code>lake new feline exe</code>を実行することで、ライブラリセクションを含まないテンプレートを<code>lake</code>に使わせることができ、ファイルを編集する必要がなくなります。</p>
<p>コードのビルドが可能であることを確認するには、<code>lake build</code>を実行してください。</p>
<h2 id="ストリームの連結"><a class="header" href="#ストリームの連結">ストリームの連結</a></h2>
<p>プログラムの基本的な骨組みができたので、実際にコードを入力する時が来ました。
正しい<code>cat</code>の実装は、<code>/dev/random</code>のような無限のIOストリームでも使用できるものです。これは出力する前に入力をメモリに読み込むことはできないことを意味します。
さらに、文字ごとに処理を実行するべきではありません。それはイライラするほど遅いパフォーマンスにつながります。
代わりに、一度に連続するデータブロック全体を読み取り、データを一度に一つのブロックとして標準出力に送信する方がより良いです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追加の便利機能"><a class="header" href="#追加の便利機能">追加の便利機能</a></h1>
<h2 id="ネストされたアクション"><a class="header" href="#ネストされたアクション">ネストされたアクション</a></h2>
<p><code>feline</code> の多くの関数では、<code>IO</code> アクションの結果に名前をつけて、すぐさま一度だけ使用するという繰り返しパターンが見られます。
例えば、 <code>dump</code> では以下のようになります。</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    let stdout ← IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>このパターンは <code>stdout</code> で発生しています。</p>
<pre><code class="language-lean">    let stdout ← IO.getStdout
    stdout.write buf
</code></pre>
<p>同様に、<code>fileStream</code> には以下のスニペットが含まれています。</p>
<pre><code class="language-lean">  let fileExists ← filename.pathExists
  if not fileExists then
</code></pre>
<p>Lean が <code>do</code> ブロックをコンパイルする際、かっこ直下の左矢印で構成される表現は最も近い外側の <code>do</code> にリフトされ、その結果は一意の名前に束縛されます。
この一意の名前は表現の元に置き換えられます。
これにより、<code>dump</code> は次のように書くこともできます。</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    (← IO.getStdout).write buf
    dump stream
</code></pre>
<p>このバージョンの <code>dump</code> では、一度だけ使用される名前を導入することを避けられるため、プログラムを大幅に簡素化することができます。
Lean がネストした式コンテキストからリフトする <code>IO</code> アクションは <em>ネストされたアクション</em> と呼ばれます。</p>
<p><code>fileStream</code> も同じテクニックを使って簡略化することができます。</p>
<pre><code class="language-lean">def fileStream (filename : System.FilePath) : IO (Option IO.FS.Stream) := do
  if not (← filename.pathExists) then
    (← IO.getStderr).putStrLn s!&quot;File not found: {filename}&quot;
    pure none
  else
    let handle ← IO.FS.Handle.mk filename IO.FS.Mode.read
    pure (some (IO.FS.Stream.ofHandle handle))
</code></pre>
<p>この場合、<code>handle</code> のローカル名もネストされたアクションを使って排除することができたかもしれませんが、その結果表現は長くて複雑になっていたでしょう。
ネストされたアクションを使うことはしばしば良いスタイルですが、中間結果に名前を付けることが依然として役立つことがあります。</p>
<p>しかし、ネストされたアクションはあくまで周囲の <code>do</code> ブロックで発生する <code>IO</code> アクションのための短い記法に過ぎないことを覚えておくことは重要です。
実行によって発生する副作用は同じ順番で発生し、副作用の実行は式の評価と交互には行われません。
これが混乱を招く例として、以下に実行されたことを世界に告げるデータを返すヘルパー定義を挙げてみましょう。</p>
<pre><code class="language-lean">def getNumA : IO Nat := do
  (← IO.getStdout).putStrLn &quot;A&quot;
  pure 5

def getNumB : IO Nat := do
  (← IO.getStdout).putStrLn &quot;B&quot;
  pure 7
</code></pre>
<p>これらの定義は、ユーザー入力を検証したり、データベースを読んだり、ファイルを開いたりするかもしれないより複雑な <code>IO</code> コードの代わりを意図しています。</p>
<p>A の数が 5 の場合は <code>0</code> を、それ以外の場合は B の数を印刷するプログラムは以下のように書かれます。</p>
<pre><code class="language-lean">def test : IO Unit := do
  let a : Nat := if (← getNumA) == 5 then 0 else (← getNumB)
  (← IO.getStdout).putStrLn s!&quot;The answer is {a}&quot;
</code></pre>
<p>しかし、このプログラムは意図されていたものよりも副作用（例えばユーザー入力へのプロンプトやデータベースの読み取りなど）を持っているかもしれません。
<code>getNumA</code> の定義は、それが常に <code>5</code> を返すことを明確にしており、したがってプログラムは B の数を読まないはずです。
しかし、プログラムを実行すると次の出力が得られます。</p>
<pre><code class="language-output info">A
B
The answer is 0
</code></pre>
<p><code>getNumB</code> が実行されたのは、<code>test</code> がこの定義と等しいからです。</p>
<pre><code class="language-lean">def test : IO Unit := do
  let x ← getNumA
  let y ← getNumB
  let a : Nat := if x == 5 then 0 else y
  (← IO.getStdout).putStrLn s!&quot;The answer is {a}&quot;
</code></pre>
<p>これはネストされたアクションが <em>最も近い外側の</em> <code>do</code> ブロックにリフトされるというルールによるものです。
<code>if</code> の分岐は <code>do</code> ブロックでそれ自体がステートメントでないため、暗黙のうちに <code>do</code> ブロックでラップされていませんでした—ステートメントは <code>a</code> を定義する <code>let</code> でした。
事実、そのようなラップはできなかったのです。なぜなら条件式の型は <code>Nat</code> であり、<code>IO Nat</code> ではないからです。</p>
<h2 id="do-のための柔軟なレイアウト"><a class="header" href="#do-のための柔軟なレイアウト"><code>do</code> のための柔軟なレイアウト</a></h2>
<p>Lean での <code>do</code> 式は空白に敏感です。
<code>do</code> 内の各 <code>IO</code> アクションまたはローカル束縛は、それぞれ独自の行で開始されることが期待されており、すべて同じインデントを持つべきです。
ほとんどすべての <code>do</code> の使用はこの方法で書かれるべきです。
しかし、まれに手動で空白やインデントを制御する必要がある場合や、多くの小さなアクションを単一行にまとめて便利と感じる場合もあります。
そのような場合、改行はセミコロンに置き換えることができ、インデントは中括弧に置き換えることができます。</p>
<p>例えば、以下のすべてのプログラムは等価です。</p>
<pre><code class="language-lean">-- This version uses only whitespace-sensitive layout
def main : IO Unit := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let name := (← stdin.getLine).trim
  stdout.putStrLn s!&quot;Hello, {name}!&quot;

-- This version is as explicit as possible
def main : IO Unit := do {
  let stdin ← IO.getStdin;
  let stdout ← IO.getStdout;

  stdout.putStrLn &quot;How would you like to be addressed?&quot;;
  let name := (← stdin.getLine).trim;
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
}

-- This version uses a semicolon to put two actions on the same line
def main : IO Unit := do
  let stdin ← IO.getStdin; let stdout ← IO.getStdout

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  let name := (← stdin.getLine).trim
  stdout.putStrLn s!&quot;Hello, {name}!&quot;
</code></pre>
<p>慣用的な Lean コードでは <code>do</code> で中括弧を使うことは非常にまれです。</p>
<h2 id="eval-を使った-io-アクションの実行"><a class="header" href="#eval-を使った-io-アクションの実行"><code>#eval</code> を使った <code>IO</code> アクションの実行</a></h2>
<p>Lean の <code>#eval</code> コマンドは、<code>IO</code> アクションを実行するために使用することができるだけでなく、評価するためにも使用されます。
通常、Lean ファイルに <code>#eval</code> コマンドを追加すると、Lean は提供された式を評価し、結果として得られる値を文字列に変換し、ツールチップと情報ウィンドウにその文字列を表示します。
<code>IO</code> アクションは文字列に変換することができないため失敗するのではなく、<code>#eval</code> はそれらを実行し、それらの副作用を実行します。
実行の結果が <code>Unit</code> 値 <code>()</code> の場合、結果の文字列は表示されませんが、文字列に変換できる型である場合は、Lean は結果として得られる値を表示します。</p>
<p>これは、以前の <code>countdown</code> と <code>runActions</code> の定義を考えると、</p>
<pre><code class="language-lean">#eval runActions (countdown 3)
</code></pre>
<p>は以下を表示します。</p>
<pre><code class="language-output info">3
2
1
Blast off!
</code></pre>
<p>これは <code>IO</code> アクションを実行したことによって得られた出力であり、アクション自体の不透明な表現ではありません。
言い換えれば, <code>IO</code> アクションに対しては、<code>#eval</code> は提供された式を <em>評価</em> だけでなく、結果として得られるアクション値を <em>実行</em> します。</p>
<p><code>#eval</code> を使って <code>IO</code> アクションを素早くテストすることは、プログラム全体をコンパイルして実行するよりもはるかに便利です。
しかし、いくつかの制限があります。
例えば、標準入力からの読み取りは単に空の入力を返すことになります。
さらに、<code>IO</code> アクションは Lean がユーザーに提供する診断情報を更新する必要があるたびに再実行され、これは予測不可能なタイミングで発生することがあります。
ファイルの読み書きを行うアクションは、例えば、不便なタイミングでそうするかもしれません。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 概要

## 評価と実行

副作用とは、ファイルの読み込み、例外の投げ、工業機械の発動など、数学的表現の評価を超えたプログラム実行の側面を指します。
ほとんどの言語では評価中に副作用が発生可能ですが、Leanはそうではありません。
代わりにLeanには`IO`という型があり、副作用を使用するプログラムの_記述_を表しています。
これらの記述は、特定の計算を行うためにLean式の評価器を呼び出す言語の実行時システムによって実行されます。
型`IO α`の値は_`IO`アクション_と呼ばれます。
最も簡単なのは`pure`で、その引数を返し、実際の副作用はありません。

`IO`アクションは、全世界を引数として取り、副作用が発生した新しい世界を返す関数としても理解することができます。
`IO`ライブラリは、裏では世界が二重に、作られたり、破壊されたりすることはないように保証しています。
この副作用モデルは実際には実装できません。なぜなら全宇宙がメモリに収まりきるほど小さくはないからです。しかし現実世界は、プログラムを通じて渡されるトークンによって表されることができます。

プログラムが開始されるとき、`IO`アクション`main`が実行されます。
`main`は3つの型のうちの1つを持つことができます：
 * `main : IO Unit`は、コマンドライン引数を読むことができず常に退出コード`0`を返す簡単なプログラムに使用されます。
 * `main : IO UInt32`は、成功や失敗をシグナルすることができるが引数を取らないプログラムに使用されます。
 * `main : List String → IO UInt32`は、コマンドライン引数を取り、成功や失敗をシグナルするプログラムに使用されます。

## `do`記法

Lean標準ライブラリは、ファイルの読み込み・書き込みや標準入力・標準出力との対話など、副作用を代表とする基本的な`IO`アクションを提供します。
これらの基本的な`IO`アクションを使い、`do`記法を使用して大きな`IO`アクションに構成します。`do`記法は、副作用を持つプログラムの記述を作成するための組み込みのドメイン特化言語です。
`do`式は、_ステートメント_のシーケンスを含みます。これらは次のものがあります：
 * `IO`アクションを代表する式、
 * `let`と`:=`を使った通常のローカル定義は、提供された式の値を参照する名前を定義します。
 * `let`と`←`を使ったローカル定義は、提供された式の値を実行する結果を参照する名前を定義します。

`do`で書かれた`IO`アクションは、一つのステートメントずつ実行されます。

さらに、`do`の直下にある`if`や`match`式は、各ブランチに独自の`do`があるかのように暗黙的に考慮されます。
`do`式の内部では、_ネストされたアクション_は左矢印が直接カッコの下にある式です。
Leanコンパイラはそれらを最も近い包含する`do`まで暗黙的に持ち上げ、その後それらに一意な名前を与えます。
この一意な名前が、ネストされたアクションの原始的な場所に置き換えられます。

## プログラムのコンパイルと実行

`main`定義で構成される単一ファイルのLeanプログラムは`lean --run FILE`を使用して実行できます。
これはシンプルなプログラムを素早く始める良い方法ですが、ほとんどのプログラムは最終的に複数ファイルのプロジェクトになり、実行する前にコンパイルする必要があります。

Leanプロジェクトは、依存関係とビルド設定に関する情報を含めたライブラリと実行可能ファイルのコレクションである_パッケージ_によって構成されます。
パッケージはLeanビルドツールであるLakeを使って記述されます。
新しいディレクトリでLakeパッケージを作成するには`lake new`を使用し、また現在のディレクトリで作成するには`lake init`を使用します。
Lakeパッケージ構成は別のドメイン特化言語です。
プロジェクトをビルドするには`lake build`を使用します。

## 部分性

表現の評価の数学的モデルを守るための一つの結果は、すべての式が値を持つ必要があるということです。
これは、データ型のすべてのコンストラクタを網羅していない不完全なパターンマッチ、および無限ループに陥る可能性のあるプログラムを除外します。
Leanはすべての`match`式がすべてのケースを網羅し、すべての再帰関数が構造的に再帰的であるか終了の明示的な証明を持っていることを保証します。

ただし、POSIXストリームのような無限データを処理するために、実際に無限にループする可能性があるプログラムが必要な場合があります。
Leanは逃げ路を提供します：`partial`とマークされた関数の定義は終了する必要はありません。
これにはコストが伴います。
型がLean言語の第一級の一部であるため、関数は型を返すことができます。
しかし、部分関数は型チェック中に評価されません。なぜなら無限ループに陥る関数は型チェッカーを無限ループに結びつける可能性があるからです。
さらに、部分関数の定義を検査できない数学的証明は、それを使用するプログラムの形式的証明にはあまり適していません。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="休憩命題証明及び添字付け"><a class="header" href="#休憩命題証明及び添字付け">休憩：命題、証明、及び添字付け</a></h1>
<p>多くの言語同様、Leanでは配列やリストへの添字付けに角括弧を使用します。
例えば、<code>woodlandCritters</code>が下記のように定義されている場合：</p>
<pre><code class="language-lean">def woodlandCritters : List String :=
  [&quot;hedgehog&quot;, &quot;deer&quot;, &quot;snail&quot;]
</code></pre>
<p>その個々の要素を取り出すことができます：</p>
<pre><code class="language-lean">def hedgehog := woodlandCritters[0]
def deer := woodlandCritters[1]
def snail := woodlandCritters[2]
</code></pre>
<p>しかし、４番目の要素を取り出そうとすると、実行時エラーではなくコンパイル時エラーが発生します：</p>
<pre><code class="language-lean">def oops := woodlandCritters[3]
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 3 &lt; List.length woodlandCritters
</code></pre>
<p>このエラーメッセージは、Leanが<code>3 &lt; List.length woodlandCritters</code>であることを自動的に証明しようとしたができなかったことを意味しています。つまり、インデックス参照が安全という証明です。範囲外エラーは一般的なバグの一種で、Leanはプログラミング言語及び定理証明者としての二重の性質を活かし、これらを可能な限り排除しようとしています。</p>
<p>これがどのように機能するかを理解するため、命題、証明、及び戦術という３つの重要な概念を理解する必要があります。</p>
<h2 id="命題と証明"><a class="header" href="#命題と証明">命題と証明</a></h2>
<p><em>命題</em> は、真か偽かのどちらか一方である文です。
以下はすべて命題です：</p>
<ul>
<li>1 + 1 = 2</li>
<li>加法は可換である</li>
<li>素数は無限に存在する</li>
<li>1 + 1 = 15</li>
<li>パリはフランスの首都である</li>
<li>ブエノスアイレスは韓国の首都である</li>
<li>すべての鳥は飛ぶことができる</li>
</ul>
<p>一方、意味不明の文は命題ではありません。
以下はどれも命題ではありません：</p>
<ul>
<li>1 + 緑 = アイスクリーム</li>
<li>すべての首都は素数である</li>
<li>少なくとも一つのゴーグがフリープである</li>
</ul>
<p>命題には２種類あります。一つは純粋に数学的で、概念の定義のみに依存するものです。もう一つは世界についての事実に基づくものです。
Leanのような定理証明者は、前者のカテゴリに関心があり、ペンギンの飛翔能力や都市の法的地位については言及しません。</p>
<p><em>証明</em> は、ある命題が真であることを納得させる議論です。
数学的命題に対するこれらの議論は関連する概念の定義と論理的な議論のルールを使用して行われます。
ほとんどの証明は人が理解するために書かれており、多くの細かい詳細を省いています。
Leanのようなコンピュータ支援定理証明者は、数学者が証明を書く時に多くの細部を省くことを可能にするようデザインされており、そのソフトウェアは欠けている明示的なステップを補います。
これにより、見落としやミスの可能性が減ります。</p>
<p>Leanでは、プログラムの型は、それをどのように操作できるかを記述します。
例えば、<code>Nat → List String</code>という型のプログラムは、<code>Nat</code>の引数を取って文字列のリストを生成する関数です。
言い換えれば、それぞれの型はその型のプログラムとして何が数え上げられるかを指定します。</p>
<p>Leanでは、命題も実際には型です。
それらはその宣言が真であるとする証拠として何が数え上げられるかを指定します。
その証拠を提示することで命題は証明されます。
一方で、命題が偽である場合、その証拠を構築することは不可能です。</p>
<p>例えば、「1 + 1 = 2」という命題はLeanで直接書き表すことができます。
この命題の証拠はコンストラクタ<code>rfl</code>であり、これは_反射律_を意味します：</p>
<pre><code class="language-lean">def onePlusOneIsTwo : 1 + 1 = 2 := rfl
</code></pre>
<p>一方で、<code>rfl</code>は偽の命題「1 + 1 = 15」を証明することはできません：</p>
<pre><code class="language-lean">def onePlusOneIsFifteen : 1 + 1 = 15 := rfl
</code></pre>
<pre><code class="language-output error">type mismatch
  rfl
has type
  1 + 1 = 1 + 1 : Prop
but is expected to have type
  1 + 1 = 15 : Prop
</code></pre>
<p>このエラーメッセージは、「1 + 1」が直接「2」に評価されるため、<code>rfl</code>は二つの式が等しいことを証明できるのは両辺が同じ数である時だけであることを示しています。これにより、<code>onePlusOneIsTwo</code>が受け入れられることになります。
ちょうど<code>Type</code>が<code>Nat</code>、<code>String</code>、<code>List (Nat × String × (Int → Float))</code>などのデータ構造と関数を表す型を記述するように、<code>Prop</code>は命題を記述します。</p>
<p>命題が証明されたとき、それは_定理_と呼ばれます。
Leanでは、定理を宣言する場合、<code>def</code>の代わりに<code>theorem</code>キーワードで宣言するのが一般的です。
これにより、読者にとって、どの宣言が数学的証明で読むべきものであり、どの宣言が定義で読むべきかを識別しやすくなります。
一般に、証明では命題が真である証拠があることが重要で、提供されたのが_どの_証拠であるかはあまり重要ではありません。<br />
一方、定義では、明らかに間違った加法の定義は常に0を返すので、選ばれた値が非常に重要です。</p>
<p>上記の例は次のように書き換えることができます：</p>
<pre><code class="language-lean">def OnePlusOneIsTwo : Prop := 1 + 1 = 2

theorem onePlusOneIsTwo : OnePlusOneIsTwo := rfl
</code></pre>
<h2 id="戦術"><a class="header" href="#戦術">戦術</a></h2>
<p>戦術は、<em>戦術_を使用して書かれることが一般的です。直接的な証拠を提供する代わりに戦術を使って証拠を構築します。
戦術は、証明すべき文（<em>目標（ゴール）</em> と呼ばれる）と、それを証明するために利用可能な前提を監視する_証明状態</em> で動作します。
戦術をゴールに適用すると、新しい目標（ゴール）が含まれた新たな証明状態になります。
すべての目標（ゴール）が証明された時点で証明は完成です。</p>
<p>戦術で証明を書くためには、定義の始めに<code>by</code>を記述します。
<code>by</code>を用いると、次のインデントされたブロックの最後までLeanは戦術モードに入ります。
戦術モードでは、Leanは現在の証明状態に関して継続的なフィードバックを提供します。
戦術を用いた<code>onePlusOneIsTwo</code>の証明は、まだ非常に短いです：</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># オーバーローディングとタイプクラス

多くの言語では、組み込みのデータ型は特別な扱いを受けています。
例えば、C言語やJavaでは、`+`を使用して`float`型や`int`型の数値を加算できますが、サードパーティライブラリの任意精度数値には適用できません。
同様に、数値リテラルは組み込み型では直接使用可能ですが、ユーザー定義の数値型では使用できない場合があります。
他の言語では、_オーバーロード_ 機構を提供することで、既存の演算子を新しい型に対する意味を持たせる機能を備えています。
C++やC#といった言語では、多様な組み込み演算子をオーバーロード可能にしており、コンパイラによる型チェックを利用して特定の実装を選択します。

数値リテラルや演算子と合わせて、多くの言語が関数やメソッドのオーバーローディングも許可しています。
C++、Java、C#、Kotlinでは、引数の数や型が異なる複数のメソッドの実装を容認しています。
コンパイラは、引数の数とその型を根拠にどのオーバーロードが意図されているかを判断します。

しかし、関数や演算子のオーバーローディングには大きな制約があります：ポリモーフィックな関数は特定のオーバーロードが存在する型に対して一般化することはできません。
たとえば、文字列、バイト配列、ファイルポインタに対してオーバーロードされたメソッドがあっても、これらどれかで動作する汎用的なメソッドを書く方法は存在しません。
この代わりに、その汎用メソッド自体をオリジナルのメソッドでサポートされる各型に対して再度オーバーロードする必要があり、これは単一のポリモーフィックな定義ではなく、多くのボイラープレートな定義を要求します。
この制限のもう一つの結果として、いくつかの演算子（例えばJavaの等価演算子）は、意味を成さない場合もありますが、_全て_ の引数の組み合わせに対して定義されてしまうことがあります。
プログラマが非常に注意深く行動しなければ、これによってプログラムが実行時にクラッシュするか、静かに不正確な結果を導出してしまう危険性があります。

Leanは、Haskellによって始められた_タイプクラス_ というメカニズムを用いてオーバーローディングを実装しており、ポリモーフィズムとうまく合わせて、演算子や関数、リテラルのオーバーローディングを可能にします。
タイプクラスは、オーバーロード可能な操作の集合を記述しています。
新しい型に対してこれらの操作をオーバーロードするには、新しい型に適合する各操作の実装を含む_インスタンス_ を生成します。
例えば、`Add`というタイプクラスが加算可能な型を規定しており、`Nat`型に対する`Add`のインスタンスは、`Nat`型の加算の実装を提供します。

オブジェクト指向言語に慣れ親しんでいる人々にとっては、_クラス_ と_インスタンス_ という用語は混乱を招くかもしれません。というのも、これらはオブジェクト指向言語におけるクラスやインスタンスとは異なる概念だからです。
しかし、これらは共通の起源を持っています：日常言語において &quot;クラス&quot; という用語は一般的にいくつかの共通属性を持つグループを指します。
オブジェクト指向プログラミングのクラスは、このような共通の属性を持つオブジェクトの集合を表しますが、それは特定の言語レベルのメカニズムを指す用語です。
タイプクラスも、共通の属性を持つ型（具体的には特定の操作の実装）を記述する方法ですが、オブジェクト指向プログラミングで見られるクラスとはまた異なります。

Leanのタイプクラスは、JavaやC#の_インターフェース_ に非常に似ています。
タイプクラスもインターフェースも、型や型の集合に実装されるべき概念的に関連する一連の操作を記述します。
同様に、タイプクラスのインスタンスは、JavaやC#のインターフェースに実装されるコードに似てはいますが、JavaやC#のクラスのインスタンスに似たものです。
ただし、JavaやC#のインターフェースと異なり、タイプクラスのインスタンスは、その型の著者がアクセスできない場合においても提供され得ます。
この点で、それらはRustのトレイトに非常に似ています。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="正の数値"><a class="header" href="#正の数値">正の数値</a></h1>
<p>あるアプリケーションでは、正の数値のみが意味をなすことがあります。
例えば、コンパイラーやインタプリターはソースコードの位置を示すために1から始まる行番号や列番号を使い、非空リストを表すデータ型では長さがゼロと報告されることはありません。
自然数を用いて、数がゼロでないことを確認するアサーションをコードに散りばめるのではなく、正の数のみを表すデータ型を設計することが有効な場合があります。</p>
<p>正の数値を表す一つの方法は<code>Nat</code>に似ていますが、基底ケースが<code>zero</code>の代わりに<code>one</code>です：</p>
<pre><code class="language-lean">inductive Pos : Type where
  | one : Pos
  | succ : Pos → Pos
</code></pre>
<p>このデータ型は正確に意図した値の集合を表していますが、使用するのは非常に不便です。
例えば、数値リテラルは拒否されます：</p>
<pre><code class="language-lean">def seven : Pos := 7
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 7
</code></pre>
<p>代わりに、コンストラクタを直接使用する必要があります：</p>
<pre><code class="language-lean">def seven : Pos :=
  Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))
</code></pre>
<p>同様に、加算や乗算を使用するのも容易ではありません：</p>
<pre><code class="language-lean">def fourteen : Pos := seven + seven
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  HAdd Pos Pos ?m.291
</code></pre>
<pre><code class="language-lean">def fortyNine : Pos := seven * seven
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  HMul Pos Pos ?m.291
</code></pre>
<p>これらのエラーメッセージはそれぞれ「failed to synthesize instance」で始まります。
これは重複した操作が実装されていないためのエラーであり、実装する必要がある型クラスを説明しています。</p>
<h2 id="クラスとインスタンス"><a class="header" href="#クラスとインスタンス">クラスとインスタンス</a></h2>
<p>型クラスは、名前といくつかのパラメーター、そしてメソッドのコレクションで構成されます。
パラメーターはオーバーロード可能な操作が定義されている型を記述し、メソッドはオーバーロード可能な操作の名前と型シグネチャーです。
再び、オブジェクト指向言語との用語の衝突があります。
オブジェクト指向プログラミングでは、メソッドは特定のオブジェクトに接続された関数であり、オブジェクトのプライベート状態への特別なアクセスを持っています。
オブジェクトはそのメソッドを介して操作されます。
Leanでは、「メソッド」という用語はオーバーロード可能であると宣言された操作を指しますが、オブジェクトや値やプライベートフィールドと特別な関連はありません。</p>
<p>加算をオーバーロードする一つの方法は、<code>Plus</code>という名前の型クラスを定義し、<code>plus</code>という加算メソッドを持つことです。
<code>Nat</code>に対する<code>Plus</code>のインスタンスが定義されると、<code>Plus.plus</code>を使用して2つの<code>Nat</code>を加算することが可能になります：</p>
<pre><code class="language-lean">#eval Plus.plus 5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>引数の型を増やすことで<code>Plus.plus</code>をより多くの種類の引数に対応させます。</p>
<p>次の型クラス宣言では、<code>Plus</code>がクラスの名前であり、<code>α : Type</code>が唯一の引数であり、<code>plus : α → α → α</code>が唯一のメソッドです：</p>
<pre><code class="language-lean">class Plus (α : Type) where
  plus : α → α → α
</code></pre>
<p>この宣言により、型<code>α</code>に対して<code>Plus</code>という型クラスがオーバーロード操作を提供しているとされます。
特に、<code>plus</code>というオーバーロード操作がありますが、これは2つの<code>α</code>を取り、<code>α</code>を返すものです。</p>
<p>型クラスは第一級の市民です。型も第一級の市民です。
特に、型クラスは別の種類の型です。
<code>Plus</code>の型は<code>Type → Type</code>です。なぜなら、これは型の引数（<code>α</code>）を取り、<code>Plus</code>の操作が<code>α</code>でオーバーロードされることを記述した新しい型を結果とします。</p>
<p>特定の型の<code>plus</code>をオーバーロードするためにインスタンスを書きます：</p>
<pre><code class="language-lean">instance : Plus Nat where
  plus := Nat.add
</code></pre>
<p><code>instance</code>の後のコロンは、<code>Plus Nat</code>が確かに型であることを示しています。
クラス<code>Plus</code>の各メソッドは<code>:=</code>を使用して値を割り当てる必要があります。
この場合、メソッドは<code>plus</code>のみです。</p>
<p>デフォルトでは、型クラスメソッドは型クラスと同じ名前の名前空間で定義されます。
ユーザーが最初にクラス名を入力する必要がないように、名前空間を<code>open</code>することが便利な場合があります。
<code>open</code>コマンドの括弧は、名前空間からアクセス可能にする指定された名前のみを示しています：</p>
<pre><code class="language-lean">open Plus (plus)

#eval plus 5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p><code>Pos</code>の加算関数と<code>Pos</code>の<code>Plus</code>のインスタンスを定義すると、<code>plus</code>を使用して<code>Pos</code>と<code>Nat</code>の値の両方を加算することができるようになります：</p>
<pre><code class="language-lean">def Pos.plus : Pos → Pos → Pos
  | Pos.one, k =&gt; Pos.succ k
  | Pos.succ n, k =&gt; Pos.succ (n.plus k)

instance : Plus Pos where
  plus := Pos.plus

def fourteen : Pos := plus seven seven
</code></pre>
<p>まだ<code>Plus Float</code>のインスタンスがないため、<code>plus</code>を使用して2つの浮動小数点数を加算しようとすると、おなじみのメッセージで失敗します：</p>
<pre><code class="language-lean">#eval plus 5.2 917.25861
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  Plus Float
</code></pre>
<p>これらのエラーは、Leanが特定の型クラスのインスタンスを見つけることができなかったことを意味します。</p>
<h2 id="オーバーロードされた加算"><a class="header" href="#オーバーロードされた加算">オーバーロードされた加算</a></h2>
<p>Leanの組み込みの加算演算子は、<code>HAdd</code>という型クラスのための構文糖衣であり、その型クラスは加算の引数が異なる型であっても柔軟に対応することができます。
<code>HAdd</code>は <em>異種加算</em> を略したものです。
例えば、<code>Nat</code>を<code>Float</code>に加算することができる<code>HAdd</code>のインスタンスを書くことができ、これにより新しい<code>Float</code>が生まれます。
プログラマーが<code>x + y</code>と書いた場合、それは<code>HAdd.hAdd x y</code>と解釈されます。</p>
<p><code>HAdd</code>の完全な一般性を理解するには<a href="type-classes/out-params.html">この章の別のセクション</a>で議論される機能が必要ですが、引数の型を混在させないよりシンプルな型クラス<code>Add</code>があります。
Leanのライブラリは、両引数の型が同じである<code>HAdd</code>のインスタンスを探す際に、<code>Add</code>のインスタンスが見つかるようにセットアップされています。</p>
<p><code>Add Pos</code>のインスタンスを定義することで、<code>Pos</code>の値で通常の加算構文を使用できるようになります：</p>
<pre><code class="language-lean">instance : Add Pos where
  add := Pos.plus

def fourteen : Pos := seven + seven
</code></pre>
<h2 id="文字列への変換"><a class="header" href="#文字列への変換">文字列への変換</a></h2>
<p>別の役立つ組み込みクラスは<code>ToString</code>と呼ばれています。
<code>ToString</code>のインスタンスは、与えられた型の値を文字列に変換する標準的な方法を提供します。
例えば、<code>ToString</code>インスタンスは、値が補間文字列に出現した場合に使用され、<a href="type-classes/../hello-world/running-a-program.html#running-a-program">説明の<code>IO</code></a>の最初で使用された<code>IO.println</code>関数が値をどのように表示するかを決定します。</p>
<p>例えば、<code>Pos</code>を<code>String</code>に変換する一つの方法は、その内部構造を明らかにすることです。
関数<code>posToString</code>は、<code>Pos.succ</code>の使用を括弧で囲むかどうかを決定する<code>Bool</code>を取りますが、これは初回の関数呼び出しでは<code>true</code>に、すべての再帰的呼び出しでは<code>false</code>にすべきです。</p>
<pre><code class="language-lean">def posToString (atTop : Bool) (p : Pos) : String :=
  let paren s := if atTop then s else &quot;(&quot; ++ s ++ &quot;)&quot;
  match p with
  | Pos.one =&gt; &quot;Pos.one&quot;
  | Pos.succ n =&gt; paren s!&quot;Pos.succ {posToString false n}&quot;
</code></pre>
<p>この関数を<code>ToString</code>インスタンスに使用すると：</p>
<pre><code class="language-lean">instance : ToString Pos where
  toString := posToString true
</code></pre>
<p>その結果、情報豊富ながらも圧倒的な出力になります：</p>
<pre><code class="language-lean">#eval s!&quot;There are {seven}&quot;
</code></pre>
<pre><code class="language-output info">&quot;There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))&quot;
</code></pre>
<p>一方で、すべての正の数には対応する<code>Nat</code>があります。
それを<code>Nat</code>に変換してから<code>ToString Nat</code>インスタンス（つまり、<code>Nat</code>に対する<code>toString</code>のオーバーロード）を使用することは、はるかに短い出力をすばやく生成する手段です：</p>
<pre><code class="language-lean">def Pos.toNat : Pos → Nat
  | Pos.one =&gt; 1
  | Pos.succ n =&gt; n.toNat + 1

instance : ToString Pos where
  toString x := toString (x.toNat)

#eval s!&quot;There are {seven}&quot;
</code></pre>
<pre><code class="language-output info">&quot;There are 7&quot;
</code></pre>
<p>インスタンスが複数定義されている場合、最も新しいものが優先されます。
さらに、型に<code>ToString</code>インスタンスがある場合、型が<code>deriving Repr</code>で定義されていなかったとしても、<code>#eval</code>の結果を表示するために使用できるため、<code>#eval seven</code>の出力は<code>7</code>になります。</p>
<h2 id="オーバーロードされた乗算"><a class="header" href="#オーバーロードされた乗算">オーバーロードされた乗算</a></h2>
<p>乗算については、<code>HAdd</code>のように引数の型が混合されることを許容する型クラス<code>HMul</code>があります。
<code>x + y</code>が<code>HAdd.hAdd x y</code>と解釈されるのと同様に、<code>x * y</code>は<code>HMul.hMul x y</code>と解釈されます。
引数の型が同じである乗算の一般的なケースでは、<code>Mul</code>インスタンスが十分です。</p>
<p><code>Pos</code>に対して<code>Mul</code>のインスタンスを持つことは、通常の乗算構文を<code>Pos</code>で使用するためにあります：</p>
<pre><code class="language-lean">def Pos.mul : Pos → Pos → Pos
  | Pos.one, k =&gt; k
  | Pos.succ n, k =&gt; n.mul k + k

instance : Mul Pos where
  mul := Pos.mul
</code></pre>
<p>このインスタンスを持つことで、乗算が予想通りに機能します：</p>
<pre><code class="language-lean">#eval [seven * Pos.one,
       seven * seven,
       Pos.succ Pos.one * seven]
</code></pre>
<pre><code class="language-output info">[7, 49, 14]
</code></pre>
<h2 id="リテラル数字"><a class="header" href="#リテラル数字">リテラル数字</a></h2>
<p>正の数値のコンストラクタの列を書き出すことはかなり不便です。
この問題を解決する方法の一つは、<code>Nat</code>を<code>Pos</code>に変換する関数を提供することです。
ただし、このアプローチには欠点があります。
まず、<code>Pos</code>は<code>0</code>を表すことができないため、結果の関数は<code>Nat</code>を大きな数値に変換するか、あるいは<code>Option Pos</code>を返すことになります。
どちらもユーザーにとって特に便利ではありません。
第二に、関数を明示的に呼び出す必要があるため、正の数値を使用するプログラムを<code>Nat</code>を使用するプログラムよりも書くことがはるかに不便になります。
正確な型と便利なAPIの間にトレードオフがあると、正確な型はあまり有用ではなくなります。</p>
<p>Leanでは、自然数のリテラルは<code>OfNat</code>という型クラスを使用して解釈されます：</p>
<pre><code class="language-lean">class OfNat (α : Type) (_ : Nat) where
  ofNat : α
</code></pre>
<p>この型クラスには2つの引数があります：<code>α</code>は自然数がオーバーロードされている型であり、名前のない<code>Nat</code>引数はプログラムで遭遇した実際のリテラル数値です。
その後、メソッド<code>ofNat</code>は数値リテラルの値として使用されます。
クラスに<code>Nat</code>引数が含まれているため、数値が意味をなす値にのみインスタンスを定義することが可能になります。</p>
<p><code>OfNat</code>は、型クラスの引数が型である必要はないことを示しています。
Leanの型は言語の中で第一級の参加者であり、関数への引数として渡したり、<code>def</code>や<code>abbrev</code>で定義を与えたりすることができるので、より柔軟性の低い言語で許可できない位置で非型引数を防ぐための障壁はありません。
この柔軟性により、特定の型だけでなく特定の値に対するオーバーロード操作を提供することが可能になります。</p>
<p>例えば、4未満の自然数を表現する和型は次のように定義できます：</p>
<pre><code class="language-lean">inductive LT4 where
  | zero
  | one
  | two
  | three
deriving Repr
</code></pre>
<p>任意のリテラル数値をこの型に対して使うことは意味がありませんが、4未満の数なら明らかに理にかなっています：</p>
<pre><code class="language-lean">instance : OfNat LT4 0 where
  ofNat := LT4.zero

instance : OfNat LT4 1 where
  ofNat := LT4.one

instance : OfNat LT4 2 where
  ofNat := LT4.two

instance : OfNat LT4 3 where
  ofNat := LT4.three
</code></pre>
<p>これらのインスタンスを使用すれば、下記の例が機能します：</p>
<pre><code class="language-lean">#eval (3 : LT4)
</code></pre>
<pre><code class="language-output info">LT4.three
</code></pre>
<pre><code class="language-lean">#eval (0 : LT4)
</code></pre>
<pre><code class="language-output info">LT4.zero
</code></pre>
<p>しかし、範囲外のリテラルはまだ許可されません：</p>
<pre><code class="language-lean">#eval (4 : LT4)
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
OfNat LT4 4
</code></pre>
<p><code>Pos</code>に対しては、<code>OfNat</code>インスタンスは<code>Nat.zero</code>を除く任意の<code>Nat</code>で機能するべきです。
別の言い方をすれば、自然数<code>n</code>に対して、インスタンスは<code>n + 1</code>で動作するべきです。
名前のように<code>α</code>が自動的に関数の暗黙の引数となり、Leanが自動的に埋めてくれるように、インスタンスも自動的な暗黙の引数を受け取ることができます。
このインスタンスでは、引数<code>n</code>はどんな<code>Nat</code>も表し、インスタンスはそれより1大きい<code>Nat</code>に対して定義されています：</p>
<pre><code class="language-lean">instance : OfNat Pos (n + 1) where
  ofNat :=
    let rec natPlusOne : Nat → Pos
      | 0 =&gt; Pos.one
      | k + 1 =&gt; Pos.succ (natPlusOne k)
    natPlusOne n
</code></pre>
<p>ユーザーが書いた数字より1少ない<code>Nat</code>を表しているので、ヘルパー関数<code>natPlusOne</code>はその引数より1大きい<code>Pos</code>を返します。
これにより自然数リテラルを正の数に使用できるようになりますが、ゼロには使用できません：</p>
<pre><code class="language-lean">def eight : Pos := 8

def zero : Pos := 0
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<h2 id="練習問題-4"><a class="header" href="#練習問題-4">練習問題</a></h2>
<h3 id="別の表現法"><a class="header" href="#別の表現法">別の表現法</a></h3>
<p>正数をある<code>Nat</code>の後継として表現するという代替方法があります。
<code>Pos</code>の定義を置き換えて、<code>Nat</code>を含む名前<code>succ</code>のコンストラクタを持つ構造体にします：</p>
<pre><code class="language-lean">structure Pos where
  succ ::
  pred : Nat
</code></pre>
<p>このバージョンの<code>Pos</code>が便利に使えるように<code>Add</code>、<code>Mul</code>、<code>ToString</code>、および<code>OfNat</code>のインスタンスを定義してください。</p>
<h3 id="偶数"><a class="header" href="#偶数">偶数</a></h3>
<p>偶数のみを表すデータ型を定義してください。それを便利に使えるように<code>Add</code>、<code>Mul</code>、および<code>ToString</code>のインスタンスを定義してください。
<code>OfNat</code>は<a href="type-classes/polymorphism.html">次のセクション</a>で紹介される機能を必要とします。</p>
<h3 id="httpリクエスト"><a class="header" href="#httpリクエスト">HTTPリクエスト</a></h3>
<p>HTTPリクエストは、<code>GET</code>や<code>POST</code>などのHTTPメソッドの識別から始まり、URIとHTTPバージョンを添えています。
HTTPメソッドの面白いサブセットを表す帰納的型と、HTTPレスポンスを表す構造体を定義してください。
レスポンスはデバッグ可能にするため<code>ToString</code>インスタンスを持っているべきです。
それぞれのHTTPメソッドに異なる<code>IO</code>アクションを関連付けるための型クラスを使用し、各メソッドを呼び出して結果を印刷するテストハーネスとしての<code>IO</code>アクションを記述してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型クラスとポリモーフィズム"><a class="header" href="#型クラスとポリモーフィズム">型クラスとポリモーフィズム</a></h1>
<p>任意の関数のオーバーロードに対して動作する関数を書くことは有用である。
例えば、<code>ToString</code>のインスタンスを持つ任意の型に対して機能する<code>IO.println</code>がそれにあたる。
これは必要なインスタンスを角括弧で示すことによって表される：<code>IO.println</code>の型は<code>{α : Type} → [ToString α] → α → IO Unit</code>である。
この型は、<code>IO.println</code>が自動的にLeanによって決定されるべき型<code>α</code>の引数を受け取り、<code>α</code>に対する<code>ToString</code>インスタンスが利用可能でなければならないことを示している。
それは<code>IO</code>アクションを返す。</p>
<h2 id="ポリモーフィック関数の型の確認"><a class="header" href="#ポリモーフィック関数の型の確認">ポリモーフィック関数の型の確認</a></h2>
<p>暗黙の引数を取る関数や型クラスを使用する関数の型をチェックするには、いくつか追加の構文が必要です。
単に書く</p>
<pre><code class="language-lean">#check (IO.println)
</code></pre>
<p>これはメタ変数を含む型を生み出す：</p>
<pre><code class="language-output info">IO.println : ?m.3620 → IO Unit
</code></pre>
<p>これは、Leanが暗黙の引数を発見することに最善を尽くしており、メタ変数の存在は、型情報の十分な発見がまだなされていないことを示している。
関数のシグネチャを理解するためには、関数名の前にアットサイン(<code>@</code>)を付けてこの機能を抑制することができる：</p>
<pre><code class="language-lean">#check @IO.println
</code></pre>
<pre><code class="language-output info">@IO.println : {α : Type u_1} → [inst : ToString α] → α → IO Unit
</code></pre>
<p>この出力では、インスタンス自体に<code>inst</code>という名前が与えられている。
さらに、<code>Type</code>の後には<code>u_1</code>があり、これはまだ導入されていないLeanの機能を使用している。
今のところ、<code>Type</code>へのこれらのパラメータを無視してください。</p>
<h2 id="インスタンス暗黙の引数を用いたポリモーフィック関数の定義"><a class="header" href="#インスタンス暗黙の引数を用いたポリモーフィック関数の定義">インスタンス暗黙の引数を用いたポリモーフィック関数の定義</a></h2>
<p>リスト内のすべてのエントリを合計する関数には二つのインスタンスが必要です：<code>Add</code>はエントリを追加することを可能にし、空のリストのためにあるべき値として<code>0</code>の<code>OfNat</code>インスタンスが提供されます：</p>
<pre><code class="language-lean">def List.sum [Add α] [OfNat α 0] : List α → α
  | [] =&gt; 0
  | x :: xs =&gt; x + xs.sum
</code></pre>
<p>この関数は<code>Nat</code>のリストについて使用することができます：</p>
<pre><code class="language-lean">def fourNats : List Nat := [1, 2, 3, 4]

#eval fourNats.sum
</code></pre>
<pre><code class="language-output info">10
</code></pre>
<p>しかし、<code>Pos</code>数字のリストには使用できません：</p>
<pre><code class="language-lean">def fourPos : List Pos := [1, 2, 3, 4]

#eval fourPos.sum
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<p>角括弧内の必要なインスタンスの仕様は_インスタンス暗黙の引数_と呼ばれます。
裏側では、すべての型クラスが各オーバーロードされた操作のためのフィールドを持つ構造を定義しています。
インスタンスはその構造型の値であり、各フィールドには実装が含まれています。
呼び出し場所で、Leanは各インスタンス暗黙の引数に対して渡すインスタンス値を見つける責任を持ちます。
通常の暗黙の引数とインスタンス暗黙の引数との最も重要な違いは、Leanが引数値を見つけるために使用する戦略です。
通常の暗黙の引数の場合、Leanはプログラムが型チェッカーを通過するために単一のユニークな引数値を見つけるために_単一化_と呼ばれる技術を使用します。
このプロセスは、関数の定義と呼び出し場所に関与する特定の型のみに依存しています。
インスタンス暗黙の引数の場合、Leanは代わりにインスタンス値の組み込みテーブルを参照します。</p>
<p><code>Pos</code>の<code>OfNat</code>インスタンスが自然数<code>n</code>を自動的な暗黙の引数として取ったように、インスタンスは自身もまたインスタンス暗黙の引数を取ることがあります。
<a href="type-classes/../getting-to-know/polymorphism.html">多相性に関するセクション</a>では、多相的な点の型が提示されました：</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>点の加算は下層の<code>x</code>と<code>y</code>フィールドを加算するべきである。
したがって、<code>PPoint</code>の<code>Add</code>インスタンスにはこれらのフィールドが持つ型の<code>Add</code>インスタンスが必要です。
言い換えれば、<code>PPoint</code>のための<code>Add</code>インスタンスは<code>α</code>に対する更なる<code>Add</code>インスタンスを必要とします：</p>
<pre><code class="language-lean">instance [Add α] : Add (PPoint α) where
  add p1 p2 := { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>Leanが2点の加算に遭遇すると、このインスタンスを探し出し見つけます。
その後、<code>Add α</code>インスタンスについてさらに探索を行います。</p>
<p>このように構築されたインスタンス値は型クラスの構造型の値です。
成功した再帰的なインスタンス探索は、他の構造値への参照を持つ構造値を結果とします。
<code>Add (PPoint Nat)</code>のインスタンスは、見つかった<code>Add Nat</code>のインスタンスへの参照を含んでいます。</p>
<p>この再帰的探索プロセスは、型クラスが単なるオーバーロードされた関数よりもはるかに多くの力を提供することを意味しています。
多相的なインスタンスのライブラリは、コンパイラが望ましい型だけを与えられて独自に組み立てるコードのビルディングブロックのセットです。
インスタンス引数を取る多相関数は、シーンの背後でヘルパー関数を組み立てるために型クラス機構に対する潜在的な要求です。
APIのクライアントは、必要なすべての部品を手作業で組み立てる負担から解放されます。</p>
<h2 id="メソッドと暗黙の引数"><a class="header" href="#メソッドと暗黙の引数">メソッドと暗黙の引数</a></h2>
<p><code>@OfNat.ofNat</code>の型は驚くかもしれない。
それは<code>{α : Type} → (n : Nat) → [OfNat α n] → α</code>であり、この場合、<code>Nat</code>引数<code>n</code>は明示的な関数引数として現れる。
しかし、メソッドの宣言では、<code>ofNat</code>は単に型<code>α</code>を持っている。
このような相違は、型クラスを宣言することが実際に以下のことをもたらすためです：</p>
<ul>
<li>各オーバーロードされた操作の実装を含む構造型</li>
<li>クラスと同じ名前の名前空間</li>
<li>インスタンスからその実装を取得するための、クラスの名前空間内の各メソッドに対する関数</li>
</ul>
<p>これは、新しい構造を宣言することでアクセサ関数も宣言される方法に類似しています。
主な違いは、構造のアクセサは構造値を明示的な引数として取るのに対し、型クラスメソッドはLeanによって自動的に発見されるべきインスタンス値をインスタンス暗黙として取る点です。</p>
<p>Leanがインスタンスを見つけるためには、その引数が利用可能である必要があります。
これは、型クラスの各引数がメソッドに対して引数であり、インスタンスの前に発生しなければならないことを意味します。
これらの引数が暗黙であると、Leanがその値を発見する作業を行うため便利です。
例として、<code>@Add.add</code>は型<code>{α : Type} → [Add α] → α → α → α</code>を持ちます。
この場合、型引数<code>α</code>は、<code>Add.add</code>への引数がユーザーが意図した型についての情報を提供するため、暗黙である可能性があります。
この型はその後、<code>Add</code>インスタンスを検索するために使用することができます。</p>
<p>しかし、<code>ofNat</code>の場合、特定の<code>Nat</code>リテラルが他の引数の一部として現れることはありません。
これは、Leanにとって暗黙の引数<code>n</code>を解明する際に使用する情報がないことを意味します。
結果は非常に不便なAPIになるでしょう。
したがって、これらのケースでは、クラスのメソッドに対して明示的な引数をLeanは使用します。</p>
<h2 id="練習問題-5"><a class="header" href="#練習問題-5">練習問題</a></h2>
<h3 id="偶数リテラル"><a class="header" href="#偶数リテラル">偶数リテラル</a></h3>
<p><a href="type-classes/pos.html#even-numbers">前のセクションの練習問題</a>で偶数データ型のための<code>OfNat</code>のインスタンスを書き、再帰的なインスタンス探索を使ってください。
基本インスタンスには、<code>OfNat Even 0</code>の代わりに<code>OfNat Even Nat.zero</code>と書く必要があります。</p>
<h3 id="再帰的なインスタンス探索の深さ"><a class="header" href="#再帰的なインスタンス探索の深さ">再帰的なインスタンス探索の深さ</a></h3>
<p>Leanコンパイラが再帰的なインスタンス探索を試みる回数には制限があります。
これは前の練習で定義された偶数リテラルの大きさに制限をもたらします。
その限界が何であるかを実験的に決定してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インスタンス検索の制御"><a class="header" href="#インスタンス検索の制御">インスタンス検索の制御</a></h1>
<p><code>Add</code> クラスのインスタンスは、型 <code>Pos</code> を持つ二つの式を便利に追加することを可能にし、別の <code>Pos</code> を生産します。
しかし、多くの場合、より柔軟になり、引数のタイプが異なることを許容する_異種_オペレーターオーバーロードを可能にした方が役に立ちます。
たとえば、<code>Nat</code> に <code>Pos</code> を加えたり、<code>Pos</code> に <code>Nat</code> を加えたりすると、常に <code>Pos</code> が得られます：</p>
<pre><code class="language-lean">def addNatPos : Nat → Pos → Pos
  | 0, p =&gt; p
  | n + 1, p =&gt; Pos.succ (addNatPos n p)

def addPosNat : Pos → Nat → Pos
  | p, 0 =&gt; p
  | p, n + 1 =&gt; Pos.succ (addPosNat p n)
</code></pre>
<p>これらの関数は自然数を正の数に追加することができますが、両方の引数が同じタイプであることを期待している <code>Add</code> タイプクラスでは使用できません。</p>
<h2 id="異種オーバーロード"><a class="header" href="#異種オーバーロード">異種オーバーロード</a></h2>
<p><a href="type-classes/pos.html#overloaded-addition">オーバーロードされた加算</a>に関するセクションで言及されているように、Leanは異種加算をオーバーロードするために <code>HAdd</code> と呼ばれるタイプクラスを提供しています。
<code>HAdd</code> クラスは3つのタイプパラメータを取ります：2つの引数タイプと返却タイプ。
<code>HAdd Nat Pos Pos</code> および <code>HAdd Pos Nat Pos</code> のインスタンスにより、タイプを混在させるために通常の加算記法を使用することができます：</p>
<pre><code class="language-lean">instance : HAdd Nat Pos Pos where
  hAdd := addNatPos

instance : HAdd Pos Nat Pos where
  hAdd := addPosNat
</code></pre>
<p>上記の2つのインスタンスを使用すると、以下の例が機能します：</p>
<pre><code class="language-lean">#eval (3 : Pos) + (5 : Nat)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<pre><code class="language-lean">#eval (3 : Nat) + (5 : Pos)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p><code>HAdd</code> タイプクラスの定義は、以下の <code>HPlus</code> の定義とその対応するインスタンスと非常によく似ています：</p>
<pre><code class="language-lean">class HPlus (α : Type) (β : Type) (γ : Type) where
  hPlus : α → β → γ

instance : HPlus Nat Pos Pos where
  hPlus := addNatPos

instance : HPlus Pos Nat Pos where
  hPlus := addPosNat
</code></pre>
<p>しかし、<code>HPlus</code> のインスタンスは <code>HAdd</code> のインスタンスよりはるかに役に立たないです。
<code>#eval</code> を使用してこれらのインスタンスを使用しようとすると、エラーが発生します：</p>
<pre><code class="language-lean">#eval HPlus.hPlus (3 : Pos) (5 : Nat)
</code></pre>
<pre><code class="language-output error">typeclass instance problem is stuck, it is often due to metavariables
  HPlus Pos Nat ?m.7527
</code></pre>
<p>これはタイプにメタ変数があり、Leanがそれを解決する方法がないために発生します。</p>
<p><a href="type-classes/../getting-to-know/polymorphism.html">ポリモーフィズムの最初の説明</a>で議論されたように、メタ変数はプログラムの推測できなかった未知の部分を表します。
<code>#eval</code> の後に式を記述すると、Leanはそのタイプを自動的に決定しようとします。
この場合、これができませんでした。
<code>HPlus</code> の三番目のタイプパラメータが未知だったので、Leanはタイプクラスのインスタンス検索を実行できませんでしたが、インスタンス検索は、Leanが式のタイプを決定する唯一の方法です。
つまり、<code>HPlus Pos Nat Pos</code> のインスタンスは、式がタイプ <code>Pos</code> を持つべき場合にのみ適用できますが、インスタンス自体以外にはそれがこのタイプを持つべきであることを示すものはプログラムにはありません。</p>
<p>この問題の一つの解決策は、式全体にタイプ注釈を追加して、全ての3つのタイプを利用可能にすることです：</p>
<pre><code class="language-lean">#eval (HPlus.hPlus (3 : Pos) (5 : Nat) : Pos)
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>しかし、この解決策は正の数ライブラリのユーザーにとって非常に便利ではありません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配列とインデックス化"><a class="header" href="#配列とインデックス化">配列とインデックス化</a></h1>
<p><a href="type-classes/../props-proofs-indexing.html">間奏曲</a>では、リスト内のエントリをその位置で検索するためにインデックス表記法を使用する方法について説明しています。
この構文は型クラスによっても制御されており、さまざまな型に対して使用することができます。</p>
<h2 id="配列"><a class="header" href="#配列">配列</a></h2>
<p>例えば、Leanの配列はほとんどの目的に対して連結リストよりもずっと効率的です。
Leanでは、<code>Array α</code>型は型<code>α</code>の値を動的にサイズ変更して保持する配列で、Javaの<code>ArrayList</code>、C++の<code>std::vector</code>、Rustの<code>Vec</code>に似ています。
<code>List</code>は<code>cons</code>コンストラクタを使用するたびにポインタの間接参照があるのに対して、配列は連続したメモリ領域を占有し、これはプロセッサキャッシュにとってはるかに良いです。
また、配列の中の値を検索するための時間は一定ですが、連結リスト内での検索時間はアクセスされるインデックスに比例します。</p>
<p>純粋関数型言語のLeanでは、データ構造の特定の位置を変更することはできません。
その代わりに、望んだ変更を含むコピーが作成されます。
配列を使用するとき、Leanコンパイラとランタイムには、配列への唯一無二の参照しかない場合に、変更を内部でミューテーションとして実装する最適化が含まれています。</p>
<p>配列はリストに似ていますが、先頭に<code>#</code>が付けられています：</p>
<pre><code class="language-lean">def northernTrees : Array String :=
  #[&quot;sloe&quot;, &quot;birch&quot;, &quot;elm&quot;, &quot;oak&quot;]
</code></pre>
<p>配列の値の数は<code>Array.size</code>を使用して見つけることができます。
例えば、<code>northernTrees.size</code>は<code>4</code>と評価されます。
配列のサイズよりも小さいインデックスについては、リストと同じようにインデックス記法を使用して対応する値を見つけることができます。
つまり、<code>northernTrees[2]</code>は<code>&quot;elm&quot;</code>と評価されます。
同様に、コンパイラはインデックスが範囲内であることを証明する必要があり、配列の範囲外の値を検索しようとすると、リストと同じくコンパイル時エラーが発生します。
例えば、<code>northernTrees[8]</code>は以下の結果になります：</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ 8 &lt; Array.size northernTrees
</code></pre>
<h2 id="空でないリスト"><a class="header" href="#空でないリスト">空でないリスト</a></h2>
<p>空でないリストを表すデータ型は、リストの先頭のためのフィールドと、通常は空かもしれないリストのためのフィールドを持つ構造として定義することができます：</p>
<pre><code class="language-lean">structure NonEmptyList (α : Type) : Type where
  head : α
  tail : List α
</code></pre>
<p>例えば、空でないリスト<code>idahoSpiders</code>（アメリカ合衆国アイダホ州に生息するいくつかのクモの種を含む）は、<code>&quot;Banded Garden Spider&quot;</code>に4匹の他のクモが続き、合計で5匹のクモから構成されています：</p>
<pre><code class="language-lean">def idahoSpiders : NonEmptyList String := {
  head := &quot;Banded Garden Spider&quot;,
  tail := [
    &quot;Long-legged Sac Spider&quot;,
    &quot;Wolf Spider&quot;,
    &quot;Hobo Spider&quot;,
    &quot;Cat-faced Spider&quot;
  ]
}
</code></pre>
<p>このリストで特定のインデックスの値を再帰的な関数で検索するときは、以下の3つの可能性を考慮する必要があります：</p>
<ol>
<li>インデックスが<code>0</code>の場合、リストの先頭を返すべきです。</li>
<li>インデックスが<code>n + 1</code>で尾が空の場合、インデックスは範囲外です。</li>
<li>インデックスが<code>n + 1</code>で尾が空ではない場合、関数は尾と<code>n</code>に対して再帰的に呼び出すことができます。</li>
</ol>
<p>例えば、<code>Option</code>を返すルックアップ関数は次のように記述することができます：</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | {head := _, tail := []}, _ + 1 =&gt; none
  | {head := _, tail := h :: t}, n + 1 =&gt; get? {head := h, tail := t} n
</code></pre>
<p>パターンマッチの各ケースは、上記の可能性に対応します。
<code>get?</code>への再帰呼び出しは定義のネームスペース内で暗黙的に行われるため、<code>NonEmptyList</code>のネームスペース修飾子は必要ありません。
この関数を書く別の方法は、インデックスがゼロよりも大きいとき<code>get?</code>をリストに対して使うことです：</p>
<pre><code class="language-lean">def NonEmptyList.get? : NonEmptyList α → Nat → Option α
  | xs, 0 =&gt; some xs.head
  | xs, n + 1 =&gt; xs.tail.get? n
</code></pre>
<p>リストが1つのエントリを含んでいる場合、有効なインデックスは<code>0</code>のみです。
リストが2つのエントリを含んでいる場合、<code>0</code>と<code>1</code>の両方が有効なインデックスです。
リストが3つのエントリを含んでいる場合<code>, </code>0<code>, </code>1<code>, </code>2`の全てが有効なインデックスです。
言い換えれば、空でないリストへの有効なインデックスは、リストの長さより厳密に小さい自然数であり、尾の長さ以下です。</p>
<p>インデックスが範囲内であるという定義は、戦術が許容可能なインデックスの証拠を見つけるために数値の不等式を解決できるが、<code>NonEmptyList.inBounds</code>という名前については何も知らないので、<code>abbrev</code>として記述されるべきです：</p>
<pre><code class="language-lean">abbrev NonEmptyList.inBounds (xs : NonEmptyList α) (i : Nat) : Prop :=
  i ≤ xs.tail.length
</code></pre>
<p>この関数は真または偽であるかもしれない命題を返します。
例えば、<code>2</code>は<code>idahoSpiders</code>で範囲内ですが、<code>5</code>は範囲外です：</p>
<pre><code class="language-leantac">theorem atLeastThreeSpiders : idahoSpiders.inBounds 2 := by simp

theorem notSixSpiders : ¬idahoSpiders.inBounds 5 := by simp
</code></pre>
<p>論理否定演算子の優先順位が非常に低いため、<code>¬idahoSpiders.inBounds 5</code>は<code>¬(idahoSpiders.inBounds 5)</code>と同等です。</p>
<p>この事実は、インデックスが有効であるという証拠が必要であり、そのために<code>Option</code>を返す必要がないルックアップ関数を書くために使用できます。これは標準ライブラリ関数がコンパイル時に証拠をチェックするために委任できるバージョンです：</p>
<pre><code class="language-lean">def NonEmptyList.get (xs : NonEmptyList α) (i : Nat) (ok : xs.inBounds i) : α :=
  match i with
  | 0 =&gt; xs.head
  | n + 1 =&gt; xs.tail[n]
</code></pre>
<p>もちろん、この関数を書くためには、同じ証拠を使用できる標準ライブラリ関数に委任するのではなく、証拠を直接使用するという手法が必要です。
これには、本書の後の部分で説明される証明や命題を扱うための技術が必要です。</p>
<h2 id="インデックス表記のオーバーロード"><a class="header" href="#インデックス表記のオーバーロード">インデックス表記のオーバーロード</a></h2>
<p>コレクション型のインデックス表記は、<code>GetElem</code>型クラスのインスタンスを定義することによってオーバーロードすることができます。
柔軟性のため、<code>GetElem</code>は4つのパラメータを持っています：</p>
<ul>
<li>コレクションの型</li>
<li>インデックスの型</li>
<li>コレクションから取り出される要素の型</li>
<li>インデックスが範囲内であるとする証拠を決定する関数</li>
</ul>
<p>要素の型と証拠関数は両方とも出力パラメータです。
<code>GetElem</code>には単一のメソッド<code>getElem</code>があり、コレクション値、インデックス値、インデックスが範囲内であるという証拠を引数として取り、要素を返します：</p>
<pre><code class="language-lean">class GetElem (coll : Type) (idx : Type) (item : outParam Type) (inBounds : outParam (coll → idx → Prop)) where
  getElem : (c : coll) → (i : idx) → inBounds c i → item
</code></pre>
<p><code>NonEmptyList α</code>の場合、これらのパラメータは以下のとおりです：</p>
<ul>
<li>コレクションは<code>NonEmptyList α</code></li>
<li>インデックスは<code>Nat</code>型</li>
<li>要素の型は<code>α</code></li>
<li>インデックスが範囲内である場合、それは尾の長さ以下である</li>
</ul>
<p>実際、<code>GetElem</code>のインスタンスは直接<code>NonEmptyList.get</code>に委任できます：</p>
<pre><code class="language-lean">instance : GetElem (NonEmptyList α) Nat α NonEmptyList.inBounds where
  getElem := NonEmptyList.get
</code></pre>
<p>このインスタンスがあると<code>NonEmptyList</code>は<code>List</code>と同じくらい便利になります。
<code>idahoSpiders[0]</code>を評価すると、<code>&quot;Banded Garden Spider&quot;</code>が得られ、<code>idahoSpiders[9]</code>はコンパイル時のエラーにつながります：</p>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
⊢ NonEmptyList.inBounds idahoSpiders 9
</code></pre>
<p><code>GetElem</code>型クラスのコレクション型およびインデックス型は入力パラメータであるため、新しい型は既存のコレクションにインデックスを付けるために使用することができます。
正数型<code>Pos</code>は、リストにインデックスを付けるのに完全に合理的ですが、最初のエントリを指すことはできません。
以下の<code>GetElem</code>インスタンスにより、<code>Pos</code>は<code>Nat</code>と同じように、リストエントリを見つけるのに便利に使用できます：</p>
<pre><code class="language-lean">instance : GetElem (List α) Pos α (fun list n =&gt; list.length &gt; n.toNat) where
  getElem (xs : List α) (i : Pos) ok := xs[i.toNat]
</code></pre>
<p>インデックスが非数値の場合でも、インデックス表記は意味を持ち得ます。
例えば、<code>Bool</code>はポイントのフィールドでの選択に使用され、<code>false</code>は<code>x</code>に、<code>true</code>は<code>y</code>に対応します：</p>
<pre><code class="language-lean">instance : GetElem (PPoint α) Bool α (fun _ _ =&gt; True) where
  getElem (p : PPoint α) (i : Bool) _ :=
    if not i then p.x else p.y
</code></pre>
<p>この場合、すべての<code>Bool</code>は有効なインデックスです。
すべての可能な<code>Bool</code>が範囲内であるため、証拠は単に真の命題<code>True</code>です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標準クラス"><a class="header" href="#標準クラス">標準クラス</a></h1>
<p>このセクションでは、Leanでタイプクラスを使用してオーバーロードできる多様な演算子や関数を紹介します。
各演算子や関数は型クラスのメソッドに対応しています。
C++とは異なり、Leanの中置演算子は名前付き関数の略称として定義されており、これは新しい型のオーバーロードが演算子自体ではなく、<code>HAdd.hAdd</code>のような基本名を用いて行われることを意味しています。</p>
<h2 id="算術"><a class="header" href="#算術">算術</a></h2>
<p>ほとんどの算術演算子は、異なるタイプの引数を取り、結果の式のタイプを決める出力パラメータを持つ異種形式で利用可能です。
各々の異種演算子には、対応する同種バージョンがありますが、これは <code>h</code> を抜いて <code>HAdd.hAdd</code> が <code>Add.add</code> になることにより見つけることができます。
以下の算術演算子がオーバーロードされています：</p>
<table><thead><tr><th>演算式</th><th>展開</th><th>クラス名</th></tr></thead><tbody>
<tr><td><code>x + y</code></td><td><code>HAdd.hAdd x y</code></td><td><code>HAdd</code></td></tr>
<tr><td><code>x - y</code></td><td><code>HSub.hSub x y</code></td><td><code>HSub</code></td></tr>
<tr><td><code>x * y</code></td><td><code>HMul.hMul x y</code></td><td><code>HMul</code></td></tr>
<tr><td><code>x / y</code></td><td><code>HDiv.hDiv x y</code></td><td><code>HDiv</code></td></tr>
<tr><td><code>x % y</code></td><td><code>HMod.hMod x y</code></td><td><code>HMod</code></td></tr>
<tr><td><code>x ^ y</code></td><td><code>HPow.hPow x y</code></td><td><code>HPow</code></td></tr>
<tr><td><code>(- x)</code></td><td><code>Neg.neg x</code></td><td><code>Neg</code></td></tr>
</tbody></table>
<h2 id="ビット単位の演算子"><a class="header" href="#ビット単位の演算子">ビット単位の演算子</a></h2>
<p>Leanには標準のビット単位の演算子がいくつかあり、型クラスを使ってオーバーロードされています。
<code>UInt8</code>、 <code>UInt16</code>、 <code>UInt32</code>、 <code>UInt64</code>、そして <code>USize</code> などの固定幅の型に対するインスタンスがあります。
後者は現在のプラットフォーム上のワードサイズで、通常は32ビットまたは64ビットです。
以下のビット単位の演算子がオーバーロードされています：</p>
<table><thead><tr><th>演算式</th><th>展開</th><th>クラス名</th></tr></thead><tbody>
<tr><td><code>x &amp;&amp;&amp; y</code></td><td><code>HAnd.hAnd x y</code></td><td><code>HAnd</code></td></tr>
<tr><td><code class="hljs">x</td><td></td><td></td></tr>
<tr><td><code>x ^^^ y</code></td><td><code>HXor.hXor x y</code></td><td><code>HXor</code></td></tr>
<tr><td><code>~~~ x</code></td><td><code>Complement.complement x</code></td><td><code>Complement</code></td></tr>
<tr><td><code>x &gt;&gt;&gt; y</code></td><td><code>HShiftRight.hShiftRight x y</code></td><td><code>HShiftRight</code></td></tr>
<tr><td><code>x &lt;&lt;&lt; y</code></td><td><code>HShiftLeft.hShiftLeft x y</code></td><td><code>HShiftLeft</code></td></tr>
</tbody></table>
<p><code>And</code> や <code>Or</code> という名前は論理接続詞の名前として既に使用されているため、<code>HAnd</code> や <code>HOr</code> の同種のバージョンは <code>And</code> や <code>Or</code> ではなく <code>AndOp</code> や <code>OrOp</code> と呼ばれます。</p>
<h2 id="等価性と順序評価"><a class="header" href="#等価性と順序評価">等価性と順序評価</a></h2>
<p>2つの値の等価性をテストするには通常 <code>BEq</code> クラスが使用されます。これは「Boolean equality（ブール等価性）」の略です。
Leanが定理証明者としての使用を考慮すると、Leanには実際には2種類の等価演算子があります：</p>
<ul>
<li><em>ブール等価性</em> は他のプログラミング言語で見られる等価性と同じです。これは2つの値を取って <code>Bool</code> を返す関数です。ブール等価性はPythonやC#と同様に二重等号で記述されます。Leanは純粋な関数言語なので、参照と値の等価性は別々にはならず、ポインタは直接観測されることはありません。</li>
<li><em>命題の等価性</em> は、二つのものが等しいという数学的な声明です。命題の等価性は関数ではなく、証明を認める数学的な声明です。それは一体の等号で書かれています。命題の等価性はこの等価性の証拠を分類する型のようなものです。</li>
</ul>
<p>両方の等価性の概念は重要であり、異なる目的で使用されます。
プログラム内では、二つの値が等しいかどうかを判断する必要がある場合にブール等価性が役立ちます。
たとえば、<code>&quot;Octopus&quot; ==  &quot;Cuttlefish&quot;</code> は <code>false</code> と評価され、<code>&quot;Octopodes&quot; ==  &quot;Octo&quot;.append &quot;podes&quot;</code> は <code>true</code> と評価されます。
関数など一部の値は、等価性をチェックできません。
たとえば、<code>(fun (x : Nat) =&gt; 1 + x) == (Nat.succ ·)</code> は以下のエラーを発生させます：</p>
<pre><code class="language-output error">failed to synthesize instance
  BEq (Nat → Nat)
</code></pre>
<p>このメッセージが示すように、<code>==</code> は型クラスを使用してオーバーロードされています。
式 <code>x == y</code> は実際に <code>BEq.beq x y</code> の略です。</p>
<p>命題の等価性はプログラムの呼び出しではなく、数学的な声明です。
命題はある声明の証拠を記述する型のようなものなので、命題の等価性は <code>String</code> や <code>Nat → List Int</code> のような型とブール等価性よりも共通点が多いです。
これは自動的にチェックすることは不可能ということを意味します。
しかし、任意のふたつの式の等価性は、それらが同じ型を持っていればLeanで宣言することができます。
命題 <code>(fun (x : Nat) =&gt; 1 + x) = (Nat.succ ·)</code> は十全に妥当な声明です。
数学の視点からすると、ふたつの関数が等しいのは、等しい入力を等しい出力に写像する場合ですので、この声明は事実に基づいていますが、Leanを説得するためには二行の証明が必要です。</p>
<p>一般的に、Leanをプログラミング言語として使用する場合、命題よりむしろブール関数を使用する方が簡単です。
しかし、<code>Bool</code> のコンストラクターで <code>true</code> と <code>false</code> という名前が示すように、この違いは時々あいまいになります。
いくつかの命題は <em>可決定</em> です。つまり、それらはブール関数のようにチェックすることができます。
命題が真または偽であるかどうかをチェックする関数は <em>決定プロセデュア</em> と呼ばれ、その命題の真実性または虚偽性の <em>証拠</em> を返します。
可決定の命題の例には、自然数の等価性・不等価性、文字列の等価性、それ自体が可決定である命題の &quot;ands&quot; と &quot;ors&quot; が含まれます。</p>
<p>Leanでは、<code>if</code> は可決定の命題と共に動作します。
たとえば、<code>2 &lt; 4</code> は命題です：</p>
<pre><code class="language-lean">#check 2 &lt; 4
</code></pre>
<pre><code class="language-output info">2 &lt; 4 : Prop
</code></pre>
<p>それにもかかわらず、<code>if</code> の条件としてそれを記述するのは完全に許容されます。
たとえば、<code>if 2 &lt; 4 then 1 else 2</code> は <code>Nat</code> 型を持ち、<code>1</code> と評価されます。</p>
<p>すべての命題が可決定であるわけではありません。
もしそうであれば、コンピュータは真の命題を決定プロセデュアを実行することによって証明できるでしょう、そして数学者は仕事を失うでしょう。
より具体的に言うと、可決定の命題は決定プロセデュアであるメソッドを持つ <code>Decidable</code> 型クラスのインスタンスを持っています。
<code>Bool</code> であるかのように可決定でない命題を使用しようとすると、<code>Decidable</code> インスタンスを見つけることができない結果となります。
例えば、<code>if (fun (x : Nat) =&gt; 1 + x) = (Nat.succ ·) then &quot;yes&quot; else &quot;no&quot;</code> は以下を引き起こします：</p>
<pre><code class="language-output error">failed to synthesize instance
  Decidable ((fun x =&gt; 1 + x) = fun x =&gt; Nat.succ x)
</code></pre>
<p>以下の通常は可決定の命題は型クラスを使ってオーバーロードされています：</p>
<table><thead><tr><th>演算式</th><th>展開</th><th>クラス名</th></tr></thead><tbody>
<tr><td><code>x &lt; y</code></td><td><code>LT.lt x y</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≤ y</code></td><td><code>LE.le x y</code></td><td><code>LE</code></td></tr>
<tr><td><code>x &gt; y</code></td><td><code>LT.lt y x</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≥ y</code></td><td><code>LE.le y x</code></td><td><code>LE</code></td></tr>
</tbody></table>
<p><code>LT</code> や <code>LE</code>の新しいインスタンスを定義する方法がまだ示されていないため、新しいインスタンスを定義するのが困難かもしれません。</p>
<p>さらに、<code>&lt;</code>、<code>==</code>、<code>&gt;</code> を使って値を比較することは非効率的です。
他の値よりも一つの値が小さいかどうかをチェックし、それから等しいかどうかをチェックすることは、大きなデータ構造にまたがって二度の走査を必要とすることもあります。
この問題を解決するために、JavaとC#では、一度に3つの操作すべてを実装するためにクラスによってオーバーライド可能な標準の <code>compareTo</code> および <code>CompareTo</code> メソッドがあります。
これらのメソッドは、受信側が引数よりも小さい場合には負の整数を、等しい場合にはゼロを、受信側が引数よりも大きい場合には正の整数を返します。
整数の意味をオーバーロードするのではなく、Leanにはこれら3つの可能性を記述する組み込みの帰納型があります：</p>
<pre><code class="language-lean">inductive Ordering where
| lt
| eq
| gt
</code></pre>
<p><code>Ord</code> 型クラスはこれらの比較のためにオーバーロードすることができます。
<code>Pos</code>に対する実装は以下のようになります：</p>
<pre><code class="language-lean">def Pos.comp : Pos → Pos → Ordering
  | Pos.one, Pos.one =&gt; Ordering.eq
  | Pos.one, Pos.succ _ =&gt; Ordering.lt
  | Pos.succ _, Pos.one =&gt; Ordering.gt
  | Pos.succ n, Pos.succ k =&gt; comp n k

instance : Ord Pos where
  compare := Pos.comp
</code></pre>
<p>Javaで <code>compareTo</code> が正しいアプローチであるような状況では、Leanで <code>Ord.compare</code> を使用します。</p>
<h2 id="ハッシュ化"><a class="header" href="#ハッシュ化">ハッシュ化</a></h2>
<p>JavaとC#にはそれぞれ <code>hashCode</code> と <code>GetHashCode</code> メソッドがあり、これはハッシュテーブルなどのデータ構造で使用される値のハッシュを計算します。
Leanの対応する機能は <code>Hashable</code> と呼ばれる型クラスです：</p>
<pre><code class="language-lean">class Hashable (α : Type) where
  hash : α → UInt64
</code></pre>
<p>2つの値がそのタイプのための <code>BEq</code> インスタンスに従って等しいと考えられる場合、それらは同じハッシュを持つべきです。
言い換えれば、<code>x == y</code> であれば、<code>hash x == hash y</code> であるべきです。
<code>x ≠ y</code> の場合、<code>hash x</code> が <code>hash y</code> と異なる必要は必ずしもありません（結局のところ、<code>Nat</code> の値は <code>UInt64</code> の値よりも無限に多いですが）、しかし異なる値が異なるハッシュを持つ可能性が高い場合、ハッシュに基づくデータ構造のパフォーマンスは向上します。
これは Java と C# と同じ期待です。</p>
<p>標準ライブラリには構成子の異なるフィールドのためにハッシュを組み合わせるために使用できる <code>mixHash</code> という関数が含まれています。
帰納データ型のための合理的なハッシュ関数は、各構成子にユニークな番号を割り当て、その番号を各フィールドのハッシュと混ぜることによって書かれます。
たとえば、<code>Pos</code> の<code>Hashable</code> インスタンスは以下のように書くことができます：</p>
<pre><code class="language-lean">def hashPos : Pos → UInt64
  | Pos.one =&gt; 0
  | Pos.succ n =&gt; mixHash 1 (hashPos n)

instance : Hashable Pos where
  hash := hashPos
</code></pre>
<p>多相型の <code>Hashable</code> インスタンスは再帰的インスタンス検索を使用しています。
<code>α</code> をハッシュ可能なときに限り、<code>NonEmptyList α</code> をハッシュ化することが可能です：</p>
<pre><code class="language-lean">instance [Hashable α] : Hashable (NonEmptyList α) where
  hash xs := mixHash (hash xs.head) (hash xs.tail)
</code></pre>
<p>二分木は <code>BEq</code> と <code>Hashable</code> の実装において再帰と再帰的インスタンス検索の両方を使用します：</p>
<pre><code class="language-lean">inductive BinTree (α : Type) where
  | leaf : BinTree α
  | branch : BinTree α → α → BinTree α → BinTree α

def eqBinTree [BEq α] : BinTree α → BinTree α → Bool
  | BinTree.leaf, BinTree.leaf =&gt;
    true
  | BinTree.branch l x r, BinTree.branch l2 x2 r2 =&gt;
    x == x2 &amp;&amp; eqBinTree l l2 &amp;&amp; eqBinTree r r2
  | _, _ =&gt;
    false

instance [BEq α] : BEq (BinTree α) where
  beq := eqBinTree

def hashBinTree [Hashable α] : BinTree α → UInt64
  | BinTree.leaf =&gt;
    0
  | BinTree.branch left x right =&gt;
    mixHash 1 (mixHash (hashBinTree left) (mixHash (hash x) (hashBinTree right)))

instance [Hashable α] : Hashable (BinTree α) where
  hash := hashBinTree
</code></pre>
<h2 id="標準クラスの導出"><a class="header" href="#標準クラスの導出">標準クラスの導出</a></h2>
<p><code>BEq</code> や <code>Hashable</code> のようなクラスのインスタンスは、手作業で実装するにはしばしば面倒です。
Leanには <em>インスタンス導出</em> と呼ばれる機能があり、多くの型クラスのためにコンパイラが自動的に適切な動作をするインスタンスを構築することを可能にします。
実際に、「構造に関するセクション」(../getting-to-know/structures.md) で <code>Point</code> の定義における <code>deriving Repr</code> のフレーズはインスタンス導出の一例です。</p>
<p>インスタンスは２つの方法で導出できます。
最初の方法は構造体や帰納型を定義する際に使用できます。
この場合、型宣言の最後に <code>deriving</code> を追加し、導出されるべきクラスの名前を続けます。
既に定義された型の場合、スタンドアロンの <code>deriving</code> コマンドを使用できます。
<code>deriving instance C1, C2, ... for T</code> と書くことで、事後に型 <code>T</code> に対して <code>C1, C2, ...</code> のインスタンスを導出します。</p>
<p><code>BEq</code> および <code>Hashable</code> のインスタンスは、<code>Pos</code> と <code>NonEmptyList</code> のために非常に少ないコード量で導出することができます：</p>
<pre><code class="language-lean">deriving instance BEq, Hashable for Pos
deriving instance BEq, Hashable, Repr for NonEmptyList
</code></pre>
<p>少なくとも以下のクラスについてはインスタンスを導出できます：</p>
<ul>
<li><code>Inhabited</code></li>
<li><code>BEq</code></li>
<li><code>Repr</code></li>
<li><code>Hashable</code></li>
<li><code>Ord</code></li>
</ul>
<p>しかし、場合によっては導出された <code>Ord</code> インスタンスがアプリケーションで求められる正確な順序を生成しないことがあります。
そのような場合は、手作業で <code>Ord</code> インスタンスを書くことが適切です。
Leanの上級ユーザーによってインスタンスを導出できるクラスの集合を拡張することが可能です。</p>
<p>プログラマの生産性やコードの可読性に明白な利点がある一方で、インスタンスを導出することはコードの保守管理を容易にします。なぜなら、型の定義が進化するにつれてインスタンスが更新されるからです。
データ型の更新に関する変更セットは、等式テストとハッシュ計算への行ごとの決まりきった変更がなければ、読むのが簡単です。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 強制変換 (Coercions)

数学では、異なる文脈において同じ記号が、ある対象の異なる側面を表すために使用されることが一般的です。
例えば、環が集合が期待される文脈で参照される場合、それは環の根底にある集合が意図されていると理解されます。
プログラミング言語では、一つの型の値を別の型の値に自動的に変換するための規則を持つことが一般的です。
例えば、Javaでは `byte` 型から `int` 型への自動昇格が許され、Kotlinでは null でない型が null を許容する型の文脈で使用されることを許します。

Leanでは、これらの目的は _強制変換 (coercions)_ と呼ばれるメカニズムによって充足されます。
Leanは、ある型の式が別の型が期待される文脈で見出された場合、型エラーを報告する前に式を強制変換しようとします。
JavaやC、Kotlinとは異なり、強制変換は型クラスのインスタンスを定義することで拡張可能です。

## 正の数 (Positive Numbers)

例えば、すべての正の数には自然数が対応します。
以前定義された関数 `Pos.toNat` は、`Pos` を対応する `Nat` に変換します：
```lean
def Pos.toNat : Pos → Nat
  | Pos.one =&gt; 1
  | Pos.succ n =&gt; n.toNat + 1
</code></pre>
<p>型 <code>{α : Type} → Nat → List α → List α</code> の関数 <code>List.drop</code> は、リストのプレフィックスを削除します。
しかし、<code>List.drop</code> を <code>Pos</code> に適用すると型エラーが生じます：</p>
<pre><code class="language-lean">[1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output error">application type mismatch
  List.drop 2
argument
  2
has type
  Pos : Type
but is expected to have type
  Nat : Type
</code></pre>
<p><code>List.drop</code> の著者はそれを型クラスのメソッドにしなかったため、新しいインスタンスを定義することで上書きすることはできません。</p>
<p>型クラス <code>Coe</code> は、一つの型から別の型への強制変換の方法を多重に記述します：</p>
<pre><code class="language-lean">class Coe (α : Type) (β : Type) where
  coe : α → β
</code></pre>
<p><code>Coe Pos Nat</code> のインスタンスがあれば、先ほどのコードが動作するのに十分です：</p>
<pre><code class="language-lean">instance : Coe Pos Nat where
  coe x := x.toNat

#eval [1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output info">[3, 4]
</code></pre>
<p><code>#check</code> を使用すると、舞台裏で使用されたインスタンス検索の結果が表示されます：</p>
<pre><code class="language-lean">#check [1, 2, 3, 4].drop (2 : Pos)
</code></pre>
<pre><code class="language-output info">List.drop (Pos.toNat 2) [1, 2, 3, 4] : List Nat
</code></pre>
<h2 id="連鎖強制変換-chaining-coercions"><a class="header" href="#連鎖強制変換-chaining-coercions">連鎖強制変換 (Chaining Coercions)</a></h2>
<p>強制変換を検索する際、Leanは小さな強制変換の連鎖から強制変換を組み立てようとします。
例えば、すでに <code>Nat</code> から <code>Int</code> への強制変換が存在します。
そのインスタンスと <code>Coe Pos Nat</code> インスタンスを組み合わせることで、以下のコードが承認されます：</p>
<pre><code class="language-lean">def oneInt : Int := Pos.one
</code></pre>
<p>この定義は、<code>Pos</code> から <code>Nat</code> へ、そして <code>Nat</code> から <code>Int</code> への二つの強制変換を使用しています。</p>
<p>左括弧の両側 <code>()</code> は <code>Unit.unit</code> のコンストラクタの略です。
<code>Repr B</code> インスタンスを導出した後、</p>
<pre><code class="language-lean">#eval coercedToB
</code></pre>
<p>の結果は次のようになります：</p>
<pre><code class="language-output info">B.b
</code></pre>
<p><code>Option</code> 型は、C#やKotlinのnull許容型と同様に使用できます：<code>none</code> コンストラクタは値の不在を表します。
Lean標準ライブラリでは、任意の型 <code>α</code> から <code>Option α</code> への強制変換を定義しており、その値を <code>some</code> でラッピングします。
これにより、<code>Option</code> 型はnull許容型と同じように使用できるようになりますが、<code>some</code> を省略することができます。
例えば、リストの最後のエントリを見つける関数 <code>List.getLast?</code> は、返り値 <code>x</code> の周りに <code>some</code> を付けずに書くことができます：</p>
<pre><code class="language-lean">def List.last? : List α → Option α
  | [] =&gt; none
  | [x] =&gt; x
  | _ :: x :: xs =&gt; last? (x :: xs)
</code></pre>
<p>インスタンス検索は強制変換を見つけ、引数を <code>some</code> でラッピングする <code>coe</code> の呼び出しを挿入します。
これらの強制変換は連鎖することができるため、<code>Option</code> のネストされた使用ではネストされた <code>some</code> コンストラクタが必要になることはありません：</p>
<pre><code class="language-lean">def perhapsPerhapsPerhaps : Option (Option (Option String)) :=
  &quot;Please don't tell me&quot;
</code></pre>
<p>強制変換は、プログラムの残りの部分から課せられた型と推論された型の間に不一致が生じたときにのみ自動的にアクティブになります。
他のエラーがある場合には、強制変換はアクティブになりません。
例えば、エラーがインスタンスが不足していることである場合、強制変換は使用されません：</p>
<pre><code class="language-lean">def perhapsPerhapsPerhapsNat : Option (Option (Option Nat)) :=
  392
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  OfNat (Option (Option (Option Nat))) 392
</code></pre>
<p>これは、<code>OfNat</code> のために使用したい型を手動で示すことで回避できます：</p>
<pre><code class="language-lean">def perhapsPerhapsPerhapsNat : Option (Option (Option Nat)) :=
  (392 : Nat)
</code></pre>
<p>さらに、強制変換は上矢印を使用することで手動で挿入することができます：</p>
<pre><code class="language-lean">def perhapsPerhapsPerhapsNat : Option (Option (Option Nat)) :=
  ↑(392 : Nat)
</code></pre>
<p>場合によっては、これを使用することでLeanが正しいインスタンスを見つけることを保証できます。
また、プログラマの意図をより明確にすることもできます。</p>
<h2 id="非空リストと依存性のある強制変換-non-empty-lists-and-dependent-coercions"><a class="header" href="#非空リストと依存性のある強制変換-non-empty-lists-and-dependent-coercions">非空リストと依存性のある強制変換 (Non-Empty Lists and Dependent Coercions)</a></h2>
<p><code>Coe α β</code> のインスタンスは、型 <code>β</code> が型 <code>α</code> からのすべての値を表すことができる値を持っているときに意味をなします。
<code>Nat</code> から <code>Int</code> への強制変換は理にかなっています。なぜなら型 <code>Int</code> はすべての自然数を含んでいるからです。
同様に、非空リストから通常のリストへの強制変換は理にかなっています。なぜなら <code>List</code> 型はすべての非空リストを表すことができるからです：</p>
<pre><code class="language-lean">instance : Coe (NonEmptyList α) (List α) where
  coe
    | { head := x, tail := xs } =&gt; x :: xs
</code></pre>
<p>これにより、非空リストは <code>List</code> API全体で使用できます。</p>
<p>一方で、<code>List α</code> から <code>NonEmptyList α</code> への <code>Coe</code> のインスタンスを書くことは不可能です。なぜなら、空リストを表す非空リストはないからです。
この制限は、<em>依存性のある強制変換 (dependent coercions)</em> と呼ばれる別のバージョンの強制変換を使用することで回避できます。
依存性のある強制変換は、一つの型から別の型への強制変換が、強制される特定の値に依存するときに使用できます。<code>OfNat</code>型クラスがオーバーロードされる具体的な<code>Nat</code>をパラメータとして取るのと同じように、依存性のある強制変換は、それをパラメータとして取ります：</p>
<pre><code class="language-lean">class CoeDep (α : Type) (x : α) (β : Type) where
  coe : β
</code></pre>
<p>これは、特定の値を選択するチャンスです。型クラスの制約を値にさらに課すか、特定のコンストラクタを直接記述するかしてです。
例えば、実際には空でない <code>List</code> を <code>NonEmptyList</code> に強制変換することができます：</p>
<pre><code class="language-lean">instance : CoeDep (List α) (x :: xs) (NonEmptyList α) where
  coe := { head := x, tail := xs }
</code></pre>
<h2 id="型への強制変換-coercing-to-types"><a class="header" href="#型への強制変換-coercing-to-types">型への強制変換 (Coercing to Types)</a></h2>
<p>数学では、集合と追加の構造を備えた概念を持つのが一般的です。
例えば、モノイドは集合 <em>S</em> 、<em>S</em> の要素 <em>s</em> 、および <em>S</em> 上の結合的な二項演算子からなります。ここで、<em>s</em> は演算子の左右で中立です。
<em>S</em> はモノイドの「担体集合 (carrier set)」として参照されます。
0と加算を伴う自然数はモノイドを形成します。なぜなら加算は結合的で、任意の数に0を加えると恒等になるからです。
同様に、1と乗算を伴う自然数もモノイドを形成します。
モノイドは関数型プログラミングでも広く使用されています。リスト、空リスト、および追加演算子はモノイドを形成し、文字列、空文字列、および文字列追加も同様です：</p>
<pre><code class="language-lean">structure Monoid where
  Carrier : Type
  neutral : Carrier
  op : Carrier → Carrier → Carrier

def natMulMonoid : Monoid :=
  { Carrier := Nat, neutral := 1, op := (· * ·) }

def natAddMonoid : Monoid :=
  { Carrier := Nat, neutral := 0, op := (· + ·) }

def stringMonoid : Monoid :=
  { Carrier := String, neutral := &quot;&quot;, op := String.append }

def listMonoid (α : Type) : Monoid :=
  { Carrier := List α, neutral := [], op := List.append }
</code></pre>
<p>モノイドが与えられると、リストのエントリをモノイドの担体集合に変換し、次にモノイドの演算子を使用してそれらを組み合わせる <code>foldMap</code> 関数を記述することができます。
モノイドは中立元を持っているので、リストが空の場合には自然な結果が返されます。そして演算子が結合的であるため、関数のクライアントは、再帰関数が左から右、あるいは右から左に要素を組み合わせるかどうかを気にする必要がありません。</p>
<pre><code class="language-lean">def foldMap (M : Monoid) (f : α → M.Carrier) (xs : List α) : M.Carrier :=
  let rec go (soFar : M.Carrier) : List α → M.Carrier
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p>モノイドは3つの異なる情報から成るものですが、モノイドの名前だけを使ってその集合を参照するのが一般的です。
「Aをモノイドとし、<em>x</em> と <em>y</em> をその担体集合の要素とする」の代わりに、「<em>A</em> をモノイドとし、<em>x</em> と <em>y</em> を <em>A</em> の要素とする」という言い方が一般的です。
この慣習をLeanでエンコードするには、モノイドからその担体集合への新しい種類の強制変換を定義します。</p>
<p><code>CoeSort</code>クラスは<code>Coe</code>クラスと似ていますが、強制変換の対象が <em>sort</em> （すなわち、<code>Type</code> または <code>Prop</code>）であるという例外があります。
Leanにおける用語_sort_は、これらデータを分類する型—<code>Type</code>はデータを分類する型を分類する型で、<code>Prop</code>はその真実の証拠を分類する命題を分類する型。
<code>Coe</code>が型の不一致が発生したときにチェックされるのと同様に、ソート以外の何かがソートを期待する文脈で提供されるときに<code>CoeSort</code>が使用されます。</p>
<p>モノイドからその担体集合への強制変換は担体を抽出します：</p>
<pre><code class="language-lean">instance : CoeSort Monoid Type where
  coe m := m.Carrier
</code></pre>
<p>この強制変換を使用すると、型シグネチャが負担の少ないものになります：</p>
<pre><code class="language-lean">def foldMap (M : Monoid) (f : α → M) (xs : List α) : M :=
  let rec go (soFar : M) : List α → M
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p><code>CoeSort</code>のもう一つの有用な例は、<code>Bool</code>と<code>Prop</code>の間の隙間を埋めるために使用されます。
<a href="type-classes/standard-classes.html#equality-and-ordering">等価性と順序についての章</a>で議論したように、Leanの <code>if</code> 文は条件が <code>Bool</code> ではなく判定可能な命題であることを期待しています。
しかし、プログラムは通常、ブール値に基づいて分岐する必要があります。
それに対し、Lean標準ライブラリは <code>Bool</code> から問題の <code>Bool</code> が <code>true</code> に等しいという命題への強制変換を定義しています：</p>
<pre><code class="language-lean">instance : CoeSort Bool Prop where
  coe b := b = true
</code></pre>
<p>この場合、疑問に思われるソートは <code>Prop</code> ではなく <code>Type</code> です。</p>
<h2 id="関数への強制変換-coercing-to-functions"><a class="header" href="#関数への強制変換-coercing-to-functions">関数への強制変換 (Coercing to Functions)</a></h2>
<p>プログラミングで定期的に出現する多くのデータ型は、その関数についていくつかの追加情報とともに構成されます。
例えば、名前はログに表示するためのものやいくつかの設定データが関数に伴って提供されることがあります。
さらに、<code>Monoid</code> の例のように、構造のフィールドに型を置くことは、操作の実装方法が複数あり、型クラスを使用するよりも手動での制御が必要な文脈で意味を成す場合があります。
例えば、JSONシリアライザによって発行される値の特定の詳細が重要であるかもしれません。これは、別のアプリケーションが特定の形式を期待しているためです。
場合によっては、構成データ自体から関数を導出できることもあります。</p>
<p>非関数型の値を関数型へと変換する型クラスとして <code>CoeFun</code> があります。
<code>CoeFun</code> には二つのパラメータがあります：一つ目は関数に変換されるべき型で、二つ目はどの関数型をターゲットにするかを決定する出力パラメータです。</p>
<pre><code class="language-lean">class CoeFun (α : Type) (makeFunctionType : outParam (α → Type)) where
  coe : (x : α) → makeFunctionType x
</code></pre>
<p>二つ目のパラメータ自体は型を計算する関数です。
Leanでは、型は第一級の市民であり、他のどんなものと同じように関数に渡されたり、関数から返されたりします。</p>
<p>例えば、その引数に定数を加える関数は、加える量を含むラッパーとして表現できます。
そして、実際の関数を定義するのではなく、どれだけ加えるかに関するラッパーとして以下のようになります：</p>
<pre><code class="language-lean">structure Adder where
  howMuch : Nat
</code></pre>
<p>その引数に5を加える関数は、<code>howMuch</code> フィールドに <code>5</code> を持っています：</p>
<pre><code class="language-lean">def add5 : Adder := ⟨5⟩
</code></pre>
<p>この <code>Adder</code> 型は、関数ではなく、その引数に適用するとエラーが発生します。</p>
<pre><code class="language-lean">#eval add5 3
</code></pre>
<pre><code class="language-output error">function expected at
  add5
term has type
  Adder
</code></pre>
<p><code>CoeFun</code> インスタンスを定義することで、Leanはadderを <code>Nat → Nat</code> 型の関数へと変換します：</p>
<pre><code class="language-lean">instance : CoeFun Adder (fun _ =&gt; Nat → Nat) where
  coe a := (· + a.howMuch)

#eval add5 3
</code></pre>
<pre><code class="language-output info">8
</code></pre>
<p>すべての <code>Adder</code> が <code>Nat → Nat</code> 関数に変換されるべきであるため、「CoeFun」の二つ目のパラメータへの引数は無視されました。</p>
<p>値自体が正しい関数型を特定するために必要な場合、<code>CoeFun</code> の二つ目のパラメータはもはや無視されません。
例えば、以下のJSON値の表現を考えます：</p>
<pre><code class="language-lean">inductive JSON where
  | true : JSON
  | false : JSON
  | null : JSON
  | string : String → JSON
  | number : Float → JSON
  | object : List (String × JSON) → JSON
  | array : List JSON → JSON
deriving Repr
</code></pre>
<p>JSONシリアライザは、シリアライズ可能な型を追跡し、そのシリアライズ自体のコードを含む構造体です：</p>
<pre><code class="language-lean">structure Serializer where
  Contents : Type
  serialize : Contents → JSON
</code></pre>
<p>文字列のシリアライザは、提供された文字列を <code>JSON.string</code> コンストラクタに包む必要しかないです：</p>
<pre><code class="language-lean">def Str : Serializer :=
  { Contents := String,
    serialize := JSON.string
  }
</code></pre>
<p>JSONシリアライザを、引数をシリアライズする関数として見るためには、シリアライズ可能なデータの内部型を抽出する必要があります：</p>
<pre><code class="language-lean">instance : CoeFun Serializer (fun s =&gt; s.Contents → JSON) where
  coe s := s.serialize
</code></pre>
<p>このインスタンスがあれば、シリアライザを直接引数に適用することができます：</p>
<pre><code class="language-lean">def buildResponse (title : String) (R : Serializer) (record : R.Contents) : JSON :=
  JSON.object [
    (&quot;title&quot;, JSON.string title),
    (&quot;status&quot;, JSON.number 200),
    (&quot;record&quot;, R record)
  ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追加の便利機能-1"><a class="header" href="#追加の便利機能-1">追加の便利機能</a></h1>
<h2 id="インスタンスのコンストラクタ構文"><a class="header" href="#インスタンスのコンストラクタ構文">インスタンスのコンストラクタ構文</a></h2>
<p>背後では、型クラスは構造型であり、インスタンスはこれらの型の値です。
唯一の違いは、Leanが型クラスについての追加情報、たとえばどのパラメータが出力パラメータであるかなどを格納し、インスタンスが検索用に登録されているということです。
構造型を持つ値は通常 <code>⟨...⟩</code> 構文または中括弧とフィールドを用いて定義されますが、インスタンスは通常 <code>where</code> を使用して定義されます。しかし、両方の構文は両方の定義で機能します。</p>
<p>たとえば、森林アプリケーションでは以下のように木を表現するかもしれません：</p>
<pre><code class="language-lean">structure Tree : Type where
  latinName : String
  commonNames : List String

def oak : Tree :=
  ⟨&quot;Quercus robur&quot;, [&quot;common oak&quot;, &quot;European oak&quot;]⟩

def birch : Tree :=
  { latinName := &quot;Betula pendula&quot;,
    commonNames := [&quot;silver birch&quot;, &quot;warty birch&quot;]
  }

def sloe : Tree where
  latinName := &quot;Prunus spinosa&quot;
  commonNames := [&quot;sloe&quot;, &quot;blackthorn&quot;]
</code></pre>
<p>これら三つの構文は等価です。</p>
<p>同様に、型クラスのインスタンスをすべての三つの構文を使用して定義することができます：</p>
<pre><code class="language-lean">class Display (α : Type) where
  displayName : α → String

instance : Display Tree :=
  ⟨Tree.latinName⟩

instance : Display Tree :=
  { displayName := Tree.latinName }

instance : Display Tree where
  displayName t := t.latinName
</code></pre>
<p>一般的に、<code>where</code> 構文はインスタンスに使用すべきであり、中括弧の構文は構造に使用すべきです。
<code>⟨...⟩</code> 構文は、構造型が名前付きのフィールドを持つタプルと非常に似ている場合に有効であり、その瞬間に名前が重要ではないときに強調するのに便利です。
しかし、他の代替手段を使用することが理にかなっている状況もあります。
特に、ライブラリがインスタンス値を構築する機能を提供する場合があります。
インスタンス宣言の <code>:=</code> の後にこの機能への呼び出しを配置することは、このような機能を使用する最も簡単な方法です。</p>
<h2 id="例"><a class="header" href="#例">例</a></h2>
<p>Leanのコードを実験する際には、<code>#eval</code> や <code>#check</code> コマンドよりも定義を使用する方が便利です。
まず、定義は出力を生成しないため、読者の注目を最も興味深い出力に集中させるのに役立ちます。
次に、ほとんどのLeanプログラムは型シグネチャから始める方が、プログラムそのものを書きながらLeanがより多くの支援を提供し、より良いエラーメッセージを与えることができます。
一方で、Leanが提供された式から型を決定できる場合には、<code>#eval</code> と <code>#check</code> を使用する方が簡単です。
さらに、<code>#eval</code> は <code>ToString</code> や <code>Repr</code> のインスタンスを持たない型の式、例えば関数と一緒には使用できません。
最後に、複数ステップの <code>do</code> ブロックや、<code>let</code>-式、およびその他の複数行にまたがる構文形式は、<code>#eval</code> や <code>#check</code> で型注釈を付けるのが特に難しくなります。なぜなら、必要な括弧が予測しにくいからです。</p>
<p>これらの問題を解決するため、Leanはソースファイルでの例の明示的な表示をサポートしています。
例は名前を持たない定義のようなものです。
例えば、コペンハーゲンの緑地に一般的に見られる鳥の空でないリストは以下のように書かれるかもしれません：</p>
<pre><code class="language-lean">example : NonEmptyList String :=
  { head := &quot;Sparrow&quot;,
    tail := [&quot;Duck&quot;, &quot;Swan&quot;, &quot;Magpie&quot;, &quot;Eurasian coot&quot;, &quot;Crow&quot;]
  }
</code></pre>
<p>例は引数を受け入れることで関数を定義することが可能です：</p>
<pre><code class="language-lean">example (n : Nat) (k : Nat) : Bool :=
  n + k == k + n
</code></pre>
<p>これにより、裏側で関数が作成されますが、この関数には名前がなく、呼び出すことはできません。
それでも、これは、いくつかの与えられた型の任意の値または不明な値を使用してライブラリがどのように使用され得るかを示すのに有用です。
ソースファイルでは、<code>example</code> 宣言はライブラリのコンセプトを説明するコメントと一緒に使用するのが最も適しています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要"><a class="header" href="#概要">概要</a></h1>
<h2 id="タイプクラスとオーバーロード"><a class="header" href="#タイプクラスとオーバーロード">タイプクラスとオーバーロード</a></h2>
<p>タイプクラスは、Leanにおける関数や演算子のオーバーロードのための機構です。
多相的な関数は複数の型に使用することができますが、どの型を使用しても同じ方法で振る舞います。
たとえば、2つのリストを結合する多相的な関数は、リストのエントリの型にかかわらず使用できますが、特定の型に基づいて異なる振る舞いをすることはできません。
一方でタイプクラスでオーバーロードされた演算は、複数の型に対して使用することができます。
しかし、各型はオーバーロードされた演算のための独自の実装が必要です。
これにより、提供された型に基づいて振る舞いが異なることを意味します。</p>
<p><em>タイプクラス</em> は名前、パラメータ、およびオーバーロード可能な演算の名前と型が含まれる数個の項目からなる本体を持ちます。
名前はオーバーロードされた演算に参照するための方法であり、パラメータは定義のどの側面をオーバーロードすることができるかを決定し、本体はオーバーロード可能な演算の名前と型シグネチャを提供します。
タイプクラスの各オーバーロード可能な演算は、そのタイプクラスの_メソッド_ と呼ばれます。
タイプクラスは、他のメソッドに関していくつかのメソッドのデフォルト実装を提供することがあり、これは実装者が必要でない場合に手動で各オーバーロードを定義する手間を省くことができます。</p>
<p>タイプクラスの <em>インスタンス</em> は、特定のパラメータに対するメソッドの実装を提供します。
インスタンスは多相的であり、場合によってはさまざまなパラメータで機能し、特定の型に対してより効率的なバージョンが存在する場合には、デフォルトメソッドのより具体的な実装を任意で提供することもできます。</p>
<p>タイプクラスのパラメータは、<em>入力パラメータ</em>（デフォルト）、または <code>outParam</code> によって示される <em>出力パラメータ</em> のいずれかです。
Leanは入力パラメータがもはやメタ変数でなくなるまでインスタンスの検索を開始しませんが、出力パラメータはインスタンスを検索しながら解決されることがあります。
タイプクラスのパラメータは、型である必要はありません。通常の値でもよいのです。
自然数リテラルをオーバーロードするために使用される <code>OfNat</code> タイプクラスは、オーバーロードされる <code>Nat</code> 自体をパラメータとして取り、インスタンスが許可される数字を制限することができます。</p>
<p>インスタンスは <code>@[default_instance]</code> 属性でマークすることができます。
インスタンスがデフォルトインスタンスである場合、型のメタ変数の存在により、Leanがインスタンスが見つからないと失敗するであろうときに、それがフォールバックとして選ばれます。</p>
<h2 id="一般的な構文のためのタイプクラス"><a class="header" href="#一般的な構文のためのタイプクラス">一般的な構文のためのタイプクラス</a></h2>
<p>Leanの多くの中置演算子はタイプクラスでオーバーライドされています。
たとえば、加算演算子は <code>Add</code> というタイプクラスに対応しています。
これらの演算子の多くは、異種バージョンを持っており、その場合、2つの引数が同じ型である必要はありません。
これらの異種演算子は、クラスの名前が <code>H</code> で始まるバージョンを使用してオーバーロードされます。たとえば <code>HAdd</code> のように。</p>
<p>インデックス構文は、証明を伴う <code>GetElem</code> というタイプクラスを使用してオーバーロードされます。
<code>GetElem</code> は2つの出力パラメータを持ち、それらはコレクションから抽出される要素の型とコレクションのインデックス値が範囲内であると考えられることを決定するために使用できる関数です。
この証拠は命題によって記述され、配列インデックスが使用される際に、Leanはこの命題を証明しようと試みます。
Leanがコンパイル時にリストや配列アクセス操作が範囲内であることを確認できない場合、インデックス操作に <code>?</code> を追加することで、実行時にチェックを延期することができます。</p>
<h2 id="ファンクター"><a class="header" href="#ファンクター">ファンクター</a></h2>
<p>ファンクターは、マッピング操作をサポートする多相型です。
このマッピング操作は、「場所に応じて」すべての要素を変換し、他の構造は変更しません。
たとえば、リストはファンクターであり、マッピング操作はリスト内のエントリを落としたり、複製したり、混ぜたりすることはありません。</p>
<p>ファンクターは <code>map</code> を持っていることで定義されていますが、Leanの <code>Functor</code> タイプクラスには、多相型変数によって与えられるすべての値を同じ新しい値で置き換えるために、定数関数を値にマッピングする責任を持つ追加のデフォルトメソッドが含まれています。
いくつかのファンクターにとって、これは全体の構造を渡るよりも効率的に行うことができます。</p>
<h2 id="インスタンスの派生"><a class="header" href="#インスタンスの派生">インスタンスの派生</a></h2>
<p>多くのタイプクラスには非常に標準的な実装があります。
たとえば、ブール等価クラス <code>BEq</code> は通常、両方の引数が同じコンストラクターで構築されているかどうかを先に確認し、その後すべての引数が等しいかどうかを確認することによって実装されます。
これらのクラスのインスタンスは_自動的に_ 作成することができます。</p>
<p>帰納的型や構造を定義するとき、宣言の最後に <code>deriving</code> 節を追加すると、インスタンスが自動的に作成されます。
さらに、データ型の定義の外に <code>deriving instance ... for ...</code> コマンドを使用することで、インスタンスが生成されるように指示することができます。
派生可能なインスタンスを持つ各クラスには特別な取り扱いが必要であるため、すべてのクラスが派生可能なわけではありません。</p>
<h2 id="強制変換"><a class="header" href="#強制変換">強制変換</a></h2>
<p>強制変換は、通常コンパイル時のエラーになるであろうものから、一方の型から別の型にデータを変換する関数の呼び出しを挿入することで、Leanが回復することを可能にします。
たとえば、任意の型 <code>α</code> から型 <code>Option α</code> への強制変換により、値を <code>some</code> コンストラクタを使わずに直接書くことが可能になり、<code>Option</code> をオブジェクト指向言語の nullable 型のように機能させることができます。</p>
<p>強制変換には複数の種類があります。
それらは異なる種類のエラーから回復することができ、それらはそれぞれ独自のタイプクラスによって表されます。
<code>Coe</code> クラスは型エラーから回復するために使用されます。
Leanが型 <code>α</code> の式を型 <code>β</code> が期待されるコンテキストで持っている場合、Leanは最初に <code>α</code> を <code>β</code> に変換する強制変換のチェーンを繋ぎ合わせることを試み、これが不可能であるときのみエラーを表示します。
<code>CoeDep</code> クラスは、強制される特定の値を追加のパラメータとして取り、さらにその値に対してタイプクラス検索を行うことを可能にするか、インスタンスでコンストラクターを使用して変換の範囲を制限することを可能にします。
<code>CoeFun</code> クラスは、関数適用をコンパイルする際の「関数ではない」エラーを補足し、関数位置にある値が可能であれば実際の関数に変換されることを可能にします。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナド"><a class="header" href="#モナド">モナド</a></h1>
<p>C#やKotlinでは、<code>?.</code>オペレータはnullかもしれない値のプロパティをルックアップしたりメソッドを呼び出したりする方法です。もしレシーバが<code>null</code>なら、その全ての式はnullになります。そうでなければ、基本となる非<code>null</code>の値が呼び出しを受けます。<code>?.</code>の使用は連鎖的に可能で、その場合最初のnull結果がルックアップの鎖を終了させます。このようにnullチェックを連鎖させるのは、深くネストされた<code>if</code>文を書いて維持していくよりもはるかに便利です。</p>
<p>同様に、エラーコードの手動でのチェックと伝播よりも例外はかなり便利です。同時に、ロギングは専用のロギング・フレームワークを持つことにより、関数がそのログ結果と戻り値を両方返すことよりも実現が最も簡単です。連鎖するnullチェックと例外は通常、言語設計者がこの使用例を予期することを必要とし、一方でロギング・フレームワークは、ログの蓄積からログを記録するコードを分離するために副作用を使用することが一般的です。</p>
<p>これらの機能やその他の多くの機能は、<code>モナド</code>と呼ばれる共通APIのインスタンスとしてライブラリコードで実装することができます。LeanはこのAPIを使用するのに便利な専用の構文を提供していますが、背後で何が起こっているのかを理解する際には邪魔になることがあります。この章は、手動でnullチェックをネストする詳細なプレゼンテーションから始まり、そこから便利で一般的なAPIへと拡張されます。その間は、信じがたいことに耐えてください。</p>
<h2 id="noneのチェック繰り返しを避ける"><a class="header" href="#noneのチェック繰り返しを避ける"><code>none</code>のチェック：繰り返しを避ける</a></h2>
<p>Leanでは、パターンマッチングを使ってnullのチェックを連鎖させることができます。リストから最初のエントリを取得するには、オプショナルなインデックス記法を使うだけです：</p>
<pre><code>def first (xs : List α) : Option α :=
  xs[0]?
</code></pre>
<p>結果は<code>Option</code>である必要があります。なぜなら空のリストには最初のエントリがないからです。最初と3番目のエントリを抽出するには、それぞれが<code>none</code>ではないというチェックが必要です：</p>
<pre><code>def firstThird (xs : List α) : Option (α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      some (first, third)
</code></pre>
<p>同様に、最初、3番目、5番目のエントリを抽出するには、さらに値が<code>none</code>でないというチェックが必要です：</p>
<pre><code>def firstThirdFifth (xs : List α) : Option (α × α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      match xs[4]? with
      | none =&gt; none
      | some fifth =&gt;
        some (first, third, fifth)
</code></pre>
<p>そして、このシーケンスに7番目のエントリを追加すると、管理がかなり困難になり始めます：</p>
<pre><code>def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  match xs[0]? with
  | none =&gt; none
  | some first =&gt;
    match xs[2]? with
    | none =&gt; none
    | some third =&gt;
      match xs[4]? with
      | none =&gt; none
      | some fifth =&gt;
        match xs[6]? with
        | none =&gt; none
        | some seventh =&gt;
          some (first, third, fifth, seventh)
</code></pre>
<p>このコードの基本的な問題は、数値を抽出することと全てが存在することを確認することの2つの関心を扱っていることですが、2番目の関心は<code>none</code>の場合のコードをコピー＆ペーストすることで対応されています。繰り返されるセグメントをヘルパー関数に持ち上げることは、しばしば良いスタイルです：</p>
<pre><code>def andThen (opt : Option α) (next : α → Option β) : Option β :=
  match opt with
  | none =&gt; none
  | some x =&gt; next x
</code></pre>
<p>このヘルパーは、C#やKotlinでの<code>?.</code>と同様に、<code>none</code>の値を伝播することを担当します。これは、オプショナルな値と、その値が<code>none</code>でない場合に適用される関数の2つの引数をとります。最初の引数が<code>none</code>の場合、ヘルパーは<code>none</code>を返します。最初の引数が<code>none</code>でない場合、関数は<code>some</code>コンストラクタの内容に適用されます。</p>
<p>これで、<code>firstThird</code>をパターンマッチングの代わりに<code>andThen</code>を使って書き直すことができます：</p>
<pre><code>def firstThird (xs : List α) : Option (α × α) :=
  andThen xs[0]? fun first =&gt;
  andThen xs[2]? fun third =&gt;
  some (first, third)
</code></pre>
<p>Leanでは、関数は引数として渡されるときに括弧で囲む必要はありません。以下の同等の定義は、より多くの括弧を使用し、関数のボディをインデントしています：</p>
<pre><code>def firstThird (xs : List α) : Option (α × α) :=
  andThen xs[0]? (fun first =&gt;
    andThen xs[2]? (fun third =&gt;
      some (first, third)))
</code></pre>
<p><code>andThen</code>ヘルパーは値が流れる一種の「パイプライン」を提供し、インデントが少し変わったバージョンの方がこの事実をより暗示しています。<code>andThen</code>を書くための構文を改善することで、これらの計算をさらに理解しやすくすることができます。</p>
<h3 id="中置演算子"><a class="header" href="#中置演算子">中置演算子</a></h3>
<p>Leanでは、中置演算子は<code>infix</code>、<code>infixl</code>、<code>infixr</code>コマンドを使用して宣言され、それぞれ非結合、左結合、右結合の演算子を作成します。連続して使用される場合、_左結合_の演算子は開き括弧を式の左側に積み上げます。加算演算子<code>+</code>は左結合なので、<code>w + x + y + z</code>は<code>(((w + x) + y) + z)</code>と同値です。べき乗演算子<code>^</code>は右結合なので、<code>w ^ x ^ y ^ z</code>は<code>(w ^ (x ^ (y ^ z)))</code>と同値です。<code>&lt;</code>のような比較演算子は非結合なので、<code>x &lt; y &lt; z</code>は構文エラーであり、手動で括弧を付ける必要があります。</p>
<p>次の宣言は<code>andThen</code>を中置演算子にします：</p>
<pre><code>infixl:55 &quot; ~~&gt; &quot; =&gt; andThen
</code></pre>
<p>コロンの後の数字は、新しい中置演算子の_優先順位_を宣言します。通常の数学記法では、<code>x + y * z</code>は<code>x + (y * z)</code>と等価ですが、<code>+</code>と<code>*</code>は共に左結合です。Leanでは、<code>+</code>は優先順位65、<code>*</code>は優先順位70を持ちます。優先度の高い演算子は、優先度の低い演算子よりも先に適用されます。<code>~~&gt;</code>の宣言に従うと、<code>+</code>と<code>*</code>は両方ともより高い優先順位を持ち、つまり先に適用されます。通常、一連の演算子の最も便利な優先順位を決定するには、いくつかの実験と多くの例が必要になります。</p>
<p>新しい中置演算子の後には<code>=&gt;</code>の二重矢印があり、中置演算子に使用される名前付き関数を指定します。Leanの標準ライブラリはこの機能を使用して、型クラスを使用して中置演算子をオーバーロードする<code>HAdd.hAdd</code>と<code>HMul.hMul</code>をそれぞれ指す中置演算子として<code>+</code>と<code>*</code>を定義しています。しかし、ここでの<code>andThen</code>はただの通常の関数です。</p>
<p><code>andThen</code>を中置演算子として定義することにより、<code>firstThird</code>は「パイプライン」の感じを前面に出す方法で書き直されます：</p>
<pre><code>def firstThirdInfix (xs : List α) : Option (α × α) :=
  xs[0]? ~~&gt; fun first =&gt;
  xs[2]? ~~&gt; fun third =&gt;
  some (first, third)
</code></pre>
<p>このスタイルは、より大きな関数を書く際にはるかに簡潔です：</p>
<pre><code>def firstThirdFifthSeventh (xs : List α) : Option (α × α × α × α) :=
  xs[0]? ~~&gt; fun first =&gt;
  xs[2]? ~~&gt; fun third =&gt;
  xs[4]? ~~&gt; fun fifth =&gt;
  xs[6]? ~~&gt; fun seventh =&gt;
  some (first, third, fifth, seventh)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナド型クラス"><a class="header" href="#モナド型クラス">モナド型クラス</a></h1>
<p>それぞれのモナド型に対して、<code>ok</code> や <code>andThen</code> のような演算子をインポートする必要がないように、Leanの標準ライブラリには、それらをオーバーロードできる型クラスが含まれており、_任意の_モナドに対して同じ演算子を使うことができます。
モナドには二つの操作があり、それは <code>ok</code> と <code>andThen</code> の同等物です：</p>
<pre><code class="language-lean">class Monad (m : Type → Type) where
  pure : α → m α
  bind : m α → (α → m β) → m β
</code></pre>
<p>この定義はやや単純化されています。
Leanライブラリでの実際の定義はもう少し複雑で、後で紹介されます。</p>
<p><code>Option</code> や <code>Except</code> の <code>Monad</code> インスタンスは、それぞれの <code>andThen</code> 操作の定義を適応することで作成できます：</p>
<pre><code class="language-lean">instance : Monad Option where
  pure x := some x
  bind opt next :=
    match opt with
    | none =&gt; none
    | some x =&gt; next x

instance : Monad (Except ε) where
  pure x := Except.ok x
  bind attempt next :=
    match attempt with
    | Except.error e =&gt; Except.error e
    | Except.ok x =&gt; next x
</code></pre>
<p>例として、<code>firstThirdFifthSeventh</code> は <code>Option α</code> と <code>Except String α</code> の戻り値の型に対して別々に定義されました。
今は、_任意の_モナドに対して多相的に定義することができます。
しかしながら、異なるモナドが結果を見つけられない異なる方法について考慮するため、引数としてのルックアップ関数が必要です。
<code>bind</code> の中置バージョンは <code>&gt;&gt;=</code> で、これは例の中の <code>~~&gt;</code> と同じ役割を果たします。</p>
<pre><code class="language-lean">def firstThirdFifthSeventh [Monad m] (lookup : List α → Nat → m α) (xs : List α) : m (α × α × α × α) :=
  lookup xs 0 &gt;&gt;= fun first =&gt;
  lookup xs 2 &gt;&gt;= fun third =&gt;
  lookup xs 4 &gt;&gt;= fun fifth =&gt;
  lookup xs 6 &gt;&gt;= fun seventh =&gt;
  pure (first, third, fifth, seventh)
</code></pre>
<p>ゆっくり動く哺乳類と速く飛ぶ鳥の例としてのリストが与えられたとき、この実装の <code>firstThirdFifthSeventh</code> は <code>Option</code> と一緒に使うことができます：</p>
<pre><code class="language-lean">def slowMammals : List String :=
  [&quot;Three-toed sloth&quot;, &quot;Slow loris&quot;]

def fastBirds : List String := [
  &quot;Peregrine falcon&quot;,
  &quot;Saker falcon&quot;,
  &quot;Golden eagle&quot;,
  &quot;Gray-headed albatross&quot;,
  &quot;Spur-winged goose&quot;,
  &quot;Swift&quot;,
  &quot;Anna's hummingbird&quot;
]

#eval firstThirdFifthSeventh (fun xs i =&gt; xs[i]?) slowMammals
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<pre><code class="language-lean">#eval firstThirdFifthSeventh (fun xs i =&gt; xs[i]?) fastBirds
</code></pre>
<pre><code class="language-output info">some (&quot;Peregrine falcon&quot;, &quot;Golden eagle&quot;, &quot;Spur-winged goose&quot;, &quot;Anna's hummingbird&quot;)
</code></pre>
<p><code>Except</code> のルックアップ関数 <code>get</code> の名前をより具体的なものに変えると、同じ実装の <code>firstThirdFifthSeventh</code> を <code>Except</code> と一緒に使うこともできます：</p>
<pre><code class="language-lean">def getOrExcept (xs : List α) (i : Nat) : Except String α :=
  match xs[i]? with
  | none =&gt; Except.error s!&quot;Index {i} not found (maximum is {xs.length - 1})&quot;
  | some x =&gt; Except.ok x

#eval firstThirdFifthSeventh getOrExcept slowMammals
</code></pre>
<pre><code class="language-output info">Except.error &quot;Index 2 not found (maximum is 1)&quot;
</code></pre>
<pre><code class="language-lean">#eval firstThirdFifthSeventh getOrExcept fastBirds
</code></pre>
<pre><code class="language-output info">Except.ok (&quot;Peregrine falcon&quot;, &quot;Golden eagle&quot;, &quot;Spur-winged goose&quot;, &quot;Anna's hummingbird&quot;)
</code></pre>
<p><code>m</code> が <code>Monad</code> インスタンスを持っていなければならないという事実は、<code>&gt;&gt;=</code> 操作と <code>pure</code> 操作が利用可能であることを意味します。</p>
<h2 id="一般的なモナド操作"><a class="header" href="#一般的なモナド操作">一般的なモナド操作</a></h2>
<p>多くの異なる型がモナドであるため、_任意の_モナドに対して多相的な関数は非常に強力です。
例えば、関数 <code>mapM</code> は <code>Monad</code> を使用して関数を適用した結果を順序づけて組み合わせる <code>map</code> のバージョンです：</p>
<pre><code class="language-lean">def mapM [Monad m] (f : α → m β) : List α → m (List β)
  | [] =&gt; pure []
  | x :: xs =&gt;
    f x &gt;&gt;= fun hd =&gt;
    mapM f xs &gt;&gt;= fun tl =&gt;
    pure (hd :: tl)
</code></pre>
<p>関数引数 <code>f</code> の戻り値の型はどの <code>Monad</code> インスタンスが使用されるかを決定します。
言い換えると、<code>mapM</code> はログを生成する関数、失敗する可能性がある関数、または可変状態を使用する関数に対して使用できます。
<code>f</code> の型が利用可能な効果を決定するため、APIデザイナーはそれらを厳密に制御することができます。</p>
<p><a href="monads/../monads.html#numbering-tree-nodes">この章のイントロダクション</a>で記述されているように、<code>State σ α</code> は可変変数の型 <code>σ</code> を使用し、型 <code>α</code> の値を返すプログラムを表します。
これらのプログラムは実際には、開始状態から値と最終状態のペアへの関数です。
<code>Monad</code> クラスでは、そのパラメーターが単一の型引数を期待することが必要です。つまり、<code>Type → Type</code> であるべきです。
これは、<code>State</code> のインスタンスは状態型 <code>σ</code> を言及し、インスタンスへのパラメーターになるべきだということを意味します：</p>
<pre><code class="language-lean">instance : Monad (State σ) where
  pure x := fun s =&gt; (s, x)
  bind first next :=
    fun s =&gt;
      let (s', x) := first s
      next x s'
</code></pre>
<p>これは、<code>get</code> と <code>set</code> の呼び出し之间を <code>bind</code> を使用してシーケンスするときに、状態の型は変化することはないという合理的なルールです。
オペレータ <code>increment</code> は与えられた量だけ保存された状態を増加させ、古い値を返します:</p>
<pre><code class="language-lean">def increment (howMuch : Int) : State Int Int :=
  get &gt;&gt;= fun i =&gt;
  set (i + howMuch) &gt;&gt;= fun () =&gt;
  pure i
</code></pre>
<p><code>mapM</code> を <code>increment</code> と一緒に使用すると、リストのエントリーの総和を計算するプログラムになります。
より具体的には、可変変数はこれまでの総和を含み、結果としてのリストは逐次的な総和を含んでいます。
言い換えると、<code>mapM increment</code>は型<code>List Int → State Int (List Int)</code>を持ち、<code>State</code>の定義を展開すると<code>List Int → Int → (Int × List Int)</code>となります。
初期総和としての引数を取り、これは <code>0</code> であるべきです:</p>
<pre><code class="language-lean">#eval mapM increment [1, 2, 3, 4, 5] 0
</code></pre>
<pre><code class="language-output info">(15, [0, 1, 3, 6, 10])
</code></pre>
<p><a href="monads/../monads.html#logging">ログ効果</a>は<code>WithLog</code> を使用することで表現できます。
<code>State</code>と同じように、その <code>Monad</code> インスタンスはログデータの型に対して多态的です:</p>
<pre><code class="language-lean">instance : Monad (WithLog logged) where
  pure x := {log := [], val := x}
  bind result next :=
    let {log := thisOut, val := thisRes} := result
    let {log := nextOut, val := nextRes} := next thisRes
    {log := thisOut ++ nextOut, val := nextRes}
</code></pre>
<p><code>saveIfEven</code> は偶数をログに記録するが、引数を変更せずに返す関数です:</p>
<pre><code class="language-lean">def saveIfEven (i : Int) : WithLog Int Int :=
  (if isEven i then
    save i
   else pure ()) &gt;&gt;= fun () =&gt;
  pure i
</code></pre>
<p>この関数を <code>mapM</code> と一緒に使用すると、偶数が含まれるログと変更されていない入力リストのペアが得られます:</p>
<pre><code class="language-lean">#eval mapM saveIfEven [1, 2, 3, 4, 5]
</code></pre>
<pre><code class="language-output info">{ log := [2, 4], val := [1, 2, 3, 4, 5] }
</code></pre>
<h2 id="アイデンティティモナド"><a class="header" href="#アイデンティティモナド">アイデンティティモナド</a></h2>
<p>モナドは、失敗、例外、ログのような効果をデータと関数としての明示的な表現にエンコードします。
しかし、たまにAPIが多様性のためにモナドを使用して記述されているが、APIのクライアントはエンコードされた効果を必要としない場合があります。
<em>アイデンティティモナド</em> は、効果のないモナドであり、純粋なコードをモナディックなAPIとともに使用させることができます：</p>
<pre><code class="language-lean">def Id (t : Type) : Type := t

instance : Monad Id where
  pure x := x
  bind x f := f x
</code></pre>
<p><code>pure</code> の型は <code>α → Id α</code> であるべきですが、<code>Id α</code> は単純に <code>α</code> にまで簡約されます。
同様に、<code>bind</code> の型は <code>α → (α → Id β) → Id β</code> であるべきです。
これは <code>α → (α → β) → β</code> にまで簡約されるため、第二引数は第一引数に適用して結果を見つけることができます。</p>
<p>アイデンティティモナドを使うと、<code>mapM</code> は <code>map</code> に等価になります。
しかし、Leanでは使用されるモナドが <code>Id</code> であるというヒントが必要です：</p>
<pre><code class="language-lean">#eval mapM (m := Id) (· + 1) [1, 2, 3, 4, 5]
</code></pre>
<pre><code class="language-output info">[2, 3, 4, 5, 6]
</code></pre>
<p>ヒントがないとエラーになります：</p>
<pre><code class="language-lean">#eval mapM (· + 1) [1, 2, 3, 4, 5]
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  HAdd Nat Nat (?m.9063 ?m.9065)
</code></pre>
<p>このエラーでは、1つのメタ変数を別のメタ変数に適用することは、Leanが型レベルの計算を後方に実行しないことを示しています。
関数の戻り値の型は何らかの他の型に適用されたモナドであることが期待されます。
同様に、どのモナドを使用しようとも特定のヒントを提供しない型の関数と <code>mapM</code> を使用すると、「インスタンス問題が詰まる」というメッセージが表示されます：</p>
<pre><code class="language-lean">#eval mapM (fun x =&gt; x) [1, 2, 3, 4, 5]
</code></pre>
<pre><code class="language-output error">typeclass instance problem is stuck, it is often due to metavariables
  Monad ?m.9063
</code></pre>
<h2 id="モナドの契約"><a class="header" href="#モナドの契約">モナドの契約</a></h2>
<p><code>BEq</code> インスタンスと <code>Hashable</code> インスタンスのすべてのペアが等しい値を同じハッシュにするべきだというように、<code>Monad</code> のインスタンスごとにモナド契約が遵守されるべきです。
最初に、<code>pure</code> は <code>bind</code> の左同一性でなければならない。
つまり、<code>bind (pure v) f</code> は <code>f v</code> と同じであるべきです。
次に、<code>pure</code> は <code>bind</code> の右同一性であり、したがって <code>bind v pure</code> は <code>v</code> と同じであるべきです。
最後に、<code>bind</code> は結合的であるため、<code>bind (bind v f) g</code> は <code>bind v (fun x =&gt; bind (f x) g)</code> と同じであるべきです。</p>
<p>この契約は、より一般的に効果を持つプログラムの期待される特性を指定しています。
<code>pure</code> には効果がないので、<code>bind</code> でその効果をシーケンス化することは結果を変えるべきではありません。
<code>bind</code> の結合性は基本的に、シーケンスブックキーピング自体は問題ではないということを言っています。つまり、事象が発生する順序が保持される限り。</p>
<h2 id="練習問題-6"><a class="header" href="#練習問題-6">練習問題</a></h2>
<h3 id="木へのマッピング"><a class="header" href="#木へのマッピング">木へのマッピング</a></h3>
<p>関数 <code>BinTree.mapM</code> を定義してください。
リストに対する <code>mapM</code> との類例により、この関数はモナディック関数をツリーの各データエントリに前順で適用するべきです。
型シグネチャは以下のようになるべきです：</p>
<pre><code>def BinTree.mapM [Monad m] (f : α → m β) : BinTree α → m (BinTree β)
</code></pre>
<h3 id="optionモナド契約"><a class="header" href="#optionモナド契約">Optionモナド契約</a></h3>
<p>最初に、<code>Option</code> の <code>Monad</code> インスタンスがモナド契約を満たしていることを説得的に証明してください。
それから、以下のインスタンスを考えます：</p>
<pre><code class="language-lean">instance : Monad Option where
  pure x := some x
  bind opt next := none
</code></pre>
<p>両方のメソッドは正しい型を持っています。
なぜこのインスタンスがモナド契約に違反するのか説明してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="例-モナドでの算術"><a class="header" href="#例-モナドでの算術">例: モナドでの算術</a></h1>
<p>モナドは、副作用を含むプログラムを副作用を持たない言語でエンコードする方法です。
これを読むと、純粋な関数型プログラムが重要な何かを欠いており、通常のプログラムを書くためにプログラマが苦労して飛び跳ねなければならないという認識にすぐさま飛びつきそうです。
しかしながら、<code>Monad</code> APIを使用することは、プログラムに構文上のコストを課しますが、2つの重要な利益をもたらします：</p>
<ol>
<li>プログラムは、それが使用する副作用について、その型で正直でなければなりません。型シグネチャを一目見るだけで、プログラムが行うことの_全て_が分かり、入力内容や返り値だけではありません。</li>
<li>全ての言語が同じ副作用を提供するわけではありません。例えば、例外を持つ言語だけ、その他の言語は<a href="https://www2.cs.arizona.edu/icon/">Iconの複数の値にわたって検索する</a>など独特のエキゾチックな副作用や、SchemeやRubyの継続を持っています。モナドは_任意_の副作用をエンコードできるため、プログラマは、言語開発者が提供したものに固執するのではなく、特定のアプリケーションに最適なものを選択できます。</li>
</ol>
<p>様々なモナドで意味をなすプログラムの一例は算術表現の評価者です。</p>
<h3 id="算術表現"><a class="header" href="#算術表現">算術表現</a></h3>
<p>算術表現は、リテラルな整数または2つの表現に適用された原始的な２項演算子のいずれかです。演算子は加算、減算、乗算、および除算です：</p>
<pre><code class="language-lean">inductive Expr (op : Type) where
  | const : Int → Expr op
  | prim : op → Expr op → Expr op → Expr op


inductive Arith where
  | plus
  | minus
  | times
  | div
</code></pre>
<p>表現 <code>2 + 3</code> は以下のように表されます：</p>
<pre><code class="language-lean">open Expr in
open Arith in
def twoPlusThree : Expr Arith :=
  prim plus (const 2) (const 3)
</code></pre>
<p>そして <code>14 / (45 - 5 * 9)</code> は以下のように表されます：</p>
<pre><code class="language-lean">open Expr in
open Arith in
def fourteenDivided : Expr Arith :=
  prim div (const 14) (prim minus (const 45) (prim times (const 5) (const 9)))
</code></pre>
<h3 id="表現の評価"><a class="header" href="#表現の評価">表現の評価</a></h3>
<p>表現には除算が含まれるため、ゼロでの除算は未定義のため、評価は失敗する可能性があります。
失敗を表す一つの方法は <code>Option</code> を使用することです：</p>
<pre><code class="language-lean">def evaluateOption : Expr Arith → Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= fun v1 =&gt;
    evaluateOption e2 &gt;&gt;= fun v2 =&gt;
    match p with
    | Arith.plus =&gt; pure (v1 + v2)
    | Arith.minus =&gt; pure (v1 - v2)
    | Arith.times =&gt; pure (v1 * v2)
    | Arith.div =&gt; if v2 == 0 then none else pure (v1 / v2)
</code></pre>
<p>この定義は二項演算子の両方の分岐の評価から失敗を伝播するために <code>Monad Option</code> インスタンスを使用しています。
しかしながら、関数は副表現の評価と副表現の結果に二項演算子を適用する２つの関心事を混在させています。
これは2つの関数に分割することで改善できます：</p>
<pre><code class="language-lean">def applyPrim : Arith → Int → Int → Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; if y == 0 then none else pure (x / y)

def evaluateOption : Expr Arith → Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= fun v1 =&gt;
    evaluateOption e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p><code>#eval evaluateOption fourteenDivided</code> を実行すると <code>none</code> となりますが、これはあまり有用なエラーメッセージではありません。
<code>&gt;&gt;=</code> を使用して <code>none</code> コンストラクタを明示的に扱うのではなく、コードが書かれているため、失敗時にエラーメッセージを提供するためには小さな修正だけが必要です：</p>
<pre><code class="language-lean">def applyPrim : Arith → Int → Int → Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)


def evaluateExcept : Expr Arith → Except String Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateExcept e1 &gt;&gt;= fun v1 =&gt;
    evaluateExcept e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p>唯一の違いは、型シグネチャが <code>Option</code> ではなく <code>Except String</code> を参照していること、および失敗する場合は <code>Except.error</code> を使用することです。
<code>evaluate</code> をそのモナドについて多相的にし、それに <code>applyPrim</code> を引数として渡すことで、単一の評価者はエラーメッセージの形式の両方を報告することができます：</p>
<pre><code class="language-lean">def applyPrimOption : Arith → Int → Int → Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      none
    else pure (x / y)

def applyPrimExcept : Arith → Int → Int → Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def evaluateM [Monad m] (applyPrim : Arith → Int → Int → m Int): Expr Arith → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyPrim e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applyPrim e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p><code>applyPrimOption</code> を使用すると、<code>evaluate</code> の最初のバージョンと同じように動作します：</p>
<pre><code class="language-lean">#eval evaluateM applyPrimOption fourteenDivided
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>同じように、<code>applyPrimExcept</code> で使用するとエラーメッセージバージョンと同じように動作します：</p>
<pre><code class="language-lean">#eval evaluateM applyPrimExcept fourteenDivided
</code></pre>
<pre><code class="language-output info">Except.error &quot;Tried to divide 14 by zero&quot;
</code></pre>
<p>コードはまだ改善される可能性があります。
関数 <code>applyPrimOption</code> と <code>applyPrimExcept</code> は除算の扱いだけが異なりますが、評価者への別のパラメータを抽出することによって異なることを示すことができます：</p>
<pre><code class="language-lean">def applyDivOption (x : Int) (y : Int) : Option Int :=
    if y == 0 then
      none
    else pure (x / y)

def applyDivExcept (x : Int) (y : Int) : Except String Int :=
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; applyDiv x y

def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyDiv e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applyDiv e2 &gt;&gt;= fun v2 =&gt;
    applyPrim applyDiv p v1 v2
</code></pre>
<p>このリファクタリングされたコードでは、２つのコードパスが失敗の扱いにおいてのみ異なることが完全に明らかとなっています。</p>
<h3 id="更なる副作用"><a class="header" href="#更なる副作用">更なる副作用</a></h3>
<p>失敗と例外は評価者で作業する際に興味深い唯一の種類の副作用ではありません。
除算の唯一の副作用は失敗ですが、他の基本的な演算子を表現に加えることは他の副作用を表現する可能性があります。</p>
<p>最初のステップは、プリミティブのデータ型から除算を抽出するという追加のリファクタリングです：</p>
<pre><code class="language-lean">inductive Prim (special : Type) where
  | plus
  | minus
  | times
  | other : special → Prim special

inductive CanFail where
  | div
</code></pre>
<p>名前 <code>CanFail</code> は除算によって導入された副作用が潜在的な失敗であることを示唆しています。</p>
<p>二つ目のステップは、<code>evaluateM</code> への除算の処理アーギュメントのスコープを拡大して、特別な演算子を処理することができるようにすることです：</p>
<pre><code class="language-lean">def divOption : CanFail → Int → Int → Option Int
  | CanFail.div, x, y =&gt; if y == 0 then none else pure (x / y)

def divExcept : CanFail → Int → Int → Except String Int
  | CanFail.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int
  | Prim.plus, x, y =&gt; pure (x + y)
  | Prim.minus, x, y =&gt; pure (x - y)
  | Prim.times, x, y =&gt; pure (x * y)
  | Prim.other op, x, y =&gt; applySpecial op x y

def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applySpecial e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applySpecial e2 &gt;&gt;= fun v2 =&gt;
    applyPrim applySpecial p v1 v2
</code></pre>
<h4 id="副作用無し"><a class="header" href="#副作用無し">副作用無し</a></h4>
<p>型 <code>Empty</code> はコンストラクタを持たず、値もない、ScalaやKotlinの <code>Nothing</code> 型のようです。
ScalaとKotlinでは、<code>Nothing</code> はプログラムをクラッシュさせる関数や、例外を投げる、または常に無限ループに陥る計算を表すことができます。
関数またはメソッドへの <code>Nothing</code> 型の引数は、適切な引数値が決して存在しないため、使用されないコードを指示します。
Leanは無限ループや例外をサポートしていませんが、<code>Empty</code> は型システムに対して関数を呼び出すことができないことを示唆するために依然として役立ちます。
型のコンストラクタを持たない式 <code>E</code> の場合、構文 <code>nomatch E</code> はLeanに現在の式が結果を返す必要がないことを示唆します、なぜならそれは決して呼び出され得ないからです。</p>
<p><code>Empty</code> を <code>Prim</code> へのパラメータとして使用する場合、<code>Prim.plus</code>、<code>Prim.minus</code>、<code>Prim.times</code> を超えた追加のケースがないことを示します。<code>Empty</code> の型の値を <code>Prim.other</code> コンストラクタに配置することは不可能であるためです。
二つの整数に <code>Empty</code> 型の演算子を適用する関数が呼び出されることは決してないため、結果を返す必要はありません。
したがって、どんなモナドでも使用できます：</p>
<pre><code class="language-lean">def applyEmpty [Monad m] (op : Empty) (_ : Int) (_ : Int) : m Int :=
  nomatch op
</code></pre>
<p>これは <code>Id</code>、アイデンティティモナドと一緒に使用され、全く副作用のない表現を評価することができます：</p>
<pre><code class="language-lean">open Expr Prim in
#eval evaluateM (m := Id) applyEmpty (prim plus (const 5) (const (-14)))
</code></pre>
<pre><code class="language-output info">-9
</code></pre>
<h4 id="非決定的探索"><a class="header" href="#非決定的探索">非決定的探索</a></h4>
<p>ゼロでの除算に遭遇した際に単に失敗する代わりに、異なる入力を試してバックトラックすることも理にかなっています。
適切なモナドを与えられた場合、全く同じ <code>evaluateM</code> は失敗しない解の_セット_に対して非決定的探索を実行することができます。
この場合、除算に加えて、非失敗の結果を探索する間にいずれかの引数を選択するように評価者に指示する式言語への <code>choose</code> 関数の追加が必要です。</p>
<p>評価者の結果は今や値のマルチセットであり、単一の値ではありません。
マルチセットへの評価規則は以下の通りです：</p>
<ul>
<li>定数 \( n \) はシングルトンセット \( {n} \) に評価されます。</li>
<li>除算以外の算術演算子は演算子のデカルト積の各ペアに対して呼び出され、したがって \( X + Y \) は \( \{ x + y \mid x ∈ X, y ∈ Y \} \) に評価されます。</li>
<li>除算 \( X / Y \) は \( \{ x / y \mid x ∈ X, y ∈ Y, y ≠ 0\} \) に評価されます。つまり、\( Y \) の全ての \( 0 \) の値は省かれます。</li>
<li>選択 \( \mathrm{choose}(x, y) \) は \( \{ x, y \} \) に評価されます。</li>
</ul>
<p>たとえば、\( 1 + \mathrm{choose}(2, 5) \) は \( \{ 3, 6 \} \) に評価され、\(1 + 2 / 0 \) は \( \{\} \) に評価され、\( 90 / (\mathrm{choose}(-5, 5) + 5) \) は \( \{ 9 \} \) に評価されます。
真のセットの代わりにマルチセットを使用することは、要素の一意性のチェックを省略することでコードを単純化します。</p>
<p>非決定的な影響を表すモナドは、回答がない状況と、少なくとも1つの回答とそれ以外の全ての回答がある状況を表すことができなければなりません：</p>
<pre><code class="language-lean">inductive Many (α : Type) where
  | none : Many α
  | more : α → (Unit → Many α) → Many α
</code></pre>
<p>このデータ型は <code>List</code> と非常によく似ています。
違いは、<code>cons</code> がリストの残りを保存するところで、<code>more</code> が次の値を要求時に計算する関数を保存している点です。
これは <code>Many</code> の消費者が見つけた結果のいくつかを得た時点で探索を止めることができることを意味します。</p>
<p>単一の結果はこれ以上の結果を返さない <code>more</code> コンストラクタで表されます：</p>
<pre><code class="language-lean">def Many.one (x : α) : Many α := Many.more x (fun () =&gt; Many.none)
</code></pre>
<p>２つのマルチセットの結果のユニオンは、最初のマルチセットが空かどうかを調べることによって計算できます。
それが空の場合、２つ目のマルチセットがユニオンです。
それが空でない場合、ユニオンは最初のマルチセットの最初の要素に続いて最初のマルチセットの残りと２つ目のマルチセットのユニオンで構成されます：</p>
<pre><code class="language-lean">def Many.union : Many α → Many α → Many α
  | Many.none, ys =&gt; ys
  | Many.more x xs, ys =&gt; Many.more x (fun () =&gt; union (xs ()) ys)
</code></pre>
<p>開始する検索プロセスで値のリストがあると便利なことがあります。
<code>Many.fromList</code> はリストを結果のマルチセットに変換します：</p>
<pre><code class="language-lean">def Many.fromList : List α → Many α
  | [] =&gt; Many.none
  | x :: xs =&gt; Many.more x (fun () =&gt; fromList xs)
</code></pre>
<p>同様に、検索が指定された後に、いくつかの値または全ての値を抽出すると便利なことがあります：</p>
<pre><code class="language-lean">def Many.take : Nat → Many α → List α
  | 0, _ =&gt; []
  | _ + 1, Many.none =&gt; []
  | n + 1, Many.more x xs =&gt; x :: (xs ()).take n

def Many.takeAll : Many α → List α
  | Many.none =&gt; []
  | Many.more x xs =&gt; x :: (xs ()).takeAll
</code></pre>
<p><code>Monad Many</code> インスタンスには <code>bind</code> 演算子が必要です。
非決定的な検索で２つの操作を連続するには、最初のステップから全ての可能性を取り、それぞれに残りのプログラムを実行し、結果のユニオンを取ることが含まれます。
言い換えると、最初のステップが３つの可能な答えを返す場合、それぞれについて次のステップを試みる必要があります。
２つ目のステップは各入力に対していくつでも答えを返すことができるので、ユニオンを取ることは全探索空間を表します。</p>
<pre><code class="language-lean">def Many.bind : Many α → (α → Many β) → Many β
  | Many.none, _ =&gt;
    Many.none
  | Many.more x xs, f =&gt;
    (f x).union (bind (xs ()) f)
</code></pre>
<p><code>Many.one</code> と <code>Many.bind</code> はモナド契約を遵守します。
<code>Many.bind (Many.one v) f</code> が <code>f v</code> と同じであることを確認するために、式を可能な限り評価してみます：</p>
<pre><code class="language-lean">Many.bind (Many.one v) f
===&gt;
Many.bind (Many.more v (fun () =&gt; Many.none)) f
===&gt;
(f v).union (Many.bind Many.none f)
===&gt;
(f v).union Many.none
</code></pre>
<p>空のマルチセットは <code>union</code> の右のアイデンティティであり、答えは <code>f v</code> と等価です。すべての関数 <code>f</code> について、<code>fun x =&gt; f x</code> は <code>f</code> と同じなので、最初の部分の契約が満たされます。
<code>Reader.bind r Reader.pure</code> が <code>r</code> と同じであることをチェックするには、同様の技術が機能します：</p>
<pre><code class="language-lean">Reader.bind r Reader.pure
===&gt;
fun env =&gt; Reader.pure (r env) env
===&gt;
fun env =&gt; (fun _ =&gt; (r env)) env
===&gt;
fun env =&gt; r env
</code></pre>
<p>リーダアクション <code>r</code> 自体が関数であるため、これは <code>r</code> と同じです。
結合性をチェックするために、<code>Reader.bind (Reader.bind r f) g</code> と <code>Reader.bind r (fun x =&gt; Reader.bind (f x) g)</code> の両方に対して同じことを行います：</p>
<pre><code class="language-lean">Reader.bind (Reader.bind r f) g
===&gt;
fun env =&gt; g ((Reader.bind r f) env) env
===&gt;
fun env =&gt; g ((fun env' =&gt; f (r env') env') env) env
===&gt;
fun env =&gt; g (f (r env) env) env
</code></pre>
<pre><code class="language-lean">Reader.bind r (fun x =&gt; Reader.bind (f x) g)
===&gt;
Reader.bind r (fun x =&gt; fun env =&gt; g (f x env) env)
===&gt;
fun env =&gt; (fun x =&gt; fun env' =&gt; g (f x env') env') (r env) env
===&gt;
fun env =&gt; (fun env' =&gt; g (f (r env) env') env') env
===&gt;
fun env =&gt; g (f (r env) env) env
</code></pre>
<p>したがって、<code>Monad (Reader ρ)</code> インスタンスが正当化されています：</p>
<pre><code class="language-lean">instance : Monad (Reader ρ) where
  pure x := fun _ =&gt; x
  bind x f := fun env =&gt; f (x env) env
</code></pre>
<p>式評価器に渡されるカスタム環境は、ペアのリストとして表現できます：</p>
<pre><code class="language-lean">abbrev Env : Type := List (String × (Int → Int → Int))
</code></pre>
<p>例えば、<code>exampleEnv</code> には最大値と剰余の機能が含まれています：</p>
<pre><code class="language-lean">def exampleEnv : Env := [(&quot;max&quot;, max), (&quot;mod&quot;, (· % ·))]
</code></pre>
<p>Leanにはすでに <code>List.lookup</code> という関数があり、キーに対応する値をペアのリストから見つけるため、<code>applyPrimReader</code> は環境内にカスタム関数が存在するかどうかをチェックするだけで十分です。もし関数が見知らぬものであれば <code>0</code> を返します：</p>
<pre><code class="language-lean">def applyPrimReader (op : String) (x : Int) (y : Int) : Reader Env Int :=
  read &gt;&gt;= fun env =&gt;
  match env.lookup op with
  | none =&gt; pure 0
  | some f =&gt; pure (f x y)
</code></pre>
<p><code>evaluateM</code> を <code>applyPrimReader</code> と式を使って使用すると、環境を期待する関数の結果が得られます。
幸いにも、<code>exampleEnv</code> が使用できます：</p>
<pre><code class="language-lean">open Expr Prim in
#eval evaluateM applyPrimReader (prim (other &quot;max&quot;) (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv
</code></pre>
<pre><code class="language-output info">9
</code></pre>
<p><code>Many</code> のように、<code>Reader</code> はほとんどの言語でエンコードするのが困難な効果の一例ですが、型クラスとモナドを使うことで他のどんな効果と同じくらい便利になります。
Common Lisp、Clojure、Emacs Lispで見られる動的または特別な変数は、<code>Reader</code> のように使用できます。
同様に、SchemeやRacketのパラメータオブジェクトは、<code>Reader</code> に完全に対応している効果です。
Kotlinのコンテキストオブジェクトの慣用句は同様の問題を解決することができますが、それは自動的に関数引数を渡す手段であるため、この慣用句は言語の効果よりもリーダモナドとしてのエンコーディングに似ています。</p>
<h2 id="練習"><a class="header" href="#練習">練習</a></h2>
<h3 id="契約のチェック"><a class="header" href="#契約のチェック">契約のチェック</a></h3>
<p><code>State σ</code> と <code>Except ε</code> についてモナド契約をチェックしてください。</p>
<h3 id="失敗を伴うリーダー"><a class="header" href="#失敗を伴うリーダー">失敗を伴うリーダー</a></h3>
<p>リーダーモナドの例を適応させて、カスタムオペレータが定義されていない場合に失敗を示すことができるようにしてください。つまり、ゼロを単に返すのではなく、これらの定義を与えられた場合に：</p>
<pre><code class="language-lean">def ReaderOption (ρ : Type) (α : Type) : Type := ρ → Option α

def ReaderExcept (ε : Type) (ρ : Type) (α : Type) : Type := ρ → Except ε α
</code></pre>
<p>次のことを行います：</p>
<ol>
<li>適切な <code>pure</code> と <code>bind</code> 関数を書く</li>
<li>これらの関数が <code>Monad</code> 契約を満たすことを確認する</li>
<li><code>ReaderOption</code> と <code>ReaderExcept</code> のための <code>Monad</code> インスタンスを書く</li>
<li>適切な <code>applyPrim</code> 演算子を定義し、いくつかの例題の式に <code>evaluateM</code> でテストする</li>
</ol>
<h3 id="トレース評価器"><a class="header" href="#トレース評価器">トレース評価器</a></h3>
<p><code>WithLog</code> 型は、評価器と共に使用されることで、特定の操作のオプションのトレースを追加することができます。
特に、<code>ToTrace</code> 型は、与えられたオペレータをトレースする信号として機能することができます：</p>
<pre><code class="language-lean">inductive ToTrace (α : Type) : Type where
  | trace : α → ToTrace α
</code></pre>
<p>トレース評価器の場合、式は型 <code>Expr (Prim (ToTrace (Prim Empty)))</code> を持つべきです。これは、追跡されたそれぞれのバージョンと増やされた追加、減少、および乗算の表現内のオペレータであり、内部の引数が <code>Empty</code> は <code>trace</code> の中にそれ以上の特別なオペレータがないことを示すためです。</p>
<p>以下を行います：</p>
<ol>
<li><code>Monad (WithLog logged)</code> インスタンスを実装する</li>
<li>トレースされたオペレータをその引数に適用する <code>applyTraced</code> 関数を書き、型 <code>ToTrace (Prim Empty) → Int → Int → WithLog (Prim Empty × Int × Int) Int</code> で運用する</li>
</ol>
<p>この練習が正しく完了している場合、</p>
<pre><code class="language-lean">open Expr Prim ToTrace in
#eval evaluateM applyTraced (prim (other (trace times)) (prim (other (trace plus)) (const 1) (const 2)) (prim (other (trace minus)) (const 3) (const 4)))
</code></pre>
<p>は次の結果になります：</p>
<pre><code class="language-output info">{ log := [(Prim.plus, 1, 2), (Prim.minus, 3, 4), (Prim.times, 3, -1)], val := -3 }
</code></pre>
<p>ヒント：結果のログには <code>Prim Empty</code> の型の値が表示されることがあります。<code>#eval</code> の結果としてそれらを表示するためには、以下のインスタンスが必要です：</p>
<pre><code class="language-lean">deriving instance Repr for WithLog
deriving instance Repr for Empty
deriving instance Repr for Prim
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナド用do記法"><a class="header" href="#モナド用do記法">モナド用do記法</a></h1>
<p>APIがモナドに基づいていることは非常に強力ですが、匿名関数と共に<code>&gt;&gt;=</code>の明示的な使用はまだ少しわかりにくいものがあります。
<code>HAdd.hAdd</code>への明示的な呼び出しの代わりに中置演算子が使われるのと同様に、Leanには_<code>do</code>記法_と呼ばれるモナド用の構文があり、これによりモナドを使用するプログラムの読み書きが容易になります。
これは、<code>IO</code>プログラムを記述する際に使用される全く同じ<code>do</code>記法であり、<code>IO</code>もまたモナドです。</p>
<p><a href="monads/../hello-world.html">Hello, World!</a>では、<code>do</code>記法が<code>IO</code>アクションを組み合わせるために使用されていますが、これらのプログラムの意味は直接説明されています。
モナドを使ってプログラミングする方法を理解することは、<code>do</code>を基本的なモナド演算子の使用方法に基づいて説明することを意味しています。</p>
<p><code>do</code>の最初の翻訳は、<code>do</code>内の唯一の文が単一の式<code>E</code>である場合に使用されます。
このケースでは、<code>do</code>は取り除かれ、</p>
<pre><code class="language-lean">do E
</code></pre>
<p>は以下のように翻訳されます。</p>
<pre><code class="language-lean">E
</code></pre>
<p>2番目の翻訳は、<code>do</code>の最初の文が矢印を持つ<code>let</code>であり、ローカル変数を束縛する場合に使用されます。
これは、その同じ変数を束縛する関数と共に<code>&gt;&gt;=</code>の使用に翻訳されるので、</p>
<pre><code class="language-lean">do let x ← E1
   Stmt
   ...
   En
</code></pre>
<p>は以下のように翻訳されます。</p>
<pre><code class="language-lean">E1 &gt;&gt;= fun x =&gt;
do Stmt
   ...
   En
</code></pre>
<p><code>do</code>ブロックの最初の文が式である場合、それは<code>Unit</code>を返すモナドアクションと見なされ、そのため関数は<code>Unit</code>コンストラクタにマッチし、</p>
<pre><code class="language-lean">do E1
   Stmt
   ...
   En
</code></pre>
<p>は以下のように翻訳されます。</p>
<pre><code class="language-lean">E1 &gt;&gt;= fun () =&gt;
do Stmt
   ...
   En
</code></pre>
<p>最後に、<code>do</code>ブロックの最初の文が<code>:=</code>を使用する<code>let</code>である場合、翻訳された形式は通常の<code>let</code>式で、</p>
<pre><code class="language-lean">do let x := E1
   Stmt
   ...
   En
</code></pre>
<p>は以下のように翻訳されます。</p>
<pre><code class="language-lean">let x := E1
do Stmt
   ...
   En
</code></pre>
<p><code>Monad</code>クラスを使用して書かれた<code>firstThirdFifthSeventh</code>の定義は以下のようになります。</p>
<pre><code class="language-lean">def firstThirdFifthSeventh [Monad m] (lookup : List α → Nat → m α) (xs : List α) : m (α × α × α × α) :=
  lookup xs 0 &gt;&gt;= fun first =&gt;
  lookup xs 2 &gt;&gt;= fun third =&gt;
  lookup xs 4 &gt;&gt;= fun fifth =&gt;
  lookup xs 6 &gt;&gt;= fun seventh =&gt;
  pure (first, third, fifth, seventh)
</code></pre>
<p><code>do</code>記法を使用すると、それはかなり読みやすくなります：</p>
<pre><code class="language-lean">def firstThirdFifthSeventh [Monad m] (lookup : List α → Nat → m α) (xs : List α) : m (α × α × α × α) := do
  let first ← lookup xs 0
  let third ← lookup xs 2
  let fifth ← lookup xs 4
  let seventh ← lookup xs 6
  pure (first, third, fifth, seventh)
</code></pre>
<p><code>Monad</code>型クラスなしでは、木のノードに番号を付ける関数<code>number</code>が以下のように書かれました：</p>
<pre><code class="language-lean">def number (t : BinTree α) : BinTree (Nat × α) :=
  let rec helper : BinTree α → State Nat (BinTree (Nat × α))
    | BinTree.leaf =&gt; ok BinTree.leaf
    | BinTree.branch left x right =&gt;
      helper left ~~&gt; fun numberedLeft =&gt;
      get ~~&gt; fun n =&gt;
      set (n + 1) ~~&gt; fun () =&gt;
      helper right ~~&gt; fun numberedRight =&gt;
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t 0).snd
</code></pre>
<p><code>Monad</code>と<code>do</code>を使用すると、その定義はかなり煩わしさがなくなります：</p>
<pre><code class="language-lean">def number (t : BinTree α) : BinTree (Nat × α) :=
  let rec helper : BinTree α → State Nat (BinTree (Nat × α))
    | BinTree.leaf =&gt; pure BinTree.leaf
    | BinTree.branch left x right =&gt; do
      let numberedLeft ← helper left
      let n ← get
      set (n + 1)
      let numberedRight ← helper right
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t 0).snd
</code></pre>
<p><code>IO</code>での<code>do</code>のすべての便利さは、他のモナドで使う場合にも利用可能です。
例えば、ネストされたアクションはどんなモナドでも動作します。
<code>mapM</code>の元の定義は以下のようでした：</p>
<pre><code class="language-lean">def mapM [Monad m] (f : α → m β) : List α → m (List β)
  | [] =&gt; pure []
  | x :: xs =&gt;
    f x &gt;&gt;= fun hd =&gt;
    mapM f xs &gt;&gt;= fun tl =&gt;
    pure (hd :: tl)
</code></pre>
<p><code>do</code>記法を使うと、以下のように書くことができます：</p>
<pre><code class="language-lean">def mapM [Monad m] (f : α → m β) : List α → m (List β)
  | [] =&gt; pure []
  | x :: xs =&gt; do
    let hd ← f x
    let tl ← mapM f xs
    pure (hd :: tl)
</code></pre>
<p>ネストされたアクションを使用することで、それはオリジナルの非モナド<code>map</code>とほぼ同じ短さになります：</p>
<pre><code class="language-lean">def mapM [Monad m] (f : α → m β) : List α → m (List β)
  | [] =&gt; pure []
  | x :: xs =&gt; do
    pure ((← f x) :: (← mapM f xs))
</code></pre>
<p>ネストされたアクションを使って、<code>number</code>関数をより簡潔にすることができます：</p>
<pre><code class="language-lean">def increment : State Nat Nat := do
  let n ← get
  set (n + 1)
  pure n

def number (t : BinTree α) : BinTree (Nat × α) :=
  let rec helper : BinTree α → State Nat (BinTree (Nat × α))
    | BinTree.leaf =&gt; pure BinTree.leaf
    | BinTree.branch left x right =&gt; do
      pure (BinTree.branch (← helper left) ((← increment), x) (← helper right))
  (helper t 0).snd
</code></pre>
<h2 id="練習問題-7"><a class="header" href="#練習問題-7">練習問題</a></h2>
<ul>
<li><code>evaluateM</code>、そのヘルパー、および異なる特定の使用例を<code>&gt;&gt;=</code>を明示的に呼び出す代わりに<code>do</code>記法を使用して書き直してください。</li>
<li><code>firstThirdFifthSeventh</code>をネストされたアクションを使って書き直してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioモナド"><a class="header" href="#ioモナド">IOモナド</a></h1>
<p><code>IO</code>をモナドとして理解するには、<a href="monads/../hello-world/running-a-program.html">プログラムの実行</a>セクションで説明された二つの視点があります。これらはそれぞれ<code>pure</code>および<code>bind</code>の<code>IO</code>での意味を理解するのに役立ちます。</p>
<p>一つ目の視点では、<code>IO</code>アクションはLeanのランタイムシステムへの命令として理解できます。例えば、その命令は「このファイルディスクリプタから文字列を読み取り、その文字列を使って純粋なLeanコードを再実行する」といったものになるかもしれません。この視点は_外部的_なもので、オペレーティングシステムの視点からプログラムを見るものです。この場合、<code>pure</code>はRTSに何の効果も要請しない<code>IO</code>アクションであり、<code>bind</code>はRTSに潜在的に影響を及ぼす操作を最初に実行するよう指示し、その後で結果の値を使ってプログラムの残りの部分を呼び出します。</p>
<p>二つ目の視点では、<code>IO</code>アクションは世界全体を変換します。<code>IO</code>アクションは実際には純粋であり、唯一無二の世界を引数として受け取り、その変更された世界を返します。この視点は_内部的_なもので、Leanの内部での<code>IO</code>の表現に合っています。Lean内で世界はトークンとして表現され、<code>IO</code>モナドは各トークンが正確に一度だけ使用されるように構造化されています。</p>
<p>これがどのように機能するのかを見るためには、定義を一つずつ剥がしていくと役立ちます。<code>#print</code>コマンドは、Leanデータ型や定義の内部情報を明らかにします。たとえば、</p>
<pre><code class="language-lean">#print Nat
</code></pre>
<p>は以下の結果になります。</p>
<pre><code class="language-output info">inductive Nat : Type
number of parameters: 0
constructors:
Nat.zero : Nat
Nat.succ : Nat → Nat
</code></pre>
<p>また、</p>
<pre><code class="language-lean">#print Char.isAlpha
</code></pre>
<p>は以下の結果になります。</p>
<pre><code class="language-output info">def Char.isAlpha : Char → Bool :=
fun c =&gt; Char.isUpper c || Char.isLower c
</code></pre>
<p>時には、<code>#print</code>の出力には、まだこの本で紹介されていないLeanの機能が含まれています。例えば、</p>
<pre><code class="language-lean">#print List.isEmpty
</code></pre>
<p>は以下の出力を生成します。</p>
<pre><code class="language-output info">def List.isEmpty.{u} : {α : Type u} → List α → Bool :=
fun {α} x =&gt;
  match x with
  | [] =&gt; true
  | head :: tail =&gt; false
</code></pre>
<p>これには、定義名の後に<code>.{u}</code>が含まれ、型が単に<code>Type</code>ではなく<code>Type u</code>と注釈されています。これは今のところ無視して構いません。</p>
<p><code>IO</code>の定義をプリントすると、それがより単純な構造に基づいて定義されているのがわかります。</p>
<pre><code class="language-lean">#print IO
</code></pre>
<pre><code class="language-output info">@[reducible] def IO : Type → Type :=
EIO IO.Error
</code></pre>
<p><code>IO.Error</code>は、<code>IO</code>アクションによってスローされ得るすべてのエラーを表しています。</p>
<pre><code class="language-lean">#print IO.Error
</code></pre>
<pre><code class="language-output info">inductive IO.Error : Type
number of parameters: 0
constructors:
IO.Error.alreadyExists : Option String → UInt32 → String → IO.Error
IO.Error.otherError : UInt32 → String → IO.Error
IO.Error.resourceBusy : UInt32 → String → IO.Error
IO.Error.resourceVanished : UInt32 → String → IO.Error
IO.Error.unsupportedOperation : UInt32 → String → IO.Error
IO.Error.hardwareFault : UInt32 → String → IO.Error
IO.Error.unsatisfiedConstraints : UInt32 → String → IO.Error
IO.Error.illegalOperation : UInt32 → String → IO.Error
IO.Error.protocolError : UInt32 → String → IO.Error
IO.Error.timeExpired : UInt32 → String → IO.Error
IO.Error.interrupted : String → UInt32 → String → IO.Error
IO.Error.noFileOrDirectory : String → UInt32 → String → IO.Error
IO.Error.invalidArgument : Option String → UInt32 → String → IO.Error
IO.Error.permissionDenied : Option String → UInt32 → String → IO.Error
IO.Error.resourceExhausted : Option String → UInt32 → String → IO.Error
IO.Error.inappropriateType : Option String → UInt32 → String → IO.Error
IO.Error.noSuchThing : Option String → UInt32 → String → IO.Error
IO.Error.unexpectedEof : IO.Error
IO.Error.userError : String → IO.Error
</code></pre>
<p><code>EIO ε α</code>は、<code>ε</code>型のエラーで終了するか、または<code>α</code>型の値で成功する<code>IO</code>アクションを表します。これは、<code>Except ε</code>モナドと同様に、<code>IO</code>モナドにはエラーハンドリングと例外の定義能力が含まれていることを意味します。</p>
<p>さらに層を剥がすと、<code>EIO</code>自体がより単純な構造によって定義されています。</p>
<pre><code class="language-lean">#print EIO
</code></pre>
<pre><code class="language-output info">def EIO : Type → Type → Type :=
fun ε =&gt; EStateM ε IO.RealWorld
</code></pre>
<p><code>EStateM</code>モナドはエラーと状態の両方を含んでおり、<code>Except</code>と<code>State</code>の組み合わせです。それは別の型、<code>EStateM.Result</code>を使用して定義されます。</p>
<pre><code class="language-lean">#print EStateM
</code></pre>
<pre><code class="language-output info">def EStateM.{u} : Type u → Type u → Type u → Type u :=
fun ε σ α =&gt; σ → EStateM.Result ε σ α
</code></pre>
<p>つまり、<code>EStateM ε σ α</code>型のプログラムは、初期状態<code>σ</code>を受け取る関数であり、<code>EStateM.Result ε σ α</code>を返します。</p>
<p><code>EStateM.Result</code>は<code>Except</code>の定義に非常に似ており、成功した終了を示すコンストラクタとエラーを示すコンストラクタがあります。</p>
<pre><code class="language-lean">#print EStateM.Result
</code></pre>
<pre><code class="language-output info">inductive EStateM.Result.{u} : Type u → Type u → Type u → Type u
number of parameters: 3
constructors:
EStateM.Result.ok : {ε σ α : Type u} → α → σ → EStateM.Result ε σ α
EStateM.Result.error : {ε σ α : Type u} → ε → σ → EStateM.Result ε σ α
</code></pre>
<p><code>Except ε α</code>のように、<code>ok</code>コンストラクタは型<code>α</code>の結果を含み、<code>error</code>コンストラクタは型<code>ε</code>の例外を含みます。しかし<code>Except</code>と違って、どちらのコンストラクタも計算の最終状態を含む追加の状態フィールドがあります。</p>
<p><code>EStateM ε σ</code>の<code>Monad</code>インスタンスには<code>pure</code>と<code>bind</code>が必要です。<code>State</code>の場合と同様に、<code>EStateM</code>の<code>pure</code>の実装は初期状態を受け取り、それを変更せずに返します。そして、<code>Except</code>の場合と同様に、その引数を<code>ok</code>コンストラクタで返します：</p>
<pre><code class="language-lean">#print EStateM.pure
</code></pre>
<pre><code class="language-output info">protected def EStateM.pure.{u} : {ε σ α : Type u} → α → EStateM ε σ α :=
fun {ε σ α} a s =&gt; EStateM.Result.ok a s
</code></pre>
<p><code>protected</code>は、<code>EStateM</code>ネームスペースが開かれていても、完全な名前<code>EStateM.pure</code>が必要であることを意味します。</p>
<p>同様に、<code>EStateM</code>の<code>bind</code>も初期状態を引数として取ります。これは初期状態を最初のアクションに渡します。<code>Except</code>の<code>bind</code>のように、結果がエラーかどうかをチェックします。もしエラーだった場合、そのエラーは変更されずに返され、<code>bind</code>の二番目の引数は使用されません。成功した結果であれば、二番目の引数は返された値と生成された状態の両方に適用されます。</p>
<pre><code class="language-lean">#print EStateM.bind
</code></pre>
<pre><code class="language-output info">protected def EStateM.bind.{u} : {ε σ α β : Type u} → EStateM ε σ α → (α → EStateM ε σ β) → EStateM ε σ β :=
fun {ε σ α β} x f s =&gt;
  match x s with
  | EStateM.Result.ok a s =&gt; f a s
  | EStateM.Result.error e s =&gt; EStateM.Result.error e s
</code></pre>
<p>これらすべてをまとめると、<code>IO</code>は同時に状態とエラーを追跡するモナドです。利用可能なエラーのコレクションは、プログラムで発生する多くの問題を説明するコンストラクタを持つデータ型<code>IO.Error</code>によって与えられます。状態は現実の世界を表す型であり、<code>IO.RealWorld</code>と呼ばれます。各基本<code>IO</code>アクションはこの現実の世界を受け取り、エラーまたは結果とペアにされた別の世界を返します。<code>IO</code>では、<code>pure</code>は世界を変更せずに返し、<code>bind</code>は一つのアクションから変更された世界を次のアクションに渡します。</p>
<p>宇宙全体はコンピュータのメモリに収まらないので、渡されている世界はただの表現です。世界のトークンが再利用されない限り、この表現は安全です。つまり、世界のトークンには一切のデータを含む必要はありません：</p>
<pre><code class="language-lean">#print IO.RealWorld
</code></pre>
<pre><code class="language-output info">def IO.RealWorld : Type :=
Unit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追加の便利機能-2"><a class="header" href="#追加の便利機能-2">追加の便利機能</a></h1>
<h2 id="共有引数タイプ"><a class="header" href="#共有引数タイプ">共有引数タイプ</a></h2>
<p>同じタイプの複数の引数を取る関数を定義するとき、両方の引数を同じコロンの前に書くことができます。
たとえば、</p>
<pre><code class="language-lean">def equal? [BEq α] (x : α) (y : α) : Option α :=
  if x == y then
    some x
  else
    none
</code></pre>
<p>は以下のように書くことができます。</p>
<pre><code class="language-lean">def equal? [BEq α] (x y : α) : Option α :=
  if x == y then
    some x
  else
    none
</code></pre>
<p>これは、特に型のシグネチャが大きい場合に便利です。</p>
<h2 id="先頭ドット記法"><a class="header" href="#先頭ドット記法">先頭ドット記法</a></h2>
<p>帰納型のコンストラクタは名前空間に含まれます。
これにより、関連する複数の帰納型が同じコンストラクタ名を使用することができますが、プログラムが冗長になる可能性があります。
帰納型が既に分かっているコンテキストでは、コンストラクタの名前の先頭にドットを置くことで名前空間を省略でき、Leanは期待される型を使ってコンストラクタ名を解決します。
たとえば、二分木を反転する関数は次のように書かれます：</p>
<pre><code class="language-lean">def BinTree.mirror : BinTree α → BinTree α
  | BinTree.leaf =&gt; BinTree.leaf
  | BinTree.branch l x r =&gt; BinTree.branch (mirror r) x (mirror l)
</code></pre>
<p>名前空間を省略することで、大幅に短くすることができますが、Leanコンパイラを含まないコードレビューツールのようなコンテキストでは、プログラムの可読性が低下するコストがあります。</p>
<pre><code class="language-lean">def BinTree.mirror : BinTree α → BinTree α
  | .leaf =&gt; .leaf
  | .branch l x r =&gt; .branch (mirror r) x (mirror l)
</code></pre>
<p>期待される表現型を使って名前空間を曖昧にすることは、コンストラクタ以外の名前にも適用されます。
もし <code>BinTree.empty</code> が <code>BinTree</code> を生成する別の方法として定義されていれば、ドット記法でも使用することができます：</p>
<pre><code class="language-lean">def BinTree.empty : BinTree α := .leaf

#check (.empty : BinTree Nat)
</code></pre>
<pre><code class="language-output info">BinTree.empty : BinTree Nat
</code></pre>
<h2 id="オアパターン"><a class="header" href="#オアパターン">オア・パターン</a></h2>
<p>複数のパターンを許すコンテキスト、例えば <code>match</code> 式では、複数のパターンが結果の表現を共有することがあります。
週の日を表すデータ型 <code>Weekday</code> があります：</p>
<pre><code class="language-lean">inductive Weekday where
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday
  deriving Repr
</code></pre>
<p>パターンマッチングを使用して、ある日が週末かどうかを確認できます：</p>
<pre><code class="language-lean">def Weekday.isWeekend (day : Weekday) : Bool :=
  match day with
  | Weekday.saturday =&gt; true
  | Weekday.sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>これは、コンストラクタのドット記法を使うことですでに単純化することができます：</p>
<pre><code class="language-lean">def Weekday.isWeekend (day : Weekday) : Bool :=
  match day with
  | .saturday =&gt; true
  | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>両方の週末パターンが同じ結果の表現（<code>true</code>）を持っているので、一つに凝縮することができます：</p>
<pre><code class="language-lean">def Weekday.isWeekend (day : Weekday) : Bool :=
  match day with
  | .saturday | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>これは、引数が名前付けされていないバージョンにさらに簡略化することができます：</p>
<pre><code class="language-lean">def Weekday.isWeekend : Weekday → Bool
  | .saturday | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>シーンの背後では、結果の表現が各パターンに単純に複製されます。
これは、パターンが変数をバインドすることができることを意味し、次の例では、同じタイプの値を含む和型から <code>inl</code> と <code>inr</code> コンストラクタを除去しています：</p>
<pre><code class="language-lean">def condense : α ⊕ α → α
  | .inl x | .inr x =&gt; x
</code></pre>
<p>結果の表現が複製されるため、パターンによってバインドされる変数が同じタイプである必要はありません。
複数のタイプで機能するオーバーロードされた関数は、異なるタイプの変数をバインドするパターンに対して単一の結果表現を書くために使用されるかもしれません：</p>
<pre><code class="language-lean">def stringy : Nat ⊕ Weekday → String
  | .inl x | .inr x =&gt; s!&quot;It is {repr x}&quot;
</code></pre>
<p>実際には、結果の表現において参照されるのは、全てのパターンで共有される変数のみです。なぜなら結果は各パターンに対して意味をなす必要があるからです。
<code>getTheNat</code> では、<code>n</code> のみがアクセス可能であり、<code>x</code> や <code>y</code> のいずれかを使用しようとする試みはエラーにつながります。</p>
<pre><code class="language-lean">def getTheNat : (Nat × α) ⊕ (Nat × β) → Nat
  | .inl (n, x) | .inr (n, y) =&gt; n
</code></pre>
<p>同様の定義で <code>x</code> にアクセスしようとすると、第二のパターンでは <code>x</code> が利用できないためエラーが発生します：</p>
<pre><code class="language-lean">def getTheAlpha : (Nat × α) ⊕ (Nat × α) → α
  | .inl (n, x) | .inr (n, y) =&gt; x
</code></pre>
<pre><code class="language-output error">unknown identifier 'x'
</code></pre>
<p>結果の表現がパターンマッチの各分岐に実質的にコピー＆ペーストされるという事実は、いくつかの驚くべき振る舞いにつながる可能性があります。
例えば、以下の定義は受け入れられますが、<code>inr</code> バージョンの結果の表現は <code>str</code> のグローバル定義を参照します：</p>
<pre><code class="language-lean">def str := &quot;Some string&quot;

def getTheString : (Nat × String) ⊕ (Nat × β) → String
  | .inl (n, str) | .inr (n, y) =&gt; str
</code></pre>
<p>この関数を両方のコンストラクタで呼び出すことで、混乱する振る舞いが明らかになります。
最初のケースでは、Leanにどのタイプの <code>β</code> であるべきかを伝えるためにタイプ注釈が必要です：</p>
<pre><code class="language-lean">#eval getTheString (.inl (20, &quot;twenty&quot;) : (Nat × String) ⊕ (Nat × String))
</code></pre>
<pre><code class="language-output info">&quot;twenty&quot;
</code></pre>
<p>二つ目のケースでは、グローバル定義が使用されます：</p>
<pre><code class="language-lean">#eval getTheString (.inr (20, &quot;twenty&quot;))
</code></pre>
<pre><code class="language-output info">&quot;Some string&quot;
</code></pre>
<p>オア・パターンを使用すると、<code>Weekday.isWeekend</code> のように、いくつかの定義を大幅に簡単にし、その明確さを増すことができます。
しかし、複数のタイプの変数や解離した変数のセットが関係しているときは特に、混乱する振る舞いの可能性があるため、それらを使用する際には注意することが賢明です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要-1"><a class="header" href="#概要-1">概要</a></h1>
<h2 id="副作用のエンコーディング"><a class="header" href="#副作用のエンコーディング">副作用のエンコーディング</a></h2>
<p>Leanは純粋な関数型言語です。
これは、変更可能な変数、ログ出力、例外などの副作用を含まないことを意味します。
しかしながら、ほとんどの副作用は、関数と帰納型または構造体を組み合わせて_エンコード_することができます。
例えば、変更可能な状態は初期状態から最終状態と結果のペアへの関数としてエンコードされ、例外は成功した終了とエラーのためのコンストラクタを持つ帰納型としてエンコードできます。</p>
<p>エンコードされた副作用のそれぞれの集合は型です。
その結果、プログラムがこれらのエンコードされた副作用を使用する場合、これはその型に明らかになります。
関数型プログラミングとは、プログラムが副作用を使用できないという意味ではなく、単に使用する副作用について<em>正直である</em>ことが求められます。
Leanの型シグネチャは、関数が期待する引数の型と返す結果の型だけでなく、使用する可能性のある副作用も記述します。</p>
<h2 id="モナド型クラス-1"><a class="header" href="#モナド型クラス-1">モナド型クラス</a></h2>
<p>どこでも副作用を許容する言語で、純粋な関数型プログラムを書くことは可能です。
たとえば、<code>2 + 3</code>は全く副作用のない有効なPythonプログラムです。
同様に、副作用を持つプログラムを組み合わせる場合、副作用が発生する順序を指定する方法が必要です。
結局のところ、変数を変更する前後で例外が投げられるかどうかは重要です。</p>
<p>型クラス<code>Monad</code>は、これら二つの重要な特性を捉えます。
それには二つのメソッドがあります：<code>pure</code>は副作用のないプログラムを表し、<code>bind</code>は副作用を持つプログラムを順序づけます。
<code>Monad</code>のインスタンスに対する契約は、<code>bind</code>と<code>pure</code>が純粋な計算と順序づけを実際に捉えることを保証します。</p>
<h2 id="モナド用のdo表記"><a class="header" href="#モナド用のdo表記">モナド用の<code>do</code>表記</a></h2>
<p><code>do</code>表記は<code>IO</code>に限定されることなく、どんなモナドに対しても動作します。
これにより、モナドを使用するプログラムは、一連のステートメントの後に他のステートメントが続く、文指向言語を思わせるスタイルで書くことができます。
さらに、<code>do</code>表記は、入れ子になったアクションなどの多くの便利な省略形を可能にします。
<code>do</code>で書かれたプログラムは、裏で<code>&gt;&gt;=</code>の適用に変換されます。</p>
<h2 id="カスタムモナド"><a class="header" href="#カスタムモナド">カスタムモナド</a></h2>
<p>異なる言語は異なるセットの副作用を提供します。
ほとんどの言語は変更可能な変数とファイルのI/Oを特徴としていますが、全てが例外のような機能を持っているわけではありません。
他の言語は、Iconの検索ベースのプログラム実行、SchemeやRubyの継続、そしてCommon Lispの再開可能な例外のような、珍しいまたは固有の効果を提供します。
モナドを使って副作用をエンコードする利点は、プログラムが言語によって提供される効果のセットに制限されないことです。
Leanは、任意のモナドでのプログラミングを便利にするように設計されているため、プログラマーは任意のアプリケーションに意味のある副作用のセットを自由に選択することができます。</p>
<h2 id="ioモナド-1"><a class="header" href="#ioモナド-1"><code>IO</code>モナド</a></h2>
<p>実世界に影響を与えることのできるプログラムはLeanで<code>IO</code>アクションとして記述されます。
<code>IO</code>は多くのモナドの中のひとつです。
<code>IO</code>モナドは状態と例外をエンコードし、状態は世界の状態を追跡するために、例外は失敗と回復をモデリングするために使用されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ファンクターアプリカティブファンクターモナド"><a class="header" href="#ファンクターアプリカティブファンクターモナド">ファンクター、アプリカティブファンクター、モナド</a></h1>
<p><code>Functor</code>や<code>Monad</code>は、型の引数がまだ適用されていない型に対する操作を記述します。
これらを理解する一つの方法は、<code>Functor</code>をデータを変換できるコンテナとして、<code>Monad</code>を副作用を伴うプログラムのコーディング手法として捉えることです。
しかしながら、この理解は完全ではありません。
結局のところ、<code>Option</code>は<code>Functor</code>と<code>Monad</code>の両方のインスタンスを持ち、また、任意の値や計算が失敗して値を返さない可能性を表しています。</p>
<p>データ構造としてみた場合、<code>Option</code>はnull許容型や多くて一つのエントリを持つリストに似ています。
制御構造の観点から見ると、<code>Option</code>は結果が出ないまま早期終了する可能性のある計算を表していると言えます。
通常、<code>Functor</code>インスタンスを使うプログラムでは、<code>Option</code>をデータ構造として見る方が簡単です。一方で、<code>Monad</code>インスタンスを使うプログラムでは、早期に失敗する可能性を許容するために<code>Option</code>を使っていると考えることが簡単ですが、関数型プログラミングを習得する上で、これら両方の視点を自在に切り替える能力は非常に重要です。</p>
<p>ファンクターやモナドの間には、もっと深い関係があります。
一つの結論として、<em>すべてのモナドはファンクターでもあります</em>。
これを別の言い方をすると、モナドの抽象化はファンクターの抽象化よりも強力だということになります。なぜなら、すべてのファンクターがモナドというわけではないからです。
さらに、「アプリカティブファンクター」と呼ばれるもう一つの中間抽象化があります。これは、多くの興味深いプログラムを書くのに十分な強さを持ちつつ、<code>Monad</code>インターフェイスが使えないライブラリに対しても使用が許されます。
型クラス<code>Applicative</code>は、アプリカティブファンクターのオーバーロード可能な操作を提供しています。
すべてのモナドはアプリカティブファンクターであり、すべてのアプリカティブファンクターはファンクターですが、逆は成り立ちません。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="構造と継承"><a class="header" href="#構造と継承">構造と継承</a></h1>
<p><code>Functor</code>、<code>Applicative</code>、そして <code>Monad</code> の完全な定義を理解するために、Lean の別の機能が必要です：構造体継承です。
構造体継承を使用すると、一つの構造体タイプが、追加のフィールドとともに、別のもののインターフェースを提供することができます。
これは、明白な分類関係を持つ概念をモデル化する際に役立ちます。
例えば、神話上の生き物のモデルを考えてみましょう。
その中には大きなものも小さなものもいます：</p>
<pre><code class="language-lean">structure MythicalCreature where
  large : Bool
deriving Repr
</code></pre>
<p>背後では、<code>MythicalCreature</code> 構造体の定義によって、<code>mk</code> と呼ばれる単一のコンストラクターを持つ帰納型が作成されます：</p>
<pre><code class="language-lean">#check MythicalCreature.mk
</code></pre>
<pre><code class="language-output info">MythicalCreature.mk (large : Bool) : MythicalCreature
</code></pre>
<p>同様に、実際にコンストラクターからフィールドを取り出す <code>MythicalCreature.large</code> 関数が作成されます：</p>
<pre><code class="language-lean">#check MythicalCreature.large
</code></pre>
<pre><code class="language-output info">MythicalCreature.large (self : MythicalCreature) : Bool
</code></pre>
<p>ほとんどの古い物語では、どんなモンスターでも何かしらの方法で倒すことができます。
モンスターの説明には、それが大きいかどうかと共に、この情報を含める必要があります：</p>
<pre><code class="language-lean">structure Monster extends MythicalCreature where
  vulnerability : String
deriving Repr
</code></pre>
<p>見出しの <code>extends MythicalCreature</code> は、すべてのモンスターもまた神話上の生き物であることを示しています。
<code>Monster</code> を定義するためには、<code>MythicalCreature</code> および <code>Monster</code> からのフィールドを両方提供する必要があります。
トロールは、日光に弱い大きなモンスターです：</p>
<pre><code class="language-lean">def troll : Monster where
  large := true
  vulnerability := &quot;sunlight&quot;
</code></pre>
<p>内部では、継承はコンポジションを使用して実装されます。
コンストラクター <code>Monster.mk</code> は <code>MythicalCreature</code> を引数として取ります：</p>
<pre><code class="language-lean">#check Monster.mk
</code></pre>
<pre><code class="language-output info">Monster.mk (toMythicalCreature : MythicalCreature) (vulnerability : String) : Monster
</code></pre>
<p>各新しいフィールドの値を抽出する関数を定義する他に、<code>Monster.toMythicalCreature</code> という型の関数 <code>Monster → MythicalCreature</code> が定義されます。
これは、基になる生き物を抽出するために使用できます。</p>
<p>Lean での継承階層の移動は、オブジェクト指向言語におけるアップキャストと同じものではありません。
アップキャスト演算子は、派生クラスの値を親クラスのインスタンスとして扱うものですが、値はそのアイデンティティと構造を保持します。
しかし、Lean では、継承階層を上に移動することが、実際には基になる情報を消去することを意味します。
このことは、<code>troll.toMythicalCreature</code> を評価した結果を考慮することで明らかになります：</p>
<pre><code class="language-lean">#eval troll.toMythicalCreature
</code></pre>
<pre><code class="language-output info">{ large := true }
</code></pre>
<p><code>MythicalCreature</code> のフィールドのみが残ります。</p>
<p><code>where</code> 構文と同様に、構造体継承でもフィールド名を伴う波括弧記法が機能します：</p>
<pre><code class="language-lean">def troll : Monster := {large := true, vulnerability := &quot;sunlight&quot;}
</code></pre>
<p>しかし、基になるコンストラクターに委譲する匿名の山括弧記法は、内部の詳細を明らかにします：</p>
<pre><code class="language-lean">def troll : Monster := ⟨true, &quot;sunlight&quot;⟩
</code></pre>
<pre><code class="language-output error">application type mismatch
  Monster.mk true
argument
  true
has type
  Bool : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<p>必要なのは追加の1組の山括弧であり、これにより <code>true</code> に <code>MythicalCreature.mk</code> が呼び出されます：</p>
<pre><code class="language-lean">def troll : Monster := ⟨⟨true⟩, &quot;sunlight&quot;⟩
</code></pre>
<p>Leanのドット記法は継承を考慮に入れることができます。
つまり、既存の <code>MythicalCreature.large</code> を <code>Monster</code> で使用でき、Lean は自動的に <code>Monster.toMythicalCreature</code> を <code>MythicalCreature.large</code> 呼び出しの前に挿入します。
しかしこれは、ドット記法を使用している場合のみ発生し、フィールドルックアップ関数を通常の関数呼び出し構文を使用して適用すると、型エラーになります：</p>
<pre><code class="language-lean">#eval MythicalCreature.large troll
</code></pre>
<pre><code class="language-output error">application type mismatch
  troll.large
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<p>ユーザー定義の関数に対しても、ドット記法は小さな生き物、それは大きくないものを指します：</p>
<pre><code class="language-lean">def MythicalCreature.small (c : MythicalCreature) : Bool := !c.large
</code></pre>
<p><code>troll.small</code> を評価すると <code>false</code> が出力され、<code>MythicalCreature.small troll</code> を評価しようとすると以下のような結果になります：</p>
<pre><code class="language-output error">application type mismatch
  MythicalCreature.small troll
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アプリカティブ関手"><a class="header" href="#アプリカティブ関手">アプリカティブ関手</a></h1>
<p><em>適用ファンクター</em> とは、<code>pure</code> および <code>seq</code> という2つの追加の操作を利用可能にするファンクターです。
<code>pure</code> は <code>Monad</code> で使われる同じ演算子です。なぜなら <code>Monad</code> は実際には <code>Applicative</code> から継承されているからです。
<code>seq</code> は <code>map</code> によく似ています：それは関数を使用してデータ型の内容を変換することを可能にします。
しかし、<code>seq</code> を使うときは、関数自体がデータ型の中に含まれます：<code>f (α → β) → (Unit → f α) → f β</code>。
型 <code>f</code> の下に関数を配置することで、<code>Applicative</code> のインスタンスは関数がどのように適用されるかを制御することができますが、<code>Functor.map</code> は無条件で関数を適用します。
二番目の引数は、関数が決して適用されない場合に <code>seq</code> の定義を短絡させるために <code>Unit →</code> で始まる型を持っています。</p>
<p>この短絡動作の価値は <code>Applicative Option</code> のインスタンスで確認できます：</p>
<pre><code class="language-lean">instance : Applicative Option where
  pure x := .some x
  seq f x :=
    match f with
    | none =&gt; none
    | some g =&gt; g &lt;$&gt; x ()
</code></pre>
<p>この場合、<code>seq</code> が適用する関数がなければ、その引数を計算する必要はなく、したがって <code>x</code> は決して呼び出されません。
同じ考慮が <code>Except</code> の <code>Applicative</code> インスタンスにも影響しています：</p>
<pre><code class="language-lean">instance : Applicative (Except ε) where
  pure x := .ok x
  seq f x :=
    match f with
    | .error e =&gt; .error e
    | .ok g =&gt; g &lt;$&gt; x ()
</code></pre>
<p>この短絡動作は、関数そのものではなく、関数を <em>取り囲む</em> <code>Option</code> もしくは <code>Except</code> の構造にのみ依存します。</p>
<p>モナドは、純粋な関数型言語において、順番に実行されるステートメントの概念を捉える方法として見ることができます。
あるステートメントの結果は、どのステートメントが続けて実行されるかに影響を与えます。
これは <code>bind</code> の型で見ることができます：<code>m α → (α → m β) → m β</code>。
最初のステートメントの結果の値は、次に実行するステートメントを計算する関数への入力です。
<code>bind</code> の連続した使用は、命令的プログラミング言語におけるステートメントのシーケンスのようなものであり、<code>bind</code> は条件分岐やループのような制御構造を実装するのに十分な力を持っています。</p>
<p>このアナロジーに従って、<code>Applicative</code> は副作用を持つ言語における関数適用を捉えます。
Kotlin や C# のような言語において、関数への引数は左から右に評価されます。
先の引数によって実行される副作用は、後になされる引数によって実行される副作用よりも前に起こります。
しかし、関数は引数の特定の <em>値</em> に依存するカスタムの短絡演算子を実装するのに十分な力はありません。</p>
<p>一般的に、<code>seq</code> は直接呼び出されません。
代わりに <code>&lt;*&gt;</code> 演算子が使用されます。
この演算子はその第二引数を <code>fun () =&gt; ...</code> でラップして、呼び出し元を簡素化します。
言い換えると、<code>E1 &lt;*&gt; E2</code> は <code>Seq.seq E1 (fun () =&gt; E2)</code> の糖衣構文です。</p>
<p><code>seq</code> を複数の引数で使用できる主な特長は、Lean の多引数関数が実際には、残りの引数を待つ別の関数を返す単一引数関数であるということです。
言い換えれば、もし <code>seq</code> の最初の引数が複数の引数を待っていれば、<code>seq</code> の結果は残りを待つことになります。
例えば、<code>some Plus.plus</code> には <code>Option (Nat → Nat → Nat)</code> の型を持つことができます。
一つの引数を提供すると、<code>some Plus.plus &lt;*&gt; some 4</code> は <code>Option (Nat → Nat)</code> の型になります。
これは <code>seq</code> と共に使用できるため、<code>some Plus.plus &lt;*&gt; some 4 &lt;*&gt; some 7</code> には <code>Option Nat</code> の型があります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アプリカティブ契約"><a class="header" href="#アプリカティブ契約">アプリカティブ契約</a></h1>
<p><code>Functor</code>、<code>Monad</code>、<code>BEq</code> や <code>Hashable</code> を実装する型と同様に、<code>Applicative</code> もすべてのインスタンスが従うべき一連の規則を持っています。</p>
<p>アプリカティブファンクターが従うべきルールは以下の四つです:</p>
<ol>
<li>結合律を尊重し、<code>pure id &lt;*&gt; v = v</code> であるべきです。</li>
<li>関数の合成を尊重し、<code>pure (· ∘ ·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code> であるべきです。</li>
<li>純粋な操作のシーケンスは、ノーオペレーション（no-op）になるべきなので、<code>pure f &lt;*&gt; pure x = pure (f x)</code> です。</li>
<li>純粋な操作の順序は関係なく、<code>u &lt;*&gt; pure x = pure (fun f =&gt; f x) &lt;*&gt; u</code> であるべきです。</li>
</ol>
<p>これらを <code>Applicative Option</code> インスタンスについてチェックするには、<code>pure</code>を<code>s​​ome</code>に展開することから始めます。</p>
<p>最初のルールは、<code>some id &lt;*&gt; v = v</code>です。
<code>Option</code>の<code>seq</code>の定義によると、これは<code>id &lt;$&gt; v = v</code>と同じであり、これはすでに確認された<code>Functor</code>の規則の1つです。</p>
<p>二番目のルールは、<code>some (· ∘ ·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code>です。
<code>u</code>、<code>v</code>、または<code>w</code>のいずれかが<code>none</code>の場合、両方の側が<code>none</code>になりますので、特性が保持されます。
<code>u</code>が<code>some f</code>であり、<code>v</code>が<code>some g</code>であり、<code>w</code>が<code>some x</code>であると仮定すると、これは<code>some (· ∘ ·) &lt;*&gt; some f &lt;*&gt; some g &lt;*&gt; some x = some f &lt;*&gt; (some g &lt;*&gt; some x)</code>ということになります。
両側を評価すると同じ結果が得られます：</p>
<pre><code class="language-lean">some (· ∘ ·) &lt;*&gt; some f &lt;*&gt; some g &lt;*&gt; some x
===&gt;
some (f ∘ ·) &lt;*&gt; some g &lt;*&gt; some x
===&gt;
some (f ∘ g) &lt;*&gt; some x
===&gt;
some ((f ∘ g) x)
===&gt;
some (f (g x))

some f &lt;*&gt; (some g &lt;*&gt; some x)
===&gt;
some f &lt;*&gt; (some (g x))
===&gt;
some (f (g x))
</code></pre>
<p>三番目のルールは、<code>seq</code>の定義から直接導かれます：</p>
<pre><code class="language-lean">some f &lt;*&gt; some x
===&gt;
f &lt;$&gt; some x
===&gt;
some (f x)
</code></pre>
<p>四番目のケースでは、<code>u</code>が<code>some f</code>であると仮定します。なぜならそれが<code>none</code>の場合、方程式の両側は<code>none</code>になるからです。
<code>some f &lt;*&gt; some x</code>は直接<code>some (f x)</code>に評価され、<code>some (fun g =&gt; g x) &lt;*&gt; some f</code>もそうなります。</p>
<h2 id="すべてのアプリカティブはファンクターです"><a class="header" href="#すべてのアプリカティブはファンクターです">すべてのアプリカティブはファンクターです</a></h2>
<p><code>Applicative</code>の二つのオペレーターは、<code>map</code>を定義するのに十分です：</p>
<pre><code class="language-lean">def map [Applicative f] (g : α → β) (x : f α) : f β :=
  pure g &lt;*&gt; x
</code></pre>
<p>しかしながら、これが<code>Functor</code>を実装することに使うことは、<code>Applicative</code>の契約が<code>Functor</code>の契約を保証する場合に限られます。
<code>Functor</code>の最初のルールは、<code>id &lt;$&gt; x = x</code>であり、これは<code>Applicative</code>の最初のルールから直接導かれます。
<code>Functor</code>の二番目のルールは、<code>map (f ∘ g) x = map f (map g x)</code>です。
ここで<code>map</code>の定義を展開すると、<code>pure (f ∘ g) &lt;*&gt; x = pure f &lt;*&gt; (pure g &lt;*&gt; x)</code>になります。
純粋な操作のシーケンスがノーオペレーションであるという規則を使って、左側を<code>pure (· ∘ ·) &lt;*&gt; pure f &lt;*&gt; pure g &lt;*&gt; x</code>に書き換えることができます。
これはアプリカティブファンクターが関数の合成を尊重するという規則の一例です。</p>
<p>これは、<code>Applicative</code>が<code>Functor</code>を拡張している定義を正当化し、<code>pure</code>と<code>seq</code>を使って<code>map</code>のデフォルト定義を提供します：</p>
<pre><code class="language-lean">class Applicative (f : Type → Type) extends Functor f where
  pure : α → f α
  seq : f (α → β) → (Unit → f α) → f β
  map g x := seq (pure g) (fun () =&gt; x)
</code></pre>
<h2 id="すべてのモナドはアプリカティブファンクターです"><a class="header" href="#すべてのモナドはアプリカティブファンクターです">すべてのモナドはアプリカティブファンクターです</a></h2>
<p><code>Monad</code>のインスタンスは既に<code>pure</code>の実装を必要としています。
これと<code>bind</code>と一緒に、<code>seq</code>を定義するのに十分です：</p>
<pre><code class="language-lean">def seq [Monad m] (f : m (α → β)) (x : Unit → m α) : m β := do
  let g ← f
  let y ← x ()
  pure (g y)
</code></pre>
<p>もう一度、<code>Monad</code>の契約が<code>Applicative</code>の契約を含意していることをチェックすれば、これを<code>Applicative</code>を拡張する<code>Monad</code>に対する<code>seq</code>のデフォルト定義として使うことができます。</p>
<p>この部分の残りは、<code>bind</code>に基づいて<code>seq</code>を実装するこの定義が実際に<code>Applicative</code>の契約を満たしているという主張で構成されています。
関数プログラミングの素晴らしいことの一つは、この種の主張を<a href="functor-applicative-monad/../getting-to-know/evaluating.html">式の評価に関する最初のセクション</a>からの評価ルールを使って、紙と鉛筆で解き出すことができるということです。
これらの引数を読む際に操作の意味を考えると、理解に役立つことがあります。</p>
<p><code>do</code>記法を明示的な<code>&gt;&gt;=</code>の使用に置き換えると、<code>Monad</code>のルールを適用しやすくなります：</p>
<pre><code class="language-lean">def seq [Monad m] (f : m (α → β)) (x : Unit → m α) : m β := do
  f &gt;&gt;= fun g =&gt;
  x () &gt;&gt;= fun y =&gt;
  pure (g y)
</code></pre>
<p>結合律を尊重しているかをチェックするには、<code>seq (pure id) (fun () =&gt; v) = v</code>であることを確認します。
左側は<code>pure id &gt;&gt;= fun g =&gt; (fun () =&gt; v) () &gt;&gt;= fun y =&gt; pure (g y)</code>に相当します。
中央の単位関数はすぐに削除でき、<code>pure id &gt;&gt;= fun g =&gt; v &gt;&gt;= fun y =&gt; pure (g y)</code>になります。
<code>pure</code>が<code>&gt;&gt;=</code>の左単位元であるという事実を使用すると、これは<code>v &gt;&gt;= fun y =&gt; pure (id y)</code>、つまり<code>v &gt;&gt;= fun y =&gt; pure y</code>と同じです。
<code>fun x =&gt; f x</code>が<code>f</code>と同じなので、これは<code>v &gt;&gt;= pure</code>と同じであり、<code>pure</code>が<code>&gt;&gt;=</code>の右単位元であるという事実を使用して<code>v</code>となります。</p>
<p>この種の非公式な推論は、少しのフォーマッティングでより読みやすくすることができます。
以下のチャートでは、「EXPR1 ={ REASON }= EXPR2」を「EXPR1はREASONのためEXPR2と同じ」と読みます：</p>
<div class="equational">
<div class="term">
<pre><code class="language-lean hljs">pure id >>= fun g => v >>= fun y => pure (g y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">v >>= fun y => pure (id y)</code></pre>
</div>
<div class="explanation">
={ <em>Reduce the call to <code class="hljs">id</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">v >>= fun y => pure y</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">fun x => f x</code> is the same as <code class="hljs">f</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">v >>= pure</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a right identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">v</code></pre>
</div>
</div>
<p>それが関数の合成を尊重しているかをチェックするには、「<code>pure (· ∘ ·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code>」であることを確認します。
最初のステップは<code>&lt;*&gt;</code>をこの定義の<code>seq</code>で置き換えることです。
その後、<code>Monad</code>の契約から恒等性と結合性のルールを使用した（やや長い）一連のステップで一方から他方への十分な取得です：</p>
<div class="equational">
<div class="term">
<pre><code class="language-lean hljs">seq (seq (seq (pure (· ∘ ·)) (fun _ => u))
      (fun _ => v))
  (fun _ => w)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">((pure (· ∘ ·) >>= fun f =>
   u >>= fun x =>
   pure (f x)) >>= fun g =>
  v >>= fun y =>
  pure (g y)) >>= fun h =>
 w >>= fun z =>
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">((u >>= fun x =>
   pure (x ∘ ·)) >>= fun g =>
   v >>= fun y =>
  pure (g y)) >>= fun h =>
 w >>= fun z =>
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Insertion of parentheses for clarity</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">((u >>= fun x =>
   pure (x ∘ ·)) >>= (fun g =>
   v >>= fun y =>
  pure (g y))) >>= fun h =>
 w >>= fun z =>
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">(u >>= fun x =>
  pure (x ∘ ·) >>= fun g =>
 v  >>= fun y => pure (g y)) >>= fun h =>
 w >>= fun z =>
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">(u >>= fun x =>
  v >>= fun y =>
  pure (x ∘ y)) >>= fun h =>
 w >>= fun z =>
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
v >>= fun y =>
pure (x ∘ y) >>= fun h =>
w >>= fun z =>
pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
v >>= fun y =>
w >>= fun z =>
pure ((x ∘ y) z)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of function composition</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
v >>= fun y =>
w >>= fun z =>
pure (x (y z))</code></pre>
</div>
<div class="explanation">
={ <em>Time to start moving backwards!<code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
v >>= fun y =>
w >>= fun z =>
pure (y z) >>= fun q =>
pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
v >>= fun y =>
 (w >>= fun p =>
  pure (y p)) >>= fun q =>
 pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
 (v >>= fun y =>
  w >>= fun q =>
  pure (y q)) >>= fun z =>
 pure (x z)</code></pre>
</div>
<div class="explanation">
={ <em>This includes the definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun x =>
seq v (fun () => w) >>= fun q =>
pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>This also includes the definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">seq u (fun () => seq v (fun () => w))</code></pre>
</div>
</div>
<p>純粋な操作のシーケンスがノーオペレーションであることをチェックするには：</p>
<div class="equational">
<div class="term">
<pre><code class="language-lean hljs">seq (pure f) (fun () => pure x)</code></pre>
</div>
<div class="explanation">
={ <em>Replacing <code class="hljs">seq</code> with its definition</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">pure f >>= fun g =>
pure x >>= fun y =>
pure (g y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">pure f >>= fun g =>
pure (g x)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">pure (f x)</code></pre>
</div>
</div>
<p>最後に、純粋な操作の順序が関係ないことをチェックするには：</p>
<div class="equational">
<div class="term">
<pre><code class="language-lean hljs">seq u (fun () => pure x)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun f =>
pure x >>= fun y =>
pure (f y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun f =>
pure (f x)</code></pre>
</div>
<div class="explanation">
={ <em>Clever replacement of one expression by an equivalent one that makes the rule match</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">u >>= fun f =>
pure ((fun g => g x) f)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">>>=</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">pure (fun g => g x) >>= fun h =>
u >>= fun f =>
pure (h f)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">seq (pure (fun f => f x)) (fun () => u)</code></pre>
</div>
</div>
<p>これにより、<code>Applicative</code>を拡張する<code>Monad</code>の定義が正当化され、<code>seq</code>のデフォルト定義が提供されます：</p>
<pre><code class="language-lean">class Monad (m : Type → Type) extends Applicative m where
  bind : m α → (α → m β) → m β
  seq f x :=
    bind f fun g =&gt;
    bind (x ()) fun y =&gt;
    pure (g y)
</code></pre>
<p><code>Applicative</code>自身の<code>map</code>のデフォルト定義により、すべての<code>Monad</code>インスタンスは自動的に<code>Applicative</code>と<code>Functor</code>のインスタンスも生成します。</p>
<h2 id="追加の定義"><a class="header" href="#追加の定義">追加の定義</a></h2>
<p>各型クラスに関連する個々の契約に準拠することに加えて、<code>Functor</code>、<code>Applicative</code>、および<code>Monad</code>の組み合わせ実装は、これらのデフォルト実装に相当するように動作するべきです。
言い換えれば、<code>Applicative</code>と<code>Monad</code>の両方のインスタンスを提供する型は、バージョンが<code>Monad</code>インスタンスがデフォルト実装として生成するバージョンとは異なる動作をする<code>seq</code>の実装を持つべきではありません。
これは重要です。なぜなら、多相関数は<code>&gt;&gt;=</code>の使用を<code>&lt;*&gt;</code>の同等の使用に置き換える、あるいは<code>&lt;*&gt;</code>の使用を<code>&gt;&gt;=</code>の同等の使用に置き換えるためにリファクタリングされるかもしれないからです。
このリファクタリングは、このコードを使用するプログラムの意味を変更するべきではありません。</p>
<p>このルールは、<code>Validate.andThen</code>を<code>Monad</code>インスタンスで<code>bind</code>を実装するために使用すべきではない理由を説明しています。
それ自体はモナド契約に従います。
ただし、それを<code>seq</code>の実装に使用した場合、動作は<code>seq</code>自体と同等ではありません。
どこが異なるかを見るために、両方がエラーを返す二つの計算の例を取ります。
関数を検証する際に二つのエラーが返されるべきケースの例を出発点としてください（これは関数への以前の引数から得られたものと同様になるかもしれません）、および引数を検証する際のエラーです：</p>
<pre><code class="language-lean">def notFun : Validate String (Nat → String) :=
  .errors { head := &quot;First error&quot;, tail := [] }

def notArg : Validate String Nat :=
  .errors { head := &quot;Second error&quot;, tail := [] }
</code></pre>
<p><code>Validate</code>の<code>Applicative</code>インスタンスからの<code>&lt;*&gt;</code>のバージョンでそれらを組み合わせると、ユーザーに両方のエラーが報告されます：</p>
<pre><code class="language-lean">notFun &lt;*&gt; notArg
===&gt;
match notFun with
| .ok g =&gt; g &lt;$&gt; notArg
| .errors errs =&gt;
  match notArg with
  | .ok _ =&gt; .errors errs
  | .errors errs' =&gt; .errors (errs ++ errs')
===&gt;
match notArg with
| .ok _ =&gt; .errors { head := &quot;First error&quot;, tail := [] }
| .errors errs' =&gt; .errors ({ head := &quot;First error&quot;, tail := [] } ++ errs')
===&gt;
.errors ({ head := &quot;First error&quot;, tail := [] } ++ { head := &quot;Second error&quot;, tail := []})
===&gt;
.errors { head := &quot;First error&quot;, tail := [&quot;Second error&quot;]}
</code></pre>
<p><code>&gt;&gt;=</code>に書き換えられた<code>seq</code>のバージョンを使って実装され、ここでは<code>andThen</code>に書き換えられたバージョンを使うと、最初のエラーのみが利用可能になります：</p>
<pre><code class="language-lean">seq notFun (fun () =&gt; notArg)
===&gt;
notFun.andThen fun g =&gt;
notArg.andThen fun y =&gt;
pure (g y)
===&gt;
match notFun with
| .errors errs =&gt; .errors errs
| .ok val =&gt;
  (fun g =&gt;
    notArg.andThen fun y =&gt;
    pure (g y)) val
===&gt;
.errors { head := &quot;First error&quot;, tail := [] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代替案"><a class="header" href="#代替案">代替案</a></h1>
<h2 id="失敗からの回復"><a class="header" href="#失敗からの回復">失敗からの回復</a></h2>
<p><code>Validate</code>は、入力が受け入れられる方法が複数ある状況でも使用できます。
入力フォーム<code>RawInput</code>に対して、レガシーシステムからの慣習を実装したビジネスルールの別のセットは以下の通りです：</p>
<ol>
<li>すべての人間のユーザーは、4桁の生年を提供しなければなりません。</li>
<li>1970年以前に生まれたユーザーは、不完全な旧記録のため、名前を提供する必要はありません。</li>
<li>1970年以降に生まれたユーザーは、名前を提供しなければなりません。</li>
<li>企業は、出生年として<code>&quot;FIRM&quot;</code>を入力し、企業名を提供する必要があります。</li>
</ol>
<p>1970年に生まれたユーザーについては特に規定がなされていません。
彼らには、諦めるか、出生年を偽るか、または電話をかけることが期待されています。
会社はこれをビジネスを行う上での許容可能なコストと考えています。</p>
<p>以下の帰納的型は、これらの規則から生成される値を捉えます：</p>
<pre><code class="language-lean">abbrev NonEmptyString := {s : String // s ≠ &quot;&quot;}

inductive LegacyCheckedInput where
  | humanBefore1970 :
    (birthYear : {y : Nat // y &gt; 999 ∧ y &lt; 1970}) →
    String →
    LegacyCheckedInput
  | humanAfter1970 :
    (birthYear : {y : Nat // y &gt; 1970}) →
    NonEmptyString →
    LegacyCheckedInput
  | company :
    NonEmptyString →
    LegacyCheckedInput
deriving Repr
</code></pre>
<p>しかし、これらのルールのバリデータはより複雑であり、３つのケースすべてに対処しなければなりません。
それは一連のネストした<code>if</code>式として書くこともできますが、３つのケースを独立して設計し、その後に統合する方が簡単です。
これには、エラーメッセージを保持しながら、失敗からの回復が可能な手段が必要です：</p>
<pre><code class="language-lean">def Validate.orElse (a : Validate ε α) (b : Unit → Validate ε α) : Validate ε α :=
  match a with
  | .ok x =&gt; .ok x
  | .errors errs1 =&gt;
    match b () with
    | .ok x =&gt; .ok x
    | .errors errs2 =&gt; .errors (errs1 ++ errs2)
</code></pre>
<p>この失敗からの回復パターンは十分に一般的であり、Leanにはそれ用の組み込み構文があります。これは<code>OrElse</code>という型クラスに付随しています：</p>
<pre><code class="language-lean">class OrElse (α : Type) where
  orElse : α → (Unit → α) → α
</code></pre>
<p>式<code>E1 &lt;|&gt; E2</code>は<code>OrElse.orElse E1 (fun () =&gt; E2)</code>の略です。
<code>Validate</code>の<code>OrElse</code>インスタンスにより、この構文をエラー回復に使用することができます：</p>
<pre><code class="language-lean">instance : OrElse (Validate ε α) where
  orElse := Validate.orElse
</code></pre>
<p><code>LegacyCheckedInput</code>のバリデータは、各コンストラクタのバリデータから構築することができます。
企業のルールは、出生年は文字列<code>&quot;FIRM&quot;</code>でなければならず、名前は非空でなければなりません。
しかし、コンストラクタ<code>LegacyCheckedInput.company</code>には出生年の表現がまったくないため、<code>&lt;*&gt;</code>を使ってこれを実行する簡単な方法はありません。
重要なのは、その引数を無視する関数を<code>&lt;*&gt;</code>と一緒に使用することです。</p>
<p>型にこの事実を何も記録せずに真偽条件が成り立つことを確認するには、<code>checkThat</code>を使用できます：</p>
<pre><code class="language-lean">def checkThat (condition : Bool) (field : Field) (msg : String) : Validate (Field × String) Unit :=
  if condition then pure () else reportError field msg
</code></pre>
<p>この<code>checkCompany</code>の定義は<code>checkThat</code>を使用して、その結果の<code>Unit</code>値を廃棄します：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  pure (fun () name =&gt; .company name) &lt;*&gt;
    checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; &lt;*&gt;
    checkName input.name
</code></pre>
<p>しかしながら、この定義はかなり雑音が多いです。
２つの方法で簡略化できます。
最初の方法は、最初の<code>&lt;*&gt;</code>を使う代わりに、最初の引数によって返される値を自動的に無視する特殊バージョンである<code>*&gt;</code>を使用することです。
この演算子もまた、<code>SeqRight</code>という型クラスによって制御されており、<code>E1 *&gt; E2</code>は<code>SeqRight.seqRight E1 (fun () =&gt; E2)</code>の糖衣構文です：</p>
<pre><code class="language-lean">class SeqRight (f : Type → Type) where
  seqRight : f α → (Unit → f β) → f β
</code></pre>
<p><code>seqRight</code>のデフォルト実装は<code>seq</code>の観点からです：<code>seqRight (a : f α) (b : Unit → f β) : f β := pure (fun _ x =&gt; x) &lt;*&gt; a &lt;*&gt; b ()</code>。</p>
<p><code>seqRight</code>を使用すると、<code>checkCompany</code>はよりシンプルになります：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; *&gt;
  pure .company &lt;*&gt; checkName input.name
</code></pre>
<p>さらに簡略化することが可能です。
すべての<code>Applicative</code>において、<code>pure F &lt;*&gt; E</code>は<code>f &lt;$&gt; E</code>と等価です。
言い換えれば、<code>pure</code>を使って<code>Applicative</code>型に置かれた関数を適用するために<code>seq</code>を使用することは過剰であり、その関数は<code>Functor.map</code>を使って適用できたはずです。
この簡略化により：</p>
<pre><code class="language-lean">def checkCompany (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkThat (input.birthYear == &quot;FIRM&quot;) &quot;birth year&quot; &quot;FIRM if a company&quot; *&gt;
  .company &lt;$&gt; checkName input.name
</code></pre>
<p><code>LegacyCheckedInput</code>の残りの２つのコンストラクタは、そのフィールドにサブタイプを使用しています。
サブタイプをチェックするための汎用ツールは、これらを読みやすくするでしょう：</p>
<pre><code class="language-lean">def checkSubtype {α : Type} (v : α) (p : α → Prop) [Decidable (p v)] (err : ε) : Validate ε {x : α // p x} :=
  if h : p v then
    pure ⟨v, h⟩
  else
    .errors { head := err, tail := [] }
</code></pre>
<p>関数の引数リストでは、型クラス<code>[Decidable (p v)]</code>が引数<code>v</code>と<code>p</code>の指定の後で発生することが重要です。
さもなければ、これは手動で提供された値ではなく、追加の一連の自動的な暗黙の引数を指すことになるでしょう。
<code>Decidable</code>インスタンスは、<code>if</code>を使用して命題<code>p v</code>をチェックすることを可能にするものです。</p>
<p>２つの人間のケースは追加のツールを必要としません：</p>
<pre><code class="language-lean">def checkHumanBefore1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =&gt;
    .humanBefore1970 &lt;$&gt;
      checkSubtype y (fun x =&gt; x &gt; 999 ∧ x &lt; 1970) (&quot;birth year&quot;, &quot;less than 1970&quot;) &lt;*&gt;
      pure input.name

def checkHumanAfter1970 (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen fun y =&gt;
    .humanAfter1970 &lt;$&gt;
      checkSubtype y (· &gt; 1970) (&quot;birth year&quot;, &quot;greater than 1970&quot;) &lt;*&gt;
      checkName input.name
</code></pre>
<p>３つのケースのバリデータは<code>&lt;|&gt;</code>を使用して組み合わせることができます：</p>
<pre><code class="language-lean">def checkLegacyInput (input : RawInput) : Validate (Field × String) LegacyCheckedInput :=
  checkCompany input &lt;|&gt; checkHumanBefore1970 input &lt;|&gt; checkHumanAfter1970 input
</code></pre>
<p>成功したケースは予想通り<code>LegacyCheckedInput</code>のコンストラクタを返します：</p>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;Johnny's Troll Groomers&quot;, &quot;FIRM&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.company &quot;Johnny's Troll Groomers&quot;)
</code></pre>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;Johnny&quot;, &quot;1963&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 &quot;Johnny&quot;)
</code></pre>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;&quot;, &quot;1963&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 &quot;&quot;)
</code></pre>
<p>最悪の入力はすべての失敗を返します：</p>
<pre><code class="language-lean">#eval checkLegacyInput ⟨&quot;&quot;, &quot;1970&quot;⟩
</code></pre>
<pre><code class="language-output info">Validate.errors
  { head := (&quot;birth year&quot;, &quot;FIRM if a company&quot;),
    tail := [(&quot;name&quot;, &quot;Required&quot;),
             (&quot;birth year&quot;, &quot;less than 1970&quot;),
             (&quot;birth year&quot;, &quot;greater than 1970&quot;),
             (&quot;name&quot;, &quot;Required&quot;)] }
</code></pre>
<h2 id="alternative-クラス"><a class="header" href="#alternative-クラス"><code>Alternative</code> クラス</a></h2>
<p>多くの型は、失敗と回復の概念をサポートしています。
<a href="functor-applicative-monad/../monads/arithmetic.html#nondeterministic-search">さまざまなモナドで算術表現を評価する</a>セクションの<code>Many</code>モナドはこのような型の一つですし、<code>Option</code>もそうです。
両方とも失敗をサポートしていますが、理由を提供することなく（例えば<code>Except</code>や<code>Validate</code>のように、何が間違っているかの何らかの指示が必要です）。</p>
<p><code>Alternative</code>クラスは、失敗と回復のための追加の演算子を持つ適用関数型子を記述します：</p>
<pre><code class="language-lean">class Alternative (f : Type → Type) extends Applicative f where
  failure : f α
  orElse : f α → (Unit → f α) → f α
</code></pre>
<p><code>Add α</code>の実装者が自動的に<code>HAdd α α α</code>インスタンスを得るのと同様に、<code>Alternative</code>の実装者は<code>OrElse</code>インスタンスを無料で取得します：</p>
<pre><code class="language-lean">instance [Alternative f] : OrElse (f α) where
  orElse := Alternative.orElse
</code></pre>
<p><code>Option</code>の<code>Alternative</code>の実装は、最初のnone-<code>none</code>引数を保持します：</p>
<pre><code class="language-lean">instance : Alternative Option where
  failure := none
  orElse
    | some x, _ =&gt; some x
    | none, y =&gt; y ()
</code></pre>
<p>同様に、<code>Many</code>の実装は<code>Many.union</code>の一般的な構造に従いますが、怠惰を誘発する<code>Unit</code>パラメータの配置が異なるために若干の違いがあります：</p>
<pre><code class="language-lean">def Many.orElse : Many α → (Unit → Many α) → Many α
  | .none, ys =&gt; ys ()
  | .more x xs, ys =&gt; .more x (fun () =&gt; orElse (xs ()) ys)

instance : Alternative Many where
  failure := .none
  orElse := Many.orElse
</code></pre>
<p>他の型クラスと同様に、<code>Alternative</code>は<code>Alternative</code>を実装する任意の適用関数型子に対して動作するさまざまな操作の定義を可能にします。
最も重要なのは、否定的な命題が偽であるときに<code>failure</code>を引き起こす<code>guard</code>です：</p>
<pre><code class="language-lean">def guard [Alternative f] (p : Prop) [Decidable p] : f Unit :=
  if p then
    pure ()
  else failure
</code></pre>
<p>これはモナドプログラムで実行を早期に終了させるために非常に有効です。
<code>Many</code>では、自然数のすべての偶数の除数を計算する以下のプログラムで、検索の全枝をフィルタリングするために使用できます：</p>
<pre><code class="language-lean">def Many.countdown : Nat → Many Nat
  | 0 =&gt; .none
  | n + 1 =&gt; .more n (fun () =&gt; countdown n)

def evenDivisors (n : Nat) : Many Nat := do
  let k ← Many.countdown (n + 1)
  guard (k % 2 = 0)
  guard (n % k = 0)
  pure k
</code></pre>
<p><code>20</code>で実行すると予想される結果が得られます：</p>
<pre><code class="language-lean">#eval (evenDivisors 20).takeAll
</code></pre>
<pre><code class="language-output info">[20, 10, 4, 2]
</code></pre>
<h2 id="練習問題-8"><a class="header" href="#練習問題-8">練習問題</a></h2>
<h3 id="バリデーションの親しみやすさの向上"><a class="header" href="#バリデーションの親しみやすさの向上">バリデーションの親しみやすさの向上</a></h3>
<p><code>&lt;|&gt;</code>を使用する<code>Validate</code>プログラムから返されるエラーは、リストに含まれるエラーは単に_いくつかの_コードパスを通じて到達可能であることを意味するため、読むのが難しいことがあります。
より構造化されたエラーレポートを使用することで、ユーザーをより正確にガイドすることができます：</p>
<ul>
<li><code>Validate.error</code>の<code>NonEmptyList</code>を素の型変数に置き換え、そして<code>Applicative (Validate ε)</code>および<code>OrElse (Validate ε α)</code>インスタンスの定義を更新して、<code>Append ε</code>インスタンスが利用可能であるだけを要求します。</li>
<li><code>Validate.mapErrors : Validate ε α → (ε → ε') → Validate ε' α</code>という関数を定義し、検証実行中のすべてのエラーを変換します。</li>
<li>エラーを代表するデータ型<code>TreeError</code>を使い、３つの代替案を通じたパスを追跡するようにレガシーバリデーションシステムを書き換えます。</li>
<li><code>report : TreeError → String</code>という関数を書き、<code>TreeError</code>の蓄積された警告とエラーのユーザーフレンドリーなビューを出力します。</li>
</ul>
<pre><code class="language-lean">inductive TreeError where
  | field : Field → String → TreeError
  | path : String → TreeError → TreeError
  | both : TreeError → TreeError → TreeError

instance : Append TreeError where
  append := .both
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宇宙-universes"><a class="header" href="#宇宙-universes">宇宙 (Universes)</a></h1>
<p>簡単のため、この本はここまでLeanの重要な特徴である_宇宙_ (universes) を省略してきました。
宇宙とは、他の型を分類する型です。
<code>Type</code> と <code>Prop</code> の2つは馴染み深いでしょう。
<code>Type</code> は <code>Nat</code>、<code>String</code>、<code>Int → String × Char</code>、<code>IO Unit</code> のような通常の型を分類します。
<code>Prop</code> は <code>&quot;nisse&quot; = &quot;elf&quot;</code> や <code>3 &gt; 2</code> のような真か偽かの命題を分類します。
<code>Prop</code> の型は <code>Type</code> です:</p>
<pre><code class="language-lean">#check Prop
</code></pre>
<pre><code class="language-output info">Prop : Type
</code></pre>
<p>技術的な理由から、これら2つよりも多くの宇宙が必要です。
特に、<code>Type</code>自体は<code>Type</code>にはなり得ません。
これを許すと論理的パラドックスが構築され、Leanの定理証明者としての有用性が損なわれることになります。</p>
<p>このための公式な議論は <em>ジラールのパラドックス</em> (Girard's Paradox) として知られています。
これはセット理論の初期バージョンが矛盾していたことを示すために使用された、よりよく知られているパラドックスである <em>ラッセルのパラドックス</em> (Russell's Paradox) に関連しています。
これらのセット理論では、セットはプロパティによって定義することができます。
たとえば、全ての赤いもののセット、全ての果物のセット、全ての自然数のセット、または全てのセットのセットなどです。
セットが与えられたら、特定の要素がそれに含まれているかどうかを尋ねることができます。
例えば、青い鳥は全ての赤いもののセットには含まれませんが、全ての赤いもののセットは全てのセットのセットに含まれます。
事実、全てのセットのセットはそれ自体をも含んでいます。</p>
<p>では、自己を含まない全てのセットのセットはどうでしょうか？
それは全ての赤いもののセットを含んでいます。なぜならそのセットは赤くはありません。
しかし、全てのセットのセットは含んでいません。なぜならそれ自体を含んでいるからです。
しかし、そのセットは自分自身を含んでいるのでしょうか？
もし含んでいるならば、それ自体を含むことはできません。
しかし含んでいないのならば、それを含むべきです。</p>
<p>これは矛盾であり、初期の前提に何か間違いがあったことを示しています。
特に、任意のプロパティを提供してセットを構築することを許すのは強力さが過ぎます。
後のバージョンのセット理論はパラドックスを取り除くためにセットの形成を制限しています。</p>
<p>依存型理論のバージョンで<code>Type</code>に<code>Type</code>という型を割り当てると同様のパラドックスが構築されます。
Leanが一貫した論理的基盤を持ち、数学のためのツールとして利用できるようにするためには、<code>Type</code>には別の型が必要です。
この型は<code>Type 1</code>と呼ばれます:</p>
<pre><code class="language-lean">#check Type
</code></pre>
<pre><code class="language-output info">Type : Type 1
</code></pre>
<p>同様に、<code>Type 1</code>は<code>Type 2</code>であり、
<code>Type 2</code>は<code>Type 3</code>であり、
<code>Type 3</code>は<code>Type 4</code>です、など。</p>
<p>関数型は両方の引数型と戻り値型を含むことのできる最小の宇宙に配置されます。
これは<code>Nat → Nat</code>が<code>Type</code>であり、<code>Type → Type</code>が<code>Type 1</code>であり、<code>Type 1 → Type 2</code>が<code>Type 3</code>であることを意味します。</p>
<p>このルールには一つの例外があります。
関数の戻り値型が<code>Prop</code>の場合、その関数型全体は<code>Prop</code>になります。たとえ引数がより大きな宇宙である<code>Type</code>や<code>Type 1</code>にあったとしてもです。
特に、これは通常の値に対する述語が<code>Prop</code>にあることを意味します。
例えば、型<code>(n : Nat) → n = n + 0</code>は<code>Nat</code>からそれが自分自身プラスゼロと等しい証拠への関数を表しています。
<code>Nat</code>は<code>Type</code>にありますが、この関数型はこのルールにより<code>Prop</code>にあります。
同様に、<code>Type</code>は<code>Type 1</code>にありますが、関数型<code>Type → 2 + 2 = 4</code>は<code>Prop</code>にあります。</p>
<h2 id="ユーザー定義型"><a class="header" href="#ユーザー定義型">ユーザー定義型</a></h2>
<p>構造や帰納的データ型は特定の宇宙に属するように宣言することができます。
Leanはそれぞれのデータ型が十分に大きな宇宙にあり、自身の型を含むことを防ぐことによってパラドックスを避けるかをチェックします。
例えば、次の宣言では<code>MyList</code>が<code>Type</code>に居住すると宣言されており、その型引数<code>α</code>もそうです:</p>
<pre><code class="language-lean">inductive MyList (α : Type) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<p><code>MyList</code>自体は<code>Type → Type</code>です。
これは実際の型を含むことに使われることができないことを意味します、なぜならその引数が<code>Type</code>になり、それは<code>Type 1</code>だからです:</p>
<pre><code class="language-lean">def myListOfNat : MyList Type :=
  .cons Nat .nil
</code></pre>
<pre><code class="language-output error">application type mismatch
  MyList Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<p><code>MyList</code>を更新して、その引数が<code>Type 1</code>である結果はLeanによって拒絶される定義です:</p>
<pre><code class="language-lean">inductive MyList (α : Type 1) : Type where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<pre><code class="language-output error">invalid universe level in constructor 'MyList.cons', parameter has type
  α
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>このエラーは<code>cons</code>の引数となる型<code>α</code>が<code>MyList</code>より大きな宇宙のものだから発生します。
<code>MyList</code>自身を<code>Type 1</code>に配置することでこの問題が解決しますが、<code>Type</code>が期待されるコンテキストでの<code>MyList</code>の利用が不便になるという代償があります。</p>
<p>データ型が許可されるかどうかを決める具体的なルールはやや複雑です。
一般的には、最大の引数と同じ宇宙からそのデータ型を始めるのが最も簡単です。
そして、もしその定義がLeanに拒絶されたら、そのレベルを1つ上に上げることが普通は通ります。</p>
<h2 id="宇宙多相性-universe-polymorphism"><a class="header" href="#宇宙多相性-universe-polymorphism">宇宙多相性 (Universe Polymorphism)</a></h2>
<p>特定の宇宙内でデータ型を定義すると、コードが重複する場合があります。
<code>MyList</code>を<code>Type → Type</code>内で配置することは、実際の型のリストに使用できないことを意味します。
それを<code>Type 1 → Type 1</code>に配置すると、型のリストのリストには使用できません。
<code>Type</code>、<code>Type 1</code>、<code>Type 2</code>などにバージョンをコピー＆ペーストする代わりに、任意のこれらの宇宙でインスタンス化できる単一の定義を書くために宇宙多相性という機能を使用することができます。</p>
<p>通常の多相型は定義で型を表す変数を使用します。
これによりLeanは変数を異なる方法で埋めることができ、これらの定義がいろいろな型で使用されることを可能にします。
同様に、宇宙多相性によって、変数が定義の宇宙を表すことを可能にし、それらが多様な宇宙で使用されることを可能にします。
型引数が一般的にギリシャ文字で命名されるのと同じように、宇宙引数は慣習的に<code>u</code>、<code>v</code>、<code>w</code>で命名されます。</p>
<p>この<code>MyList</code>の定義は特定の宇宙レベルを指定せず、代わりに任意のレベルを表す変数<code>u</code>を使用しています。
生成されたデータ型が<code>Type</code>で使われる場合<code>u</code>は<code>0</code>であり、<code>Type 3</code>で使用される場合<code>u</code>は<code>3</code>です:</p>
<pre><code class="language-lean">inductive MyList (α : Type u) : Type u where
  | nil : MyList α
  | cons : α → MyList α → MyList α
</code></pre>
<p>この定義により、自然数自体と自然数型自体の両方を含む<code>MyList</code>の同じ定義を使用することができます:</p>
<pre><code class="language-lean">def myListOfNumbers : MyList Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList Type :=
  .cons Nat .nil
</code></pre>
<p>それ自身を含むことさえできます:</p>
<pre><code class="language-lean">def myListOfList : MyList (Type → Type) :=
  .cons MyList .nil
</code></pre>
<p>これにより論理的パラドックスを書くことが可能になるかのように思われるかもしれません。
結局のところ、宇宙システムの全体的な目的は自己参照型を排除することです。
しかし裏では、<code>MyList</code>の各出現に宇宙レベル引数が提供されます。
本質的に、宇宙多相性の<code>MyList</code>の定義は各レベルでのデータ型の_コピー_を作り、レベル引数は使用するコピーを選ぶためにあります。
これらのレベル引数はドットと中括弧で書かれるので、<code>MyList.{0} : Type → Type</code>、<code>MyList.{1} : Type 1 → Type 1</code>、<code>MyList.{2} : Type 2 → Type 2</code>です。</p>
<p>レベルを明示的に書くと、前の例は以下のようになります:</p>
<pre><code class="language-lean">def myListOfNumbers : MyList.{0} Nat :=
  .cons 0 (.cons 1 .nil)

def myListOfNat : MyList.{1} Type :=
  .cons Nat .nil

def myListOfList : MyList.{1} (Type → Type) :=
  .cons MyList.{0} .nil
</code></pre>
<p>宇宙多相性の定義が複数の型を引数として取る場合、それぞれの引数にそれぞれのレベル変数を与えることが最大の柔軟性のために良い考えです。
たとえば、単一のレベル引数を持つ<code>Sum</code>のバージョンは次のように書かれます:</p>
<pre><code class="language-lean">inductive Sum (α : Type u) (β : Type u) : Type u where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>この定義は複数のレベルで使用できます:</p>
<pre><code class="language-lean">def stringOrNat : Sum String Nat := .inl &quot;hello&quot;

def typeOrType : Sum Type Type := .inr Nat
</code></pre>
<p>ただし、両方の引数が同じ宇宙にある必要があります:</p>
<pre><code class="language-lean">def stringOrType : Sum String Type := .inr Nat
</code></pre>
<pre><code class="language-output error">application type mismatch
  Sum String Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<p>このデータ型は2つの型引数の宇宙レベルに異なる変数を使用し、その結果のデータ型が2つの中で最大の宇宙にあることを宣言することでより柔軟にできます:</p>
<pre><code class="language-lean">inductive Sum (α : Type u) (β : Type v) : Type (max u v) where
  | inl : α → Sum α β
  | inr : β → Sum α β
</code></pre>
<p>これにより<code>Sum</code>は異なる宇宙からの引数で使用できます:</p>
<pre><code class="language-lean">def stringOrType : Sum String Type := .inr Nat
</code></pre>
<p>Leanが宇宙レベルを期待する位置では、次のどれかが使用できます:</p>
<ul>
<li>具体的なレベル、例えば<code>0</code>や<code>1</code></li>
<li>レベルを表す変数、例えば<code>u</code>や<code>v</code></li>
<li>2つのレベルの最大値、<code>max</code>がレベルに適用される形</li>
<li>レベルの増加、<code>+ 1</code>と書かれる形</li>
</ul>
<h3 id="宇宙多相性定義の書き方"><a class="header" href="#宇宙多相性定義の書き方">宇宙多相性定義の書き方</a></h3>
<p>これまでのこの本で定義されているデータ型は、データの最小宇宙である<code>Type</code>にあります。
Lean標準ライブラリから多相型、例えば<code>List</code>や<code>Sum</code>を紹介する際、この本はそれらの非宇宙多相性バージョンを作成しました。
実際のバージョンは宇宙多相性を使用して型レベルおよび非型レベルプログラム間でのコードの再利用を可能にします。</p>
<p>宇宙多相性型を書く際にはいくつか一般的な指針に従うと良いでしょう。
まず、独立した型引数は異なる宇宙変数を持つべきで、これにより多相性の定義がより多様な引数で使用されることを可能にし、コード再利用の可能性を高めます。
次に、全体の型自体は通常、全ての宇宙変数の最大値か、この最大値よりも1つ大きい値になります。最初に小さい方を試してみてください。
最後に、できるだけ小さい宇宙で新しい型を定義することで、他の文脈での使用が柔軟になります。
非多相型、例えば<code>Nat</code>や<code>String</code>などは直接<code>Type 0</code>に配置します。</p>
<h3 id="propと多相性"><a class="header" href="#propと多相性"><code>Prop</code>と多相性</a></h3>
<p><code>Type</code>、<code>Type 1</code>などがプログラムやデータを分類する型を記述するのと同じように、<code>Prop</code>は論理的な命題を分類します。
<code>Prop</code>の型は、ステートメントの真実性に対する説得力のある証拠が何であるかを記述します。
命題は多くの面で通常の型と似ています：帰納的に宣言でき、コンストラクタがあり、関数が命題を引数として取ることができます。
しかし、データ型と異なり、ステートメントの真実性に対する証拠が提供されることは通常重要であるものの、証拠が_どのようなものであるか_は通常は重要ではありません。
一方で、プログラムが<code>Nat</code>を返す場合には、それが_正しい_ <code>Nat</code>であることは非常に重要です。</p>
<p><code>Prop</code>は宇宙階層の最下位にあり、<code>Prop</code>の型は<code>Type</code>です。
これは<code>Prop</code>が<code>Nat</code>と同じ理由で<code>List</code>に提供するための適切な引数であることを意味します。
命題のリストは <code>List Prop</code>型を持ちます:</p>
<pre><code class="language-lean">def someTruePropositions : List Prop := [
  1 + 1 = 2,
  &quot;Hello, &quot; ++ &quot;world!&quot; = &quot;Hello, world!&quot;
]
</code></pre>
<p>宇宙の引数を明示的に記入することにより、<code>Prop</code>が<code>Type</code>であることが示されます:</p>
<pre><code class="language-lean">def someTruePropositions : List.{0} Prop := [
  1 + 1 = 2,
  &quot;Hello, &quot; ++ &quot;world!&quot; = &quot;Hello, world!&quot;
]
</code></pre>
<p>内部的には、<code>Prop</code>と<code>Type</code>は<code>Sort</code>と呼ばれる単一の階層に統合されています。
<code>Prop</code>は<code>Sort 0</code>と同じで、<code>Type 0</code>は<code>Sort 1</code>、<code>Type 1</code>は<code>Sort 2</code>であり、その先も続きます。
実際には、<code>Type u</code>は<code>Sort (u+1)</code>と同じです。
Leanでプログラムを書くときにはこれは通常関係ありませんが、時々エラーメッセージに現れることがあり、また<code>CoeSort</code>クラスの名前の由来を説明するものでもあります。
さらに、<code>Prop</code>を<code>Sort 0</code>として持つことで、<code>Prop</code>と<code>Type</code>の宇宙の間でできる限り移植性のあるコードを書くときに<code>Prop</code>を返す関数に特別なルールを使用するようになります。</p>
<h2 id="実践における多相性"><a class="header" href="#実践における多相性">実践における多相性</a></h2>
<p>この本の残りの部分では、Lean標準ライブラリと一致するために、多相的なデータ型、構造体、およびクラスの定義に宇宙多相性が使用されます。
これにより<code>Functor</code>、<code>Applicative</code>、<code>Monad</code>クラスの完全な提示が実際の定義と完全に一致することが可能になります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="完全な定義"><a class="header" href="#完全な定義">完全な定義</a></h1>
<p>ここに、Lean 標準ライブラリにおける <code>Functor</code>、<code>Applicative</code>、そして <code>Monad</code> の完全かつ正直な定義を記述しました。
理解のために、詳細は省略されていません。</p>
<h2 id="functor"><a class="header" href="#functor">Functor</a></h2>
<p><code>Functor</code> クラスの完全な定義は、宇宙多相性 (universe polymorphism) とデフォルトメソッド実装を使用します：</p>
<pre><code class="language-lean">class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
  mapConst : {α β : Type u} → α → f β → f α :=
    Function.comp map (Function.const _)
</code></pre>
<p>この定義において、<code>Function.comp</code> は関数の合成であり、通常 <code>∘</code> 演算子で書かれます。
<code>Function.const</code> は_定数関数 (constant function)_ で、第二引数を無視する二つの引数を取る関数です。
この関数に一つの引数だけを適用すると、常に同じ値を返す関数が得られ、APIが関数を要求するものの、プログラムが異なる引数に対して異なる結果を計算する必要がない場合に便利です。
<code>Function.const</code> のシンプルなバージョンは次のように書けます：</p>
<pre><code class="language-lean">def simpleConst  (x : α) (_ : β) : α := x
</code></pre>
<p>これを <code>List.map</code> に対する関数引数として一つの引数で使用するとその有用性がわかります：</p>
<pre><code class="language-lean">#eval [1, 2, 3].map (simpleConst &quot;same&quot;)
</code></pre>
<pre><code class="language-output info">[&quot;same&quot;, &quot;same&quot;, &quot;same&quot;]
</code></pre>
<p>実際の関数には以下のようなシグネチャがあります：</p>
<pre><code class="language-output info">Function.const.{u, v} {α : Sort u} (β : Sort v) (a : α) (a✝ : β) : α
</code></pre>
<p>ここで、型引数 <code>β</code> は明示的な引数であり、そのため <code>Functor.mapConst</code> のデフォルト定義は <code>_</code> 引数を提供し、プログラムがタイプチェックされるように <code>Function.const</code> に渡すユニークな型を Lean が見つけるよう指示します。
<code>(Function.comp map (Function.const _) : α → f β → f α)</code> は <code>fun (x : α) (y : f β) =&gt; map (fun _ =&gt; x) y</code> と同等です。</p>
<p><code>Functor</code> 型クラスは <code>u+1</code> と <code>v</code> の大きな方にある宇宙に属しています。
ここで、<code>u</code> は <code>f</code> に対して引数として受け入れられる宇宙のレベル、<code>v</code> は <code>f</code> によって返される宇宙です。
<code>Functor</code> 型クラスを実装する構造が <code>u</code> よりも大きな宇宙になければならない理由を理解するためには、クラスの簡素化された定義から始めます：</p>
<pre><code class="language-lean">class Functor (f : Type u → Type v) : Type (max (u+1) v) where
  map : {α β : Type u} → (α → β) → f α → f β
</code></pre>
<p>この型クラスの構造型は次の帰納型と等価です：</p>
<pre><code class="language-lean">inductive Functor (f : Type u → Type v) : Type (max (u+1) v) where
  | mk : ({α β : Type u} → (α → β) → f α → f β) → Functor f
</code></pre>
<p><code>Functor.mk</code> に引数として渡される <code>map</code> メソッドの実装には、<code>Type u</code> 内の二つの型を引数とする関数が含まれています。
これは関数自身の型が <code>Type (u+1)</code> 内にあることを意味するため、<code>Functor</code> も少なくとも <code>u+1</code> のレベルになければなりません。
同様に、関数の他の引数には <code>f</code> を適用して作られた型が含まれるため、<code>v</code> のレベルにも達している必要があります。
この節で共有されているすべての型クラスがこのプロパティを共有しています。</p>
<h2 id="applicative"><a class="header" href="#applicative">Applicative</a></h2>
<p><code>Applicative</code> 型クラスは実際には、<code>pure</code> や <code>seq</code> などの関連メソッドを含むいくつかの小さなクラスから構成されています。
最初に <code>Pure</code> と <code>Seq</code> があり、それぞれ <code>pure</code> と <code>seq</code> を含んでいます：</p>
<pre><code class="language-lean">class Pure (f : Type u → Type v) : Type (max (u+1) v) where
  pure {α : Type u} : α → f α

class Seq (f : Type u → Type v) : Type (max (u+1) v) where
  seq : {α β : Type u} → f (α → β) → (Unit → f α) → f β
</code></pre>
<p>これに加えて、<code>Applicative</code> は <code>SeqRight</code> と類似の <code>SeqLeft</code> クラスにも依存しています：</p>
<pre><code class="language-lean">class SeqRight (f : Type u → Type v) : Type (max (u+1) v) where
  seqRight : {α β : Type u} → f α → (Unit → f β) → f β

class SeqLeft (f : Type u → Type v) : Type (max (u+1) v) where
  seqLeft : {α β : Type u} → f α → (Unit → f β) → f α
</code></pre>
<p><a href="functor-applicative-monad/alternative.html">代替と検証に関する節</a>で紹介された <code>seqRight</code> 関数は、効果の観点から理解するのが最も簡単です。
<code>E1 *&gt; E2</code> は <code>SeqRight.seqRight E1 (fun () =&gt; E2)</code> に展開され、<code>E1</code> を実行してから <code>E2</code> を実行し、<code>E2</code> の結果だけを結果として得ると理解できます。
<code>E1</code> の効果によって <code>E2</code> が実行されなかったり、複数回実行されたりすることがあります。
確かに、<code>f</code> が <code>Monad</code> のインスタンスを持っているならば、<code>E1 *&gt; E2</code> は <code>do let _ ← E1; E2</code> と同等ですが、<code>seqRight</code> は <code>Validate</code> のようなモナドではない型で使用できます。</p>
<p>そのいとこ <code>seqLeft</code> も非常に似ていますが、左側の式の値が返されます。
<code>E1 &lt;* E2</code> は <code>SeqLeft.seqLeft E1 (fun () =&gt; E2)</code> に展開されます。
<code>SeqLeft.seqLeft</code> の型は <code>f α → (Unit → f β) → f α</code> となり、これは <code>seqRight</code> と同じですが、<code>f α</code> を返すという点だけが異なります。
<code>E1 &lt;* E2</code> は <code>E1</code> を最初に実行し、次に <code>E2</code> を実行し、<code>E1</code> に対する元の結果を返すプログラムとして理解できます。
<code>f</code> が <code>Monad</code> のインスタンスを持っているならば、<code>E1 &lt;* E2</code> は <code>do let x ← E1; _ ← E2; pure x</code> と同等です。
一般的に、<code>seqLeft</code> は、値自体を変更することなく、検証やパーサーのようなワークフローにおいて値に追加の条件を指定するために役立ちます。</p>
<p><code>Applicative</code> の定義はこれらのクラスすべてを拡張しますが、<code>Functor</code> も含んでいます：</p>
<pre><code class="language-lean">class Applicative (f : Type u → Type v) extends Functor f, Pure f, Seq f, SeqLeft f, SeqRight f where
  map      := fun x y =&gt; Seq.seq (pure x) fun _ =&gt; y
  seqLeft  := fun a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
  seqRight := fun a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
</code></pre>
<p><code>Applicative</code> の完全な定義には <code>pure</code> と <code>seq</code> の定義だけが必要です。
これは <code>Functor</code>、<code>SeqLeft</code>、<code>SeqRight</code> のすべてのメソッドにデフォルトの定義があるためです。
<code>Functor</code> の <code>mapConst</code> メソッドには <code>Functor.map</code> に基づく独自のデフォルト実装があります。
これらのデフォルト実装は、振る舞いが同等でありながら効率的な新たな関数に置き換えられるべきです。
デフォルトの実装は、正確性の仕様と同時に自動生成されたコードとして見るべきです。</p>
<p><code>seqLeft</code> のデフォルト実装は非常にコンパクトです。
いくつかの名前を構文糖やそれらの定義に置き換えることで別の視点が得られるため：</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
</code></pre>
<p>になります</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq ((fun x _ =&gt; x) &lt;$&gt; a) b
</code></pre>
<p><code>(fun x _ =&gt; x) &lt;$&gt; a</code> はどのように理解すべきでしょうか？
ここでは、<code>a</code> は型 <code>f α</code> を持ち、<code>f</code> はファンクターです。
<code>f</code> が <code>List</code> である場合、<code>(fun x _ =&gt; x) &lt;$&gt; [1, 2, 3]</code> は <code>[fun _ =&gt; 1, fun _ =&gt; 2, fun _ =&gt; 3]</code> と評価されます。
<code>f</code> が <code>Option</code> である場合、<code>(fun x _ =&gt; x) &lt;$&gt; some &quot;hello&quot;</code> は <code>some (fun _ =&gt; &quot;hello&quot;)</code> と評価されます。
どちらの場合でも、ファンクター内の値は引数を無視して元の値を返す関数に置き換えられます。
<code>seq</code> と組み合わせると、この関数は <code>seq</code> の第二引数の値を破棄します。</p>
<p><code>seqRight</code> のデフォルト実装も非常に類似していますが、<code>const</code> には追加の引数 <code>id</code> があります。
この定義も、いくつかの標準的な構文糖を導入し、それからいくつかの名前をそれらの定義に置き換えることで同様に理解することができます：</p>
<pre><code class="language-lean">fun a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ =&gt; id) &lt;$&gt; a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ =&gt; fun x =&gt; x) &lt;$&gt; a) b
===&gt;
fun a b =&gt; Seq.seq ((fun _ x =&gt; x) &lt;$&gt; a) b
</code></pre>
<p><code>(fun _ x =&gt; x) &lt;$&gt; a</code> はどのように理解すべきでしょうか？
やはり、例が役立ちます。
<code>(fun _ x =&gt; x) &lt;$&gt; [1, 2, 3]</code> は <code>[fun x =&gt; x, fun x =&gt; x, fun x =&gt; x]</code> と同等であり、<code>(fun _ x =&gt; x) &lt;$&gt; some &quot;hello&quot;</code> は <code>some (fun x =&gt; x)</code> と同等です。
言い換えれば、<code>(fun _ x =&gt; x) &lt;$&gt; a</code> は <code>a</code> の全体的な形を維持しつつ、各値がアイデンティティ関数で置き換えられます。
効果の観点から、<code>a</code> の副作用は起こりますが、それが <code>seq</code> で使われるときに値は捨てられます。</p>
<h2 id="monad"><a class="header" href="#monad">Monad</a></h2>
<p><code>Applicative</code> の構成操作がそれぞれ独自の型クラスに分割されているように、<code>Bind</code> も独自のクラスを持っています：</p>
<pre><code class="language-lean">class Bind (m : Type u → Type v) where
  bind : {α β : Type u} → m α → (α → m β) → m β
</code></pre>
<p><code>Monad</code> は <code>Applicative</code> と <code>Bind</code> で拡張されます：</p>
<pre><code class="language-lean">class Monad (m : Type u → Type v) extends Applicative m, Bind m : Type (max (u+1) v) where
  map      f x := bind x (Function.comp pure f)
  seq      f x := bind f fun y =&gt; Functor.map y (x ())
  seqLeft  x y := bind x fun a =&gt; bind (y ()) (fun _ =&gt; pure a)
  seqRight x y := bind x fun _ =&gt; y ()
</code></pre>
<p>インスタンスが要求するメソッドの集合と、階層全体から得られるデフォルトメソッドを追跡すると、<code>Monad</code> インスタンスには <code>bind</code> と <code>pure</code> の実装だけが必要です。
言い換えれば、<code>Monad</code> インスタンスは自動的に <code>seq</code>、<code>seqLeft</code>、<code>seqRight</code>、<code>map</code>、<code>mapConst</code> の実装を導出します。
API 境界の観点から、<code>Monad</code> のインスタンスを持つ任意の型は <code>Bind</code>、<code>Pure</code>、<code>Seq</code>、<code>Functor</code>、<code>SeqLeft</code>、<code>SeqRight</code> のインスタンスを得ます。</p>
<h2 id="エクササイズ"><a class="header" href="#エクササイズ">エクササイズ</a></h2>
<ol>
<li><code>Monad</code> における <code>map</code>、<code>seq</code>、<code>seqLeft</code>、<code>seqRight</code> のデフォルト実装を、<code>Option</code> や <code>Except</code> などの例を通じて理解してみてください。つまり、その定義を <code>bind</code> と <code>pure</code> に代替してデフォルト定義に代入し、手書きされるであろうバージョンの <code>map</code>、<code>seq</code>、<code>seqLeft</code>、<code>seqRight</code> に単純化してください。</li>
<li>紙に書いたりテキストファイルに記述したりして、<code>map</code> と <code>seq</code> のデフォルト実装が <code>Functor</code> および <code>Applicative</code> の契約を満たすことを自分自身に証明してみてください。この議論で使用するのは <code>Monad</code> 契約からの規則と通常の式の評価です。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 概要

## 型クラスと構造体

内部的には、型クラスは構造体によって表現されます。
クラスを定義することは構造体を定義することであり、さらにインスタンスの空のテーブルを作成します。
インスタンスを定義すると、構造体をその型として持つ値が作成されるか、あるいは構造体を返すことができる関数が作成され、加えてテーブルに項目が追加されます。
インスタンスの検索は、インスタンステーブルを参照してインスタンスを構築することで行われます。
構造体とクラスは、デフォルト値を提供することができます（これはメソッドのデフォルト実装です）。

## 構造体と継承

構造体は他の構造体から継承することができます。
裏側では、他の構造体から継承する構造体は、もとの構造体のインスタンスをフィールドとして保持しています。
言い換えると、継承は合成によって実装されています。
複数継承が用いられる場合は、ダイヤモンド問題を避けるため設計によって、追加の親構造体からユニークなフィールドのみを使用し、通常ならば親の値を抽出する関数は代わりに一つを構築するように組織されます。
レコードドット表記は構造体の継承を考慮に入れています。

型クラスは単なる構造体であるため、いくつかの追加の自動化が適用されているだけで、これらのすべての機能が型クラスで利用可能です。
デフォルトメソッドと共に、これは大きなクラスが小さいクラスから継承することができる細かい階層のインターフェースを作成するために使用されますが、それはクライアントに大きな負担を課すものではないため、大きなクラスが継承する小さなクラスは自動的に実装可能です。

## アプリカティブファンクター

アプリカティブファンクターは、2つの追加操作を持つファンクターです：
 * `pure`、これは `Monad` のための同じ演算子です
 * `seq`、これはファンクターの文脈内で関数を適用することができます。
  
モナドは任意の制御フローを持つプログラムを表すことができますが、アプリカティブファンクターは関数引数を左から右へと実行することのみができます。
パワーが低いため、インターフェースに対するプログラムの制御は少ない反面、メソッドを実装する側にはより大きな自由度があります。
有用な型は `Applicative` を実装できますが、`Monad` は実装できません。

実際には、型クラス `Functor`、`Applicative`、`Monad` はパワーの階層を形成しています。
階層を昇るにつれて、`Functor` から `Monad` へと、よりパワフルなプログラムを書くことができますが、よりパワフルなクラスを実装する型は少なくなります。
多相的なプログラムは可能なかぎり弱い抽象化を使用して書くべきですが、データ型にはできるだけパワフルなインスタンスを与えるべきです。
これによりコードの再利用が最大化されます。
よりパワフルな型クラスは、より弱いものを拡張するため、`Monad` の実装は `Functor` および `Applicative` の実装を無料で提供します。

それぞれのクラスには実装されるべき一連のメソッドがあり、メソッドに追加のルールを定める対応する契約があります。
これらのインターフェースに対して書かれたプログラムは、追加のルールが守られることを期待しています。もしそれが守られていないならば、プログラムはバグを含む可能性があります。
`Functor` のデフォルト実装と `Applicative` の `Monad` のものは、これらのルールを守るでしょう。

## 宇宙

Leanをプログラミング言語と定理証明者の両方として使用できるようにするために、言語にはいくつかの制約が必要です。
これには、すべての再帰関数が終了するか、あるいは `partial` でマークされていて無人の型を返すように書かれていることを保証する必要があります。
さらに、特定の種類の論理的なパラドックスを型として表現できるようなことが不可能である必要があります。

特定のパラドックスを排除する制約の1つは、すべての型が _宇宙_ に割り当てられているということです。
宇宙は `Prop`、`Type`、`Type 1`、`Type 2` などの型です。
これらの型は他の型を記述します。`0` と `17` が `Nat` によって記述されているように、`Nat` 自体は `Type` によって、そして `Type` は `Type 1` によって記述されています。
型を引数として取る関数の型は、引数の宇宙よりも大きな宇宙でなければなりません。

宣言された各データ型には宇宙がありますが、データのように型を扱うコードを書くとすぐに面倒なことになり、多相型を`Type 1` から取るようにコピー・ペーストする必要が生じます。
_宇宙多相性_ という機能は、Leanのプログラムとデータ型が通常の多相性がプログラムに型を引数として取るのと同じように宇宙レベルを引数として取ることを可能にします。
一般的には、Leanのライブラリは多相的な操作のライブラリを実装する際に宇宙多相性を使用すべきです。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナドトランスフォーマー"><a class="header" href="#モナドトランスフォーマー">モナドトランスフォーマー</a></h1>
<p>モナドは、副作用をエンコードする手段の一つとして純粋言語において利用されます。
様々なモナドが異なる効果を提供し、例えば状態管理やエラー処理を行います。
多くのモナドは、多くの言語では使われないような有益な効果をも提供しており、非決定論的探索、リーダー、さらにコンティニュエーションなどがこれに該当します。</p>
<p>通常のアプリケーションでは、テストしやすい関数のコアセットがモナドを使わずに記述され、必要なアプリケーションロジックをエンコードするために外部ラッパーとしてモナドが使用されます。
これらモナドは、よく知られたコンポーネントから構築されています。
例えば：</p>
<ul>
<li>可変状態は同じ型の関数パラメータと戻り値でエンコードされる</li>
<li>エラー処理は<code>Except</code>に似た型で、成功と失敗のためのコンストラクタを持つ戻り値でエンコードされる</li>
<li>ログは戻り値とログを組み合わせることでエンコードされる</li>
</ul>
<p>しかしながら、それぞれのモナドを手作業で書くのは面倒であり、多種多様な型クラスを定義する際にはボイラープレートが不可欠です。
これらのコンポーネントは、さらなる効果を加えるべく他のモナドを変更する定義としても抜き出されることがあります。
このような定義は「<em>モナドトランスフォーマー</em>」として知られています。
具体的なモナドはモナドトランスフォーマーの集まりから構築することができ、これによりコードの再利用性が大いに向上します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioとreaderの組み合わせ"><a class="header" href="#ioとreaderの組み合わせ">IOとReaderの組み合わせ</a></h1>
<p>リーダーモナドが便利であるとされるのは、アプリケーションの「現在の設定」を多くの再帰呼び出しを通じて渡す必要がある場合です。そのようなプログラムの例として、現在のディレクトリ及びそのサブディレクトリ内のファイルを再帰的にリストアップし、ツリー構造を文字で表示する<code>tree</code>というコマンドがあります。この章で紹介する<code>tree</code>コマンドのバージョンは、北米西海岸に生息する偉大なダグラスファーにちなんで<code>doug</code>と名付けられ、ディレクトリ構造を表示する際にユニコード枠線記号かそれに相当するASCII文字を選択できるようにします。</p>
<p>例えば、以下のコマンドは<code>doug-demo</code>という名前のディレクトリにいくつかのサブディレクトリと空のファイルを作成します：</p>
<pre><code>$ cd doug-demo
$ mkdir -p a/b/c
$ mkdir -p a/d
$ mkdir -p a/e/f
$ touch a/b/hello
$ touch a/d/another-file
$ touch a/e/still-another-file-again
</code></pre>
<p><code>doug</code>を実行すると、以下のようになります：</p>
<pre><code>$ doug
</code></pre>
<h2 id="実装"><a class="header" href="#実装">実装</a></h2>
<p>内部的に、<code>doug</code>は設定値をディレクトリ構造の再帰的なトラバース中に下へ伝播させます。この設定には2つのフィールドが含まれています：<code>useASCII</code>はユニコード枠線記号を使うかASCIIの縦線やダッシュを使うかを決定し、<code>currentPrefix</code>は出力の各行の先頭につける文字列を保持しています。ディレクトリが深くなるにつれてプレフィックス文字列は、そのディレクトリ内に居ることを示すマーカーとともに拡大されます。この設定は以下のような構造です：</p>
<pre><code class="language-lean">-- Config構造体の例
</code></pre>
<p>この構造体は両方のフィールドにデフォルト値を持っています。デフォルトの<code>Config</code>はプレフィックスなしでユニコードを使用します。</p>
<p><code>doug</code>を使うユーザーはコマンドライン引数を提供する必要があります。コマンドラインの使用に関する情報は以下の通りです：</p>
<pre><code class="language-lean">-- コマンドライン引数の使用方法の例
</code></pre>
<p>それに応じて、コマンドライン引数のリストを解析して設定を構築することができます：</p>
<pre><code class="language-lean">-- 引数からConfigを構築する例
</code></pre>
<p><code>main</code>関数は、<code>dirTree</code>という内部のワーカー関数をラップしており、設定を使ってディレクトリ内容を表示します。<code>dirTree</code>を呼ぶ前に、<code>main</code>はコマンドライン引数を処理し、オペレーティングシステムに適切な終了コードを返す責任があります：</p>
<pre><code class="language-lean">-- main関数の例
</code></pre>
<p>ディレクトリツリーに表示すべきでない全てのパスがあります。特に、<code>.</code>や<code>..</code>という名前のファイルはスキップされるべきで、実際にはナビゲーションに使われるためでありファイルではありません。表示すべきファイルには2種類あります：通常のファイルとディレクトリです：</p>
<pre><code class="language-lean">-- Entry構造体の例
</code></pre>
<p>ファイルを表示すべきかどうかと、どの種類のエントリかを判断するために、<code>doug</code>は<code>toEntry</code>関数を使用します：</p>
<pre><code class="language-lean">-- toEntry関数の例
</code></pre>
<p><code>System.FilePath.components</code>関数は、パスをコンポーネントのリストに分割し、ディレクトリセパレータで分割された名前にします。最後のコンポーネントがない場合は、そのパスはルートディレクトリです。最後のコンポーネントが<code>.</code>や<code>..</code>など特殊なナビゲーションファイルであれば、そのファイルは除外されるべきです。それ以外の場合は、ディレクトリとファイルはそれぞれの構造体でラップされます。</p>
<p>Lean言語では、ディレクトリツリーが有限であると理解することはできません。実際には、いくつかのシステムは循環的なディレクトリ構造の作成を許可しています。したがって、<code>dirTree</code>関数は<code>partial</code>と宣言されています：</p>
<pre><code class="language-lean">-- dirTree関数の例
</code></pre>
<p><code>toEntry</code>への呼び出しはネストされたアクションです—括弧はアローとしての他の意味を持たせることができない位置で省略できます、例えば<code>match</code>の場合。ファイル名がツリー内のエントリに該当しない場合（例えば<code>..</code>のために）、<code>dirTree</code>は何もしません。通常のファイルを示している場合には、<code>dirTree</code>は現在の設定を用いて表示するヘルパー関数を呼びます。ディレクトリを指している場合は、ヘルパーで表示し、その後その内容を新しい設定で再帰的に表示します。</p>
<p>ファイルとディレクトリの名前を表示するためには、<code>showFileName</code>と<code>showDirName</code>が使われます：</p>
<pre><code class="language-lean">-- showFileNameとshowDirName関数の例
</code></pre>
<p>これらのヘルパー関数は、ASCIIかユニコードの選択を扱う<code>Config</code>上の関数を呼び出します：</p>
<pre><code class="language-lean">-- ファイル名とディレクトリ名を表示する関数の例
</code></pre>
<p>同様に、<code>Config.inDirectory</code>はプレフィックスをディレクトリマーカーで拡大する機能を提供します：</p>
<pre><code class="language-lean">-- inDirectory関数の例
</code></pre>
<p>ディレクトリ内のコンテンツリストに対してIOアクションを繰り返すには<code>doList</code>関数を使用します。<code>doList</code>関数はリスト内の全てのアクションを実行し、返される値に基づいて制御フローを判断しませんので、<code>Monad</code>の全機能は不要であり、任意の<code>Applicative</code>を実行できます：</p>
<pre><code class="language-lean">-- doList関数の例
</code></pre>
<h2 id="カスタムモナドの使用"><a class="header" href="#カスタムモナドの使用">カスタムモナドの使用</a></h2>
<p>この<code>doug</code>の実装は機能しますが、設定を手動で渡すことは冗長でエラーを引き起こしやすいです。タイプシステムは、間違った設定が下方向に渡されても、それをキャッチしません。リーダー効果は、再帰呼び出しの間毎回同じ設定が渡されることを保証し、コードをシンプルにするのに役立ちます。</p>
<p><code>IO</code>のバージョンを持つカスタム<code>Config</code>モナドを作成することもできますが、最初にそのタイプとその<code>Monad</code>インスタンスを定義する必要があります。<a href="monad-transformers/../monads/arithmetic.html#custom-environments"><code>示されている例の評価者</code></a>を参照してください：</p>
<pre><code class="language-lean">-- ConfigIOタイプとそのMonadインスタンスの例
</code></pre>
<p>この<code>Monad</code>インスタンスと<code>Reader</code>用のそれとの違いは、<code>bind</code>が<code>next</code>を直接<code>result</code>からの値に適用する代わりに、<code>IO</code>モナドの<code>do</code>構文を使用していることです。<code>result</code>による任意の<code>IO</code>効果は、<code>next</code>が呼ばれる前に発生しなければならず、<code>IO</code>モナドの<code>bind</code>演算子によってこれが保証されます。<code>ConfigIO</code>タイプは基底の<code>IO</code>タイプが多型でないため、多型でもありません。</p>
<p><code>ConfigIO</code>アクションを実行するには、設定を提供することによってIOアクションに変換することが含まれます：</p>
<pre><code class="language-lean">-- ConfigIOアクションを実行する例
</code></pre>
<p>この関数は本来必要ありません。なぜなら、呼出し側は単に設定を直接提供することもできるからです。しかし、この操作に名前をつけることで、どのコードの部分がどのモナドで実行されるべきなのかを、より理解しやすくします。</p>
<p>次のステップとして、現在の設定にアクセスする手段を<code>ConfigIO</code>の一部として定義します：</p>
<pre><code class="language-lean">-- 現在のConfigにアクセスするための例
</code></pre>
<p>これは<code>read</code>と似ていますが、その値を直接返すのではなく、<code>IO</code>の<code>pure</code>を使用して返します。ディレクトリに進入することは、より小さなプログラムの領域に対して変更された設定を局所的に限定するために再帰呼び出しのスコープで現在の設定を変更することを意味するので、設定を上書きする手段が必要です：</p>
<pre><code class="language-lean">-- 設定を上書きする例
</code></pre>
<p><code>doug</code>で使用される多くのコードは設定を必要としません。<code>doug</code>は標準ライブラリから通常のLeanのIOアクションを呼び出しますが、それらは確かに<code>Config</code>を必要としません。普通のIOアクションは<code>runIO</code>を使って実行できます。これは設定引数を無視します：</p>
<pre><code class="language-lean">-- runIO関数の例
</code></pre>
<p>これらのコンポーネントがあれば、<code>showFileName</code>と<code>showDirName</code>は<code>ConfigIO</code>モナドを介して暗黙的に設定引数を受け取り、<a href="monad-transformers/../hello-world/conveniences.html#nested-actions">ネストされたアクション</a>を使用して設定を取得し、<code>runIO</code>を使用して<code>IO.println</code>の呼び出しを実行します：</p>
<pre><code class="language-lean">-- showFileNameとshowDirName関数の中間バージョンの例
</code></pre>
<p>新しいバージョンの<code>dirTree</code>では、<code>toEntry</code>と<code>System.FilePath.readDir</code>への呼び出しは<code>runIO</code>でラップされています。また、再帰呼び出しに渡す新しい設定をプログラマがどれを渡すかを追跡する代わりに、それは<code>locally</code>を使用して変更された設定をプログラムの小さなエリアに自然に限定し、それが有効な設定となります：</p>
<pre><code class="language-lean">-- dirTreeの中間バージョンの例
</code></pre>
<p>新しいバージョンの<code>main</code>は<code>ConfigIO.run</code>を使用して初期設定と一緒に<code>dirTree</code>を呼び出します：</p>
<pre><code class="language-lean">-- mainの中間バージョンの例
</code></pre>
<p>このカスタムモナドは設定を手動ですることに対して多くの利点を持ちます：</p>
<ol>
<li>設定を変更することなく渡すことを保証する方が簡単になります（変更を望む場合除く）。</li>
<li>設定を次に渡すという心配がディレクトリ内容の印刷の心配からより明確に分離されます。</li>
<li>プログラムが大きくなったとしても、設定のロジックを変更しても、これらの中間層を書き換える必要はありません。</li>
</ol>
<p>しかし、いくつかの明らかな欠点もあります：</p>
<ol>
<li>プログラムが進化してモナドにより多くの機能が必要になるにつれて、<code>locally</code>や<code>currentConfig</code>などの基本演算子を更新する必要があります。</li>
<li>通常のIOアクションを<code>runIO</code>でラップすることは騒々しく、プログラムの流れを邪魔します。</li>
<li>モナドインスタンスを手作業で作成することは繰り返しであり、それを異なるモナドに追加するためのリーダー効果は文書化とコミュニケーションのためのオーバーヘッドを必要とします。</li>
</ol>
<p>_モナド変換器_と呼ばれるテクニックを使用することで、これらの欠点に対処ることができます。モナド変換器は一つのモナドを引数として取り、新しいモナドを返します。モナド変換器には以下のものが含まれます：</p>
<ol>
<li>変換器自体（通常は型から型への関数です）。</li>
<li>内部型が既にモナドであることを前提とする<code>Monad</code>インスタンス。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナド構築キット"><a class="header" href="#モナド構築キット">モナド構築キット</a></h1>
<p><code>ReaderT</code>は有用なモナド変換子であり、それが唯一存在するわけではありません。
このセクションでは、追加の変換子について説明します。
各モナド変換子は以下のもので構成されます：</p>
<ol>
<li>モナドを引数として受け取る定義またはデータ型 <code>T</code>。
型は <code>(Type u → Type v) → Type u → Type v</code> のようになりますが、モナドの前に追加の引数を受け付けることがあります。</li>
<li><code>Monad m</code> のインスタンスに依存する <code>T m</code> の <code>Monad</code> インスタンス。これにより、変換されたモナドをモナドとして使用することができます。</li>
<li>任意のモナド <code>m</code> において、型 <code>m α</code> のアクションを型 <code>T m α</code> のアクションに変換する <code>MonadLift</code> インスタンス。これにより、基礎となるモナドのアクションを、変換されたモナドで使用できます。</li>
</ol>
<p>さらに、変換子の <code>Monad</code> インスタンスは、少なくとも基礎となる <code>Monad</code> インスタンスがそうである場合、<code>Monad</code> の契約を守るべきです。
加えて、<code>monadLift (pure x)</code> は変換されたモナドにおける <code>pure x</code> と等価でなければならず、<code>monadLift</code> は <code>bind</code> 上で分配可能であるべきで、<code>monadLift (x &gt;&gt;= f)</code> は <code>monadLift x &gt;&gt;= fun y =&gt; monadLift (f y)</code> と等価でなければなりません。</p>
<p>多くのモナド変換子は、モナドにおいて使用可能な実際の効果を記述する <code>MonadReader</code> のスタイルの型クラスを追加で定義します。
これにより、より大きな柔軟性が提供されることがあります：プログラムはインターフェイスのみに依存するように記述され、特定の変換子によって基礎となるモナドが実装されることに制約されることはありません。
型クラスは、プログラムがその要件を表現する方法であり、モナド変換子はこれらの要件を満たす便利な方法です。</p>
<h2 id="optiont-を用いた失敗"><a class="header" href="#optiont-を用いた失敗"><code>OptionT</code> を用いた失敗</a></h2>
<p><code>Option</code> モナドによって代表される失敗と、<code>Except</code> モナドによって代表される例外の両方には、対応する変換子があります。
<code>Option</code> の場合、失敗をモナドに追加することは、それ以外では型 <code>α</code> の値を含む箇所に型 <code>Option α</code> の値を含むようにすることで実現されます。
たとえば、<code>IO (Option α)</code> は常に型 <code>α</code> の値を返すわけではない <code>IO</code> アクションを表します。
これは、モナド変換子 <code>OptionT</code> の定義を示唆しています：</p>
<pre><code class="language-lean">def OptionT (m : Type u → Type v) (α : Type u) : Type v :=
  m (Option α)
</code></pre>
<p><code>OptionT</code> のアクションの例として、ユーザーに質問をするプログラムを考えます。
関数 <code>getSomeInput</code> は入力行を求め、両端から空白を削除します。
結果のトリムされた入力が空でない場合は、それが返されますが、空白文字がない場合は関数は失敗します：</p>
<pre><code class="language-lean">def getSomeInput : OptionT IO String := do
  let input ← (← IO.getStdin).getLine
  let trimmed := input.trim
  if trimmed == &quot;&quot; then
    failure
  else pure trimmed
</code></pre>
<p>この特定のアプリケーションは、ユーザーを名前と彼らの好きな甲虫の種類で追跡します：</p>
<pre><code class="language-lean">structure UserInfo where
  name : String
  favoriteBeetle : String
</code></pre>
<p>ユーザーに入力を求めることは、<code>IO</code> のみを使用する関数よりも煩雑ではありません：</p>
<pre><code class="language-lean">def getUserInfo : OptionT IO UserInfo := do
  IO.println &quot;What is your name?&quot;
  let name ← getSomeInput
  IO.println &quot;What is your favorite species of beetle?&quot;
  let beetle ← getSomeInput
  pure ⟨name, beetle⟩
</code></pre>
<p>しかし、関数が <code>IO</code> ではなく <code>OptionT IO</code> の文脈で実行されるため、最初の <code>getSomeInput</code> 呼び出しでの失敗は、甲虫に関する質問に到達することなく <code>getUserInfo</code> 全体の失敗を引き起こします。
メイン関数 <code>interact</code> は、<code>getUserInfo</code> を純粋な <code>IO</code> コンテキストで呼び出し、内部の <code>Option</code> にマッチングすることで、呼び出しが成功したか失敗したかを確認します：</p>
<pre><code class="language-lean">def interact : IO Unit := do
  match ← getUserInfo with
  | none =&gt; IO.eprintln &quot;Missing info&quot;
  | some ⟨name, beetle⟩ =&gt; IO.println s!&quot;Hello {name}, whose favorite beetle is {beetle}.&quot;
</code></pre>
<h3 id="モナドインスタンス"><a class="header" href="#モナドインスタンス">モナドインスタンス</a></h3>
<p>モナドインスタンスを記述する際には難しさが明らかになります。
型に基づいて <code>pure</code> は基礎となるモナド <code>m</code> の <code>pure</code> と共に使用するべきです。
<code>Option</code> の <code>bind</code> が最初の引数に分岐し <code>none</code> を伝播するのと同様に、<code>OptionT</code> の <code>bind</code> は最初の引数で構成されるモナドアクションを実行し、結果に分岐した後 <code>none</code> を伝播するべきです。
この概略に従うと以下の定義が生じますが、Leanは受け入れません：</p>
<pre><code class="language-lean">instance [Monad m] : Monad (OptionT m) where
  pure x := pure (some x)
  bind action next := do
    match (← action) with
    | none =&gt; pure none
    | some v =&gt; next v
</code></pre>
<p>エラーメッセージには謎めいた型の不一致が表示されます：</p>
<pre><code class="language-output error">application type mismatch
  pure (some x)
argument
  some x
has type
  Option α✝ : Type ?u.25
but is expected to have type
  α✝ : Type ?u.25
</code></pre>
<p>ここでの問題は、Leanが<code>pure</code>の周辺使用に対する間違った<code>Monad</code>インスタンスを選択していることです。
型注釈を使用してLeanを正しい<code>Monad</code>インスタンスに導くために同様のエラーが<code>bind</code>の定義にも発生します：</p>
<pre><code class="language-lean">instance [Monad m] : Monad (OptionT m) where
  pure x := (pure (some x) : m (Option _))
  bind action next := (do
    match (← action) with
    | none =&gt; pure none
    | some v =&gt; next v : m (Option _))
</code></pre>
<p>この解決策は機能しますが、洗練されておらずコードが少し騒がしくなります。</p>
<p>別の解決策は、正しいインスタンスにLeanを導く型シグネチャを持つ関数を定義することです。
実際には、<code>OptionT</code> を構造体として定義することも可能でした：</p>
<pre><code class="language-lean">structure OptionT (m : Type u → Type v) (α : Type u) : Type v where
  run : m (Option α)
</code></pre>
<p>これにより問題が解決されます。なぜなら、コンストラクタ <code>OptionT.mk</code> とフィールドアクセス <code>OptionT.run</code> が正しいインスタンスに型クラスインターフェースを導くからです。
ただし、構造体の値を使ったコードを実行するたびに、割り当ておよび取り消しが必要になり、それに対して直接の定義はコンパイル時のみの機能です。
最善の世界は <code>OptionT.mk</code> と <code>OptionT.run</code> の役割として機能するが、直接定義で機能する関数を定義することによって達成できます：</p>
<pre><code class="language-lean">def OptionT.mk (x : m (Option α)) : OptionT m α := x

def OptionT.run (x : OptionT m α) : m (Option α) := x
</code></pre>
<p>これらの関数は入力されたものを変更せずに返しますが、<code>OptionT</code>のインターフェイスを提示することを意図したコードと、基礎となるモナド <code>m</code> のインターフェイスを提示することを意図したコードの間に境界を示しています。
これらの補助関数を使用して、<code>Monad</code>インスタンスがより読みやすくなります：</p>
<pre><code class="language-lean">instance [Monad m] : Monad (OptionT m) where
  pure x := OptionT.mk (pure (some x))
  bind action next := OptionT.mk do
    match ← action with
    | none =&gt; pure none
    | some v =&gt; next v
</code></pre>
<p>ここでは <code>OptionT.mk</code> の使用が引数を <code>m</code> のインターフェイスを使用するコードとして見なすべきことを示し、これによってLeanは正しい <code>Monad</code> インスタンスを選択することができます。</p>
<p>モナドインスタンスを定義した後、モナド契約が満たされていることを確認することは良いアイデアです。
最初のステップは <code>bind (pure v) f</code> が <code>f v</code> と同じであることを示すことです。
以下がステップです：</p>
<div class="equational">
<div class="term">
<pre><code class="language-lean hljs">bind (pure v) f</code></pre>
</div>
<div class="explanation">
={ <em>Unfolding the definitions of <code class="hljs">bind</code> and <code class="hljs">pure</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">OptionT.mk do
  match ← pure (some v) with
  | none => pure none
  | some x => f x</code></pre>
</div>
<div class="explanation">
={ <em>Desugaring nested action syntax</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">OptionT.mk do
  let y ← pure (some v)
  match y with
  | none => pure none
  | some x => f x</code></pre>
</div>
<div class="explanation">
={ <em>Desugaring <code class="hljs">do</code>-notation</em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">OptionT.mk
  (pure (some v) >>= fun y =>
    match y with
    | none => pure none
    | some x => f x)</code></pre>
</div>
<div class="explanation">
={ <em>Using the first monad rule for <code class="hljs">m</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">OptionT.mk
  (match some v with
   | none => pure none
   | some x => f x)</code></pre>
</div>
<div class="explanation">
={ <em>Reduce <code class="hljs">match</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">OptionT.mk (f v)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">OptionT.mk</code></em> }=
</div>
<div class="term">
<pre><code class="language-lean hljs">f v</code></pre>
</div>
</div>
<p>二つ目の規則は <code>bind w pure</code> が <code>w</code> と同じであると述べています。
これを示すためには、<code>bind</code> と <code>pure</code> の定義を展開し、以下を示します：</p>
<pre><code class="language-lean">OptionT.mk do
    match ← w with
    | none =&gt; pure none
    | some v =&gt; pure (some v)
</code></pre>
<p>このパターンマッチで、両方のケースの結果はパターンに対して同じですが、<code>pure</code> がそれを取り巻いています。
つまり、これは <code>w &gt;&gt;= fun y =&gt; pure y</code> に相当し、これは <code>m</code> の二つ目のモナドルールのインスタンスです。</p>
<p>最終ルールは <code>bind (bind v f) g</code> が <code>bind v (fun x =&gt; bind (f x) g)</code> と同じであると述べています。
これも同様の方法で <code>bind</code> と <code>pure</code> の定義を展開して確認することができ、その後基礎となるモナド <code>m</code> に委ねます。</p>
<h3 id="alternative-インスタンス"><a class="header" href="#alternative-インスタンス"><code>Alternative</code> インスタンス</a></h3>
<p><code>OptionT</code> を使用する便利な方法の一つは、<code>Alternative</code> 型クラスを通じてです。
成功した返り値はすでに <code>pure</code> によって示されており、<code>Alternative</code> の <code>failure</code> および <code>orElse</code> メソッドは、複数のサブプログラムから最初の成功した結果を返すプログラムを記述する方法を提供します：</p>
<pre><code class="language-lean">instance [Monad m] : Alternative (OptionT m) where
  failure := OptionT.mk (pure none)
  orElse x y := OptionT.mk do
    match ← x with
    | some result =&gt; pure (some result)
    | none =&gt; y ()
</code></pre>
<h3 id="リフティング"><a class="header" href="#リフティング">リフティング</a></h3>
<p><code>m</code> から <code>OptionT m</code> へのアクションをリフティングすることは、計算結果に <code>some</code> をラップするだけで必要とされます：</p>
<pre><code class="language-lean">instance [Monad m] : MonadLift m (OptionT m) where
  monadLift action := OptionT.mk do
    pure (some (← action))
</code></pre>
<h2 id="例外"><a class="header" href="#例外">例外</a></h2>
<p><code>Except</code> のモナド変換子バージョンは <code>Option</code> のモナド変換子バージョンに非常に似ています。
型 <code>ε</code> の例外を型 <code>m α</code> のモナドアクションに追加することは <code>α</code> に例外を追加し、型 <code>m (Except ε α)</code> を生み出すことで実現されます：</p>
<pre><code class="language-lean">def ExceptT (ε : Type u) (m : Type u → Type v) (α : Type u) : Type v :=
  m (Except ε α)
</code></pre>
<p><code>OptionT</code> は型チェッカーを正しい <code>Monad</code> インスタンスに導く <code>mk</code> と <code>run</code> 関数を提供します。
このテクニックは <code>ExceptT</code> にも役立ちます：</p>
<pre><code class="language-lean">def ExceptT.mk {ε α : Type u} (x : m (Except ε α)) : ExceptT ε m α := x

def ExceptT.run {ε α : Type u} (x : ExceptT ε m α) : m (Except ε α) := x
</code></pre>
<p><code>ExceptT</code> の <code>Monad</code> インスタンスも <code>OptionT</code> のインスタンスと非常に似ています。
唯一の違いは、特定のエラー値を伝播すること、そして <code>none</code> ではないことです：</p>
<pre><code class="language-lean">instance {ε : Type u} {m : Type u → Type v} [Monad m] : Monad (ExceptT ε m) where
  pure x := ExceptT.mk (pure (Except.ok x))
  bind result next := ExceptT.mk do
    match ← result with
    | .error e =&gt; pure (.error e)
    | .ok x =&gt; next x
</code></pre>
<p><code>ExceptT.mk</code> と <code>ExceptT.run</code> の型シグネチャには、<code>α</code> と <code>ε</code> の宇宙レベルを明示的に注釈しているという微妙な詳細が含まれています。
それらが明示的に注釈されていない場合、Leanはそれらに異なる多型宇宙変数があるより一般的な型シグネチャを生成し、しかし <code>ExceptT</code> の定義は <code>m</code> に引数として両方を与えることができるために、それらが同じ宇宙にあることを期待しています。
これにより <code>Monad</code> インスタンスで宇宙レベルのソルバーが機能するソリューションを見つけることができずに問題が発生する可能性があります：</p>
<pre><code class="language-lean">def ExceptT.mk (x : m (Except ε α)) : ExceptT ε m α := x

instance {ε : Type u} {m : Type u → Type v} [Monad m] : Monad (ExceptT ε m) where
  pure x := ExceptT.mk (pure (Except.ok x))
  bind result next := ExceptT.mk do
    match (← result) with
    | .error e =&gt; pure (.error e)
    | .ok x =&gt; next x
</code></pre>
<pre><code class="language-output error">stuck at solving universe constraint
  max ?u.12144 ?u.12145 =?= u
while trying to unify
  ExceptT ε m α✝
with
  (ExceptT ε m α✝) ε m α✝
</code></pre>
<p>この種のエラーメッセージは一般に、制約が不足している宇宙変数によって引き起こされます。
診断するのはトリッキーなことがありますが、最初のステップとしては、一部の定義で再利用される宇宙変数が他の定義では再利用されないことを探すことです。</p>
<p><code>Except</code> と異なり、<code>Except</code> データ型は通常データ構造として使用されません。
それは常にその <code>Monad</code> インスタンスを使った制御構造として使用されます。
これは <code>Except ε</code> アクションを <code>ExceptT ε m</code> にリフティングすることが合理的であることを意味し、 <code>m</code> のアクションから <code>m</code> のエフェクトがないため、<code>m</code> の <code>pure</code> でそれらをラップする必要があります：</p>
<pre><code class="language-lean">instance [Monad m] : MonadLift (Except ε) (ExceptT ε m) where
  monadLift action := ExceptT.mk (pure action)
</code></pre>
<p><code>m</code> からのアクションには例外が含まれていないため、その値は <code>Except.ok</code> にラップされるべきです。
これは、<code>Functor</code> が <code>Monad</code> のスーパークラスであるという事実を利用して、任意の</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナドトランスフォーマの並び順"><a class="header" href="#モナドトランスフォーマの並び順">モナドトランスフォーマの並び順</a></h1>
<p>モナドトランスフォーマのスタックからモナドを構築する際、その層の順序が重要であることに注意する必要があります。
同じセットのトランスフォーマを異なる順序で積み重ねると、異なるモナドが生まれます。</p>
<p>このバージョンの <code>countLetters</code> は、具体的なモナドを提供する代わりに型クラスを使用して使用可能な効果のセットを記述する点で、前のバージョンと異なります：</p>
<pre><code class="language-lean">def countLetters [Monad m] [MonadState LetterCounts m] [MonadExcept Err m] (str : String) : m Unit :=
  let rec loop (chars : List Char) := do
    match chars with
    | [] =&gt; pure ()
    | c :: cs =&gt;
      if c.isAlpha then
        if vowels.contains c then
          modify fun st =&gt; {st with vowels := st.vowels + 1}
        else if consonants.contains c then
          modify fun st =&gt; {st with consonants := st.consonants + 1}
        else -- modified or non-English letter
          pure ()
      else throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>ステートと例外のモナドトランスフォーマを、以下の2つの異なる順序で組み合わせることができ、どちらの順序でも両方の型クラスのインスタンスがあるモナドになります：</p>
<pre><code class="language-lean">abbrev M1 := StateT LetterCounts (ExceptT Err Id)
abbrev M2 := ExceptT Err (StateT LetterCounts Id)
</code></pre>
<p>プログラムが例外を投げない入力に対して実行される場合、両方のモナドは似たような結果をもたらします：</p>
<pre><code class="language-lean">#eval countLetters (m := M1) &quot;hello&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">Except.ok ((), { vowels := 2, consonants := 3 })
</code></pre>
<pre><code class="language-lean">#eval countLetters (m := M2) &quot;hello&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">(Except.ok (), { vowels := 2, consonants := 3 })
</code></pre>
<p>しかし、これらの戻り値の間には微妙な違いが存在します。
<code>M1</code>の場合、最も外側のコンストラクタは<code>Except.ok</code>で、最終状態とユニットコンストラクタの組み合わせを含んでいます。
<code>M2</code>の場合、最も外側のコンストラクタはその組み合わせであり、ユニットコンストラクタに適用された<code>Except.ok</code>が含まれます。
最終状態は<code>Except.ok</code>の外にあります。
どちらの場合も、プログラムは母音と子音の数を返します。</p>
<p>一方で、文字列が例外を投げる原因となる場合、最終的に母音と子音のカウントを返すモナドは一つだけです。
<code>M1</code>を使用すると、例外値のみが返されます：</p>
<pre><code class="language-lean">#eval countLetters (m := M1) &quot;hello!&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">Except.error (StEx.Err.notALetter '!')
</code></pre>
<p><code>M2</code>を使用すると、例外値がその時点の状態とペアになります：</p>
<pre><code class="language-lean">#eval countLetters (m := M2) &quot;hello!&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">(Except.error (StEx.Err.notALetter '!'), { vowels := 2, consonants := 3 })
</code></pre>
<p><code>M2</code>はデバッグ時に役立つかもしれない情報をより多く提供しているため、<code>M1</code>よりも優れていると考えがちです。
しかし、同じプログラムが<code>M1</code>と<code>M2</code>で_異なる_結果を計算する可能性があり、どちらの答えが必ずしも良いとは限りません。
例外を取り扱うプログラムのステップを行うと、これが明らかになります：</p>
<pre><code class="language-lean">def countWithFallback
    [Monad m] [MonadState LetterCounts m] [MonadExcept Err m]
    (str : String) : m Unit :=
  try
    countLetters str
  catch _ =&gt;
    countLetters &quot;Fallback&quot;
</code></pre>
<p>このプログラムは常に成功しますが、異なる結果で成功することもあります。
例外が投げられない場合、結果は<code>countLetters</code>と同じです：</p>
<pre><code class="language-lean">#eval countWithFallback (m := M1) &quot;hello&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">Except.ok ((), { vowels := 2, consonants := 3 })
</code></pre>
<pre><code class="language-lean">#eval countWithFallback (m := M2) &quot;hello&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">(Except.ok (), { vowels := 2, consonants := 3 })
</code></pre>
<p>しかし、例外が投げられて捕捉された場合、最終状態は非常に異なります。
<code>M1</code>の場合、最終状態は<code>&quot;Fallback&quot;</code>からの文字数のみを含みます：</p>
<pre><code class="language-lean">#eval countWithFallback (m := M1) &quot;hello!&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">Except.ok ((), { vowels := 2, consonants := 6 })
</code></pre>
<p><code>M2</code>の場合、最終状態は<code>&quot;hello&quot;</code>と<code>&quot;Fallback&quot;</code>の両方からの文字数を含んでおり、命令型の言語で期待されるような結果になります：</p>
<pre><code class="language-lean">#eval countWithFallback (m := M2) &quot;hello!&quot; ⟨0, 0⟩
</code></pre>
<pre><code class="language-output info">(Except.ok (), { vowels := 4, consonants := 9 })
</code></pre>
<p><code>M1</code>では、例外が投げられると状態は例外が捕捉された地点まで&quot;ロールバック&quot;されます。
<code>M2</code>では、例外が捕捉されても状態の変更は保持されます。
この違いは<code>M1</code>と<code>M2</code>の定義を展開することで確認できます。
<code>M1 α</code>を展開すると<code>LetterCounts → Except Err (α × LetterCounts)</code>になり、<code>M2 α</code>を展開すると<code>LetterCounts → Except Err α × LetterCounts</code>になります。
つまり、<code>M1 α</code>は初期の文字数を取り、エラーか更新された数に対応する<code>α</code>を返す関数を記述します。
<code>M1</code>で例外が投げられた場合、最終状態は存在しません。
<code>M2 α</code>は初期の文字数を取り、新しい文字数とエラーか<code>α</code>をペアにしたものを返す関数を記述します。
<code>M2</code>で例外が投げられると、それが状態に影響します。</p>
<h2 id="交換可能なモナド"><a class="header" href="#交換可能なモナド">交換可能なモナド</a></h2>
<p>関数型プログラミングの専門用語で、2つのモナドトランスフォーマが_交換可能である_とは、それらが順番を変えてもプログラムの意味が変わらない場合を指します。
<code>StateT</code>と<code>ExceptT</code>の並び替えはプログラムの結果を変えるため、ステートと例外は交換可能ではありません。
一般的に、モナドトランスフォーマは交換可能ではありません。</p>
<p>すべてのモナドトランスフォーマが交換可能でなくても、いくつかは交換可能です。
例えば、2つの<code>StateT</code>は並び替え可能です。
<code>StateT σ (StateT σ' Id) α</code>の定義を展開すると、型<code>σ → σ' → ((α × σ) × σ')</code>が得られ、<code>StateT σ' (StateT σ Id) α</code>を展開すると<code>σ' → σ → ((α × σ') × σ)</code>が得られます。
言い換えれば、それらの違いはσ型とσ'型がリターンタイプの異なる位置に入れ子になっていることと、引数を異なる順番で受け取っていることです。
クライアントコードは依然として同じ入力を提供する必要があり、また同じ出力を受け取ります。</p>
<p>ほとんどのプログラミング言語では、変更可能な状態と例外の両方を持っており、それは<code>M2</code>のように動作します。
これらの言語では、例外が発生した時にロールバックされるべき状態を表現することが困難で、通常は<code>M1</code>の明示的な状態値を使用することで模倣する必要があります。
モナドトランスフォーマは問題に応じてエフェクトの順序の解釈を選択する自由を与えますが、どちらの選択もプログラムするのは容易です。
しかし、トランスフォーマを順序付ける際は注意が必要です。
大きな表現力が与えられている分、意図したものが表現されていることを確認する責任が伴います。<code>countWithFallback</code>の型シグネチャは、おそらくそれがあるべきよりも多様性を持ちすぎているでしょう。</p>
<h2 id="練習問題-9"><a class="header" href="#練習問題-9">練習問題</a></h2>
<ul>
<li><code>ReaderT</code>と<code>StateT</code>が交換可能であることを、その定義を展開して得られる型を通じて推論することで確認してください。</li>
<li><code>ReaderT</code>と<code>ExceptT</code>は交換可能ですか？その定義を展開して得られる型を通じて推論することで回答を確認してください。</li>
<li><code>Many</code>の定義に基づいてモナドトランスフォーマ<code>ManyT</code>を構築し、適切な<code>Alternative</code>インスタンスが提供されているかを確認してください。またそれが<code>Monad</code>契約を満たしていることを確認してください。</li>
<li><code>ManyT</code>は<code>StateT</code>と交換可能ですか？もしそうなら、その定義を展開して得られる型を通じて推論することで回答を確認してください。そうでなければ、<code>ManyT (StateT σ Id)</code>のプログラムと<code>StateT σ (ManyT Id)</code>のプログラムを書いてください。それぞれのプログラムは、与えられたモナドトランスフォーマの順序に対してより意味をなすものです。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="doの機能強化"><a class="header" href="#doの機能強化">doの機能強化</a></h1>
<p>The content you provided seems to have placeholders for code examples (<code>{{#example_decl ... }}</code>, <code>{{#example_in ... }}</code>, <code>{{#example_out ... }}</code>, etc.) that are intended to be substituted with actual Lean code when the Markdown file is processed by a documentation tool or system. As those placeholders would fetch code from a database or a file system when processed, they aren't direct content that I can translate.</p>
<p>However, I can provide you with translation for the surrounding conceptual explanations and headings. Please note that any <code>{{...}}</code> placeholders will be left unchanged.</p>
<hr />
<h1 id="leanのdo表記におけるさらなる特徴"><a class="header" href="#leanのdo表記におけるさらなる特徴">Leanの<code>do</code>表記におけるさらなる特徴</a></h1>
<p>Leanの<code>do</code>表記は、命令型プログラミング言語に似た構文で、モナドを使ったプログラミングを記述するための構文を提供します。
単にモナドを有効活用するための便利な構文を提供するだけではなく、特定のモナドトランスフォーマを使うための構文も<code>do</code>記法は提供しています。</p>
<h2 id="ifの単一の分岐"><a class="header" href="#ifの単一の分岐"><code>if</code>の単一の分岐</a></h2>
<p>モナドの中で働く際、特定の条件が真のときだけに副作用を起こすという一般的なパターンがあります。
たとえば、<code>countLetters</code>は母音または子音かどうかをチェックする処理が含まれており、どちらでもない文字は状態に影響しません。
以下の<code>countLettersModify</code>は<code>else</code>ブロックが<code>pure ()</code>を評価し、これには副作用がありません：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  let rec loop (chars : List Char) := do
    match chars with
    | [] =&gt; pure ()
    | c :: cs =&gt;
      if c.isAlpha then
        if vowels.contains c then
          modify fun st =&gt; {st with vowels := st.vowels + 1}
        else if consonants.contains c then
          modify fun st =&gt; {st with consonants := st.consonants + 1}
        else -- modified or non-English letter
          pure ()
      else throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p><code>do</code>ブロック内で式ではなくステートメントとしての<code>if</code>には、<code>else pure ()</code>を省略でき、Leanは自動的にこれを挿入します。
以下の<code>countLettersNoElse</code>の定義も完全に同等です：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  let rec loop (chars : List Char) := do
    match chars with
    | [] =&gt; pure ()
    | c :: cs =&gt;
      if c.isAlpha then
        if vowels.contains c then
          modify fun st =&gt; {st with vowels := st.vowels + 1}
        else if consonants.contains c then
          modify fun st =&gt; {st with consonants := st.consonants + 1}
      else throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>状態モナドを使用して、モナディック条件を満たすリスト項目を数えるプログラムは以下のようになります：</p>
<pre><code class="language-lean">def count [Monad m] [MonadState Nat m] (p : α → m Bool) : List α → m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; do
    if ← p x then
      modify (· + 1)
    count p xs
</code></pre>
<p>同様に、<code>if not E1 then STMT...</code>のかわりに<code>unless E1 do STMT...</code>と書くことができます。
条件を満たさないエントリーを数える<code>countNot</code>の逆の動作は、<code>if</code>の代わりに<code>unless</code>を使うことで実現できます：</p>
<pre><code class="language-lean">def countNot [Monad m] [MonadState Nat m] (p : α → m Bool) : List α → m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; do
    unless ← p x do
      modify (· + 1)
    countNot p xs
</code></pre>
<p>単一の分岐<code>if</code>と<code>unless</code>を理解するには、モナドトランスフォーマについて考える必要はありません。
それらは単に欠けているブランチを<code>pure ()</code>で置き換えるだけです。
しかし、このセクションに残されている拡張機能はLeanが<code>do</code>ブロックを自動的に書き換え、そこに書かれたモナドの上に局所トランスフォーマーを追加するようになっています。</p>
<h2 id="早期リターン"><a class="header" href="#早期リターン">早期リターン</a></h2>
<p>標準ライブラリには、ある条件を満たすリストの最初のエントリを返す<code>List.find?</code>という関数が含まれています。
この<code>Option</code>モナドを活用しない単純な実装は、リカーシブ(再帰的)関数を使用し、望ましいエントリが見つかったときにループを停止するために<code>if</code>を使います：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; none
  | x :: xs =&gt;
    if p x then
      some x
    else
      find? p xs
</code></pre>
<p>命令型言語で、通常<code>return</code>キーワードは関数の実行を中断し、何らかの値を直ちに返すために使用されます。
Leanでは、<code>do</code>表記の中で<code>return</code>を使うことができ、<code>return</code>で<code>do</code>ブロックの実行を止めることができ、<code>return</code>の引数がモナドから返される値となります。
つまり、<code>List.find?</code>は以下のように書けたかもしれません：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; failure
  | x :: xs =&gt; do
    if p x then return x
    find? p xs
</code></pre>
<p>命令型言語の早期リターンは、現在のスタックフレームだけをアンワインドすることが可能な例外類似です。
早期リターンと例外はどちらもコードブロックの実行を停止させ、周囲のコードを投げられた値で置き換えます。
裏側では、Leanにおける早期リターンは<code>ExceptT</code>のバージョンを使用して実装されています。
早期リターンを使う各<code>do</code>ブロックは、関数<code>tryCatch</code>の意味の例外ハンドラーでラップされます。
早期リターンは例外として値を投げ、ハンドラは投げられた値をキャッチし、直ちに返します。
つまり、<code>do</code>ブロックの元の戻り値型は、例外型としても使われます。</p>
<p>より具体的にするために、ヘルパー関数<code>runCatch</code>は<code>ExceptT</code>の層をモナドトランスフォーマースタックの最上部から取り除きます。これは例外タイプと戻り値タイプが同じ場合に使用されます：</p>
<pre><code class="language-lean">def runCatch [Monad m] (action : ExceptT α m α) : m α := do
  match ← action with
  | Except.ok x =&gt; pure x
  | Except.error x =&gt; pure x
</code></pre>
<p>早期リターンを使う<code>List.find?</code>の<code>do</code>ブロックは、<code>runCatch</code>を使用してラップされ、早期リターンを<code>throw</code>に置き換えることで、早期リターンを使用しない<code>do</code>ブロックに変換されます：</p>
<pre><code class="language-lean">def List.find? (p : α → Bool) : List α → Option α
  | [] =&gt; failure
  | x :: xs =&gt;
    runCatch do
      if p x then throw x else pure ()
      monadLift (find? p xs)
</code></pre>
<p>早期リターンが有用な別のシナリオは、引数や入力が不正な場合にコマンドラインアプリケーションを早期終了させる場合です。
多くのプログラムは、プログラムの本体に入る前に、引数や入力を検証するセクションから始まります。
以下の挨拶プログラム<code>hello-name</code>のバージョンはコマンドライン引数が提供されていないことをチェックします：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  let stderr ← IO.getStderr

  unless argv == [] do
    stderr.putStrLn s!&quot;Expected no arguments, but got {argv.length}&quot;
    return 1

  stdout.putStrLn &quot;How would you like to be addressed?&quot;
  stdout.flush

  let name := (← stdin.getLine).trim
  if name == &quot;&quot; then
    stderr.putStrLn s!&quot;No name provided&quot;
    return 1

  stdout.putStrLn s!&quot;Hello, {name}!&quot;

  return 0
</code></pre>
<p>引数なしで実行し、名前<code>David</code>を入力すると、以前のバージョンと同じ結果が得られます。</p>
<p>名前をコマンドライン引数として提供するとエラーが発生します：</p>
<p>そして名前を提供しない場合は別のエラーが発生します：</p>
<p>早期リターンを使用するプログラムは、このような制御フローのネストを避けます。早期リターンを使用しないバージョンで行われているようにです：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  let stdin ← IO.getStdin
  let stdout ← IO.getStdout
  let stderr ← IO.getStderr

  if argv != [] then
    stderr.putStrLn s!&quot;Expected no arguments, but got {argv.length}&quot;
    pure 1
  else
    stdout.putStrLn &quot;How would you like to be addressed?&quot;
    stdout.flush

    let name := (← stdin.getLine).trim
    if name == &quot;&quot; then
      stderr.putStrLn s!&quot;No name provided&quot;
      pure 1
    else
      stdout.putStrLn s!&quot;Hello, {name}!&quot;
      pure 0
</code></pre>
<p>Leanの早期リターンと命令型言語の早期リターンの重要な違いの一つは、Leanの早期リターンは現在の<code>do</code>ブロックにのみ影響を与えるということです。
関数の完全な定義が同じ<code>do</code>ブロックの内にある場合は、この違いはそれほど重要ではありません。
しかし、<code>do</code>が他の構造の下にある場合、その差異は明確になります。
例として、以下の<code>greet</code>の定義を考えましょう：</p>
<pre><code class="language-lean">def greet (name : String) : String :=
  &quot;Hello, &quot; ++ Id.run do return name
</code></pre>
<p>この式<code>greet &quot;David&quot;</code>は<code>&quot;Hello, David&quot;</code>として評価されます。注意しましょう、これは<code>&quot;David&quot;</code>ではありません。</p>
<h2 id="ループ"><a class="header" href="#ループ">ループ</a></h2>
<p>すべての書き換え可能な状態を持つプログラムは、状態を引数として渡すプログラムに置き換えることができるのと同様に、すべてのループも再帰関数に置き換えることができます。
一方で、<code>List.find?</code>は再帰関数として一番明確です。結局のところ、定義はリストの構造を反映しています：先頭がチェックを通過するならばそれを返し、そうでなければ尾部を検討します。エントリがなくなった場合、答えは<code>none</code>です。
別の視点からすると、<code>List.find?</code>はループとしてもっとも明確です。このプログラムは満足のいくエントリが見つかるまで、順にエントリを調べます。ループがなにも返さずに終わる場合、答えは<code>none</code>です。</p>
<h3 id="formを使用したループ"><a class="header" href="#formを使用したループ">ForMを使用したループ</a></h3>
<p>Leanには、特定のモナドの中でコンテナ型をループするための型クラスが含まれています。
これは<code>ForM</code>と呼ばれています：</p>
<pre><code class="language-lean">class ForM (m : Type u → Type v) (γ : Type w₁) (α : outParam (Type w₂)) where
  forM [Monad m] : γ → (α → m PUnit) → m PUnit
</code></pre>
<p>このクラスはとても一般的です。パラメータ<code>m</code>はいくつかのモナドであり求められる効果を持ち、<code>γ</code>はループされるコレクションで、<code>α</code>はコレクションからの要素の型です。
通常<code>m</code>はどのモナドでも良いですが、例えば<code>IO</code>でのみループをサポートするデータ構造を持つこともできます。
メソッド<code>forM</code>はコレクションと、コレクションの各要素に対してその効果のために実行されるモナドアクションをとり、アクションを実行します。</p>
<p><code>List</code>のインスタンスも任意のモナドに対して<code>m</code>を許し、<code>γ</code>を<code>List α</code>に設定し、クラスの<code>α</code>はリストに見られる同じ<code>α</code>に設定します：</p>
<pre><code class="language-lean">def List.forM [Monad m] : List α → (α → m PUnit) → m PUnit
  | [], _ =&gt; pure ()
  | x :: xs, action =&gt; do
    action x
    forM xs action

instance : ForM m (List α) α where
  forM := List.forM
</code></pre>
<p><code>doug</code>からの<code>doList</code>関数はリストに対する<code>forM</code>です。
<code>forM</code>は<code>do</code>ブロックで使われることを意図しているため、<code>Applicative</code>よりも<code>Monad</code>が使われます。
<code>forM</code>を使えば<code>countLetters</code>をかなり短くすることができます：</p>
<pre><code class="language-lean">def countLetters (str : String) : StateT LetterCounts (Except Err) Unit :=
  forM str.toList fun c =&gt; do
    if c.isAlpha then
      if vowels.contains c then
        modify fun st =&gt; {st with vowels := st.vowels + 1}
      else if consonants.contains c then
        modify fun st =&gt; {st with consonants := st.consonants + 1}
    else throw (.notALetter c)
</code></pre>
<p><code>Many</code>のインスタンスも非常に似ています：</p>
<pre><code class="language-lean">def Many.forM [Monad m] : Many α → (α → m PUnit) → m PUnit
  | Many.none, _ =&gt; pure ()
  | Many.more first rest, action =&gt; do
    action first
    forM (rest ()) action

instance : ForM m (Many α) α where
  forM := Many.forM
</code></pre>
<p><code>γ</code>は何でもよいので、<code>ForM</code>は非多様なコレクションもサポートすることができます。
特にシンプルなコレクションの一つは、反対バージョンの特定の数値よりも小さい自然数です：</p>
<pre><code class="language-lean">structure AllLessThan where
  num : Nat
</code></pre>
<p>その<code>forM</code>演算子は指定されたアクションをそれぞれの小さな<code>Nat</code>に適用します：</p>
<pre><code class="language-lean">def AllLessThan.forM [Monad m] (coll : AllLessThan) (action : Nat → m Unit) : m Unit :=
  let rec countdown : Nat → m Unit
    | 0 =&gt; pure ()
    | n + 1 =&gt; do
      action n
      countdown n
  countdown coll.num

instance : ForM m AllLessThan Nat where
  forM := AllLessThan.forM
</code></pre>
<p>5より小さい数に<code>IO.println</code>を実行するのは<code>forM</code>を使って達成されます：</p>
<pre><code class="language-lean">#eval forM { num := 5 : AllLessThan } IO.println
</code></pre>
<pre><code class="language-output info">4
3
2
1
0
</code></pre>
<p>特定のモナドにのみ動作する<code>ForM</code>インスタンスの例は、例えば標準入力などのIOストリームから読まれた行をループするものです：</p>
<pre><code class="language-lean">structure LinesOf where
  stream : IO.FS.Stream

partial def LinesOf.forM (readFrom : LinesOf) (action : String → IO Unit) : IO Unit := do
  let line ← readFrom.stream.getLine
  if line == &quot;&quot; then return ()
  action line
  forM readFrom action

instance : ForM IO LinesOf String where
  forM := LinesOf.forM
</code></pre>
<p><code>forM</code>の定義は、ストリームが有限でない可能性があるため<code>partial</code>としてマークされています。
この場合、<code>IO.FS.Stream.getLine</code>は<code>IO</code>モナドのみで動作するため、他のモナドではループすることができません。</p>
<p>この例のプログラムでは、人を除いた行をフィルタリングするためにこのループ構造が使われています：</p>
<pre><code class="language-lean">def main (argv : List String) : IO UInt32 := do
  if argv != [] then
    IO.eprintln &quot;Unexpected arguments&quot;
    return 1

  forM (LinesOf.mk (← IO.getStdin)) fun line =&gt; do
    if line.any (·.isAlpha) then
      IO.print line

  return 0
</code></pre>
<p>ファイル<code>test-data</code>には以下の内容が含まれています：</p>
<p>このプログラムを実行すると、<code>ForMIO.lean</code>に保存されると次の出力が得られます：</p>
<h3 id="反復を停止する"><a class="header" href="#反復を停止する">反復を停止する</a></h3>
<p><code>forM</code>で早めにループを止めるのは大変な場合があります。
<code>AllLessThan</code>と<code>Nat</code>をループし、「3」に到達したら反復をやめるだけの関数を書く場合、途中でループを止められる手段が必要です。
この目的を達成する1つの方法は、<code>OptionT</code>モナドトランスフォーマを<code>forM</code>と一緒に使うことです。
最初のステップは、<code>OptionT.exec</code>を定義することであり、これは変換された計算に基づく戻り値と成功したかどうかの情報の両方を破棄します：</p>
<pre><code class="language-lean">def OptionT.exec [Applicative m] (action : OptionT m α) : m Unit :=
  action *&gt; pure ()
</code></pre>
<p>次に、<code>OptionT</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追加の便利機能-3"><a class="header" href="#追加の便利機能-3">追加の便利機能</a></h1>
<h2 id="パイプ演算子"><a class="header" href="#パイプ演算子">パイプ演算子</a></h2>
<p>通常、関数はその引数の前に記述されます。
左側から右側にプログラムを読み進める場合、関数の_出力_が最も重要になります。つまり、関数には達成すべき目標（つまり計算すべき値）があり、そのプロセスを支援するために引数が与えられます。
しかし、入力が順次精錬され出力が生成されるという考え方の方が理解しやすいプログラムもあります。
このような場合、LeanはF#と似た_パイプライン_演算子を提供しています。
パイプライン演算子は、Clojureのスレッドマクロが便利とされるのと同様の状況で役立ちます。</p>
<p>パイプライン <code>E1 |&gt; E2</code> は <code>E2 E1</code> の省略形です。
例えば、以下を評価すると:</p>
<pre><code class="language-lean">#eval some 5 |&gt; toString
</code></pre>
<p>結果は以下のようになります:</p>
<pre><code class="language-output info">&quot;(some 5)&quot;
</code></pre>
<p>このフォーカスの変更は、プログラムを読む際の利便性を高めることがありますが、特に多くの要素が含まれる場合にパイプラインが真価を発揮します。</p>
<p>以下の定義を使用して:</p>
<pre><code class="language-lean">def times3 (n : Nat) : Nat := n * 3
</code></pre>
<p>次のパイプラインを使うと:</p>
<pre><code class="language-lean">#eval 5 |&gt; times3 |&gt; toString |&gt; (&quot;It is &quot; ++ ·)
</code></pre>
<p>以下の結果が出力されます:</p>
<pre><code class="language-output info">&quot;It is 15&quot;
</code></pre>
<p>一般的に、パイプラインのシリーズ <code>E1 |&gt; E2 |&gt; E3 |&gt; E4</code> はネストされた関数適用 <code>E4 (E3 (E2 E1))</code> の省略形です。</p>
<p>パイプラインは逆向きにも書けます。
この場合、データ変換の対象を最初に提示するわけではありませんが、読者にとってネストされた括弧が挑戦的になる時に、適用されるステップを明瞭にできます。
上記の例は、以下のように書き換えられます:</p>
<pre><code class="language-lean">#eval (&quot;It is &quot; ++ ·) &lt;| toString &lt;| times3 &lt;| 5
</code></pre>
<p>これは以下の省略形です:</p>
<pre><code class="language-lean">#eval (&quot;It is &quot; ++ ·) (toString (times3 5))
</code></pre>
<p>演算子の後ろでの名前空間を解決するためにドットの前にある型名を使用するLeanのメソッドドット記法は、パイプラインと同様の目的で機能します。
パイプライン演算子なしで <code>[1, 2, 3].reverse</code> の代わりに <code>List.reverse [1, 2, 3]</code> と書くことは可能です。
しかし、パイプライン演算子は多くの関数を使用する際に、ドット付き関数においても便利です。
<code>([1, 2, 3].reverse.drop 1).reverse</code> は <code>[1, 2, 3] |&gt; List.reverse |&gt; List.drop 1 |&gt; List.reverse</code> としても書けます。
このバージョンでは、単に引数を受け入れるために式を括弧で囲む必要がなく、KotlinやC#といった言語でのメソッドチェーンの利便性を取り戻します。
しかし、名前空間は手動で提示しなければなりません。
最後の便利機能として、Leanは「パイプラインドット」演算子を提供しています。これはパイプラインと同様に関数をグループ化しますが、名前空間を解決するために型名を使用します。
「パイプラインドット」を使うと、例は <code>[1, 2, 3] |&gt;.reverse |&gt;.drop 1 |&gt;.reverse</code> に書き換えられます。</p>
<h2 id="無限ループ"><a class="header" href="#無限ループ">無限ループ</a></h2>
<p><code>do</code> ブロック内で、<code>repeat</code> キーワードは無限ループを生成します。
例として、文字列 <code>&quot;Spam!&quot;</code> を無限に表示するプログラムはそれを使って実現できます:</p>
<pre><code class="language-lean">def spam : IO Unit := do
  repeat IO.println &quot;Spam!&quot;
</code></pre>
<p><code>repeat</code> ループは、<code>break</code> や <code>continue</code> をサポートする点で <code>for</code> ループと同様です。</p>
<p><a href="monad-transformers/../hello-world/cat.html#streams"><code>feline</code> 実装</a>の <code>dump</code> 関数は、無限に実行される再帰関数を使用しています:</p>
<pre><code class="language-lean">partial def dump (stream : IO.FS.Stream) : IO Unit := do
  let buf ← stream.read bufsize
  if buf.isEmpty then
    pure ()
  else
    let stdout ← IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>この関数は <code>repeat</code> を利用することでより簡潔に記述することができます:</p>
<pre><code class="language-lean">def dump (stream : IO.FS.Stream) : IO Unit := do
  let stdout ← IO.getStdout
  repeat do
    let buf ← stream.read bufsize
    if buf.isEmpty then break
    stdout.write buf
</code></pre>
<p><code>spam</code> と <code>dump</code> のどちらも <code>partial</code> と宣言する必要はありません。これら自体が無限再帰ではないためです。
代わりに、<code>repeat</code> は <code>ForM</code> インスタンスが <code>partial</code> となる型を利用しています。
部分性は呼び出す側の関数に「感染」しません。</p>
<h2 id="whileループ"><a class="header" href="#whileループ">Whileループ</a></h2>
<p>局所的な可変性を伴うプログラミングにおいて、<code>if</code>-ガードされた <code>break</code> を使用する <code>repeat</code> の便利な代替として <code>while</code> ループがあります:</p>
<pre><code class="language-lean">def dump (stream : IO.FS.Stream) : IO Unit := do
  let stdout ← IO.getStdout
  let mut buf ← stream.read bufsize
  while not buf.isEmpty do
    stdout.write buf
    buf ← stream.read bufsize
</code></pre>
<p>舞台裏では、<code>while</code> は単に <code>repeat</code> のより簡潔な書き方です。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 要約

## モナドの組み合わせ

スクラッチからモナドを書く際には、それぞれのエフェクトをモナドに追加する方法を説明する設計パターンが存在します。
リーダーエフェクトは、モナド型がリーダーの環境からの関数として追加されます。状態エフェクトは、初期状態から最終状態までの値をペアとして含む関数によって追加されます。失敗や例外は、戻り値の型に和型（union type）を加えることで追加され、ログやその他の出力は、戻り値の型に積型（product type）を含むことで追加されます。
既存のモナドも、その効果を新しいモナドに含めるために、戻り値の型の一部として活用できます。

これらの設計パターンは、_モナドトランスフォーマー_を定義することで、再使用可能なソフトウェアコンポーネントのライブラリに変えられます。モナドトランスフォーマーは基本的なモナドにエフェクトを追加します。
モナドトランスフォーマーは、より単純なモナド型を引数として取り込み、強化されたモナド型を返します。
最低限、モナドトランスフォーマーは以下のインスタンスを提供するべきです：
 1. 内部の型が既にモナドであるとする`Monad`インスタンス
 2. 内部モナドから拡張されたモナドへアクションを変換する`MonadLift`インスタンス

モナドトランスフォーマーは多相的な構造や帰納的データ型として実装されることがありますが、通常は、基盤となるモナド型から拡張されたモナド型への関数として実装されます。

## エフェクトのための型クラス

特定のエフェクトを実装する一般的なアプローチは、そのエフェクトを持つモナドを定義し、それを他のモナドに追加するためのモナドトランスフォーマーを定義し、そのエフェクトに対する汎用インターフェースを提供する型クラスを定義することです。
これにより、プログラムを必要なエフェクトだけを指定するように記述し、実行環境が適切なエフェクトを持つ任意のモナドを提供することが可能です。

場合によっては、補助的な型情報（例えば、状態を提供するモナドの状態の型や、例外を提供するモナドの例外の型など）が出力パラメータとして使用されますが、必ずしもそうではありません。
出力パラメータは、様々なエフェクトを一度に使う単純なプログラムに最も役立ちますが、同じプログラム内で同じエフェクトを複数回使う場合には、型チェッカーが早い段階で誤った型に固定するリスクがあります。
したがって、一般的なパラメータを持つ型クラスと、`-Of`で終わる型クラスの両方が通常提供されます。

## モナドトランスフォーマーは交換可能ではありません

モナドにトランスフォーマーの順序を変更すると、そのモナドを使用するプログラムの意味が変わる可能性がある点に注意が必要です。
例えば、`StateT`と`ExceptT`の順序を変えることで、例外が投げられた場合に状態変更が失われるプログラム、あるいは変更が保持されるプログラムのどちらかが生じます。
多くの命令型言語は後者のみをサポートしていますが、モナドトランスフォーマーによる柔軟性の増加は、適切な種類を選ぶための細心の注意を要求します。

## `do`表記とモナドトランスフォーマー

Leanの`do`ブロックは、早期リターンによる特定の値での終了、ローカルに変更可能な変数、`for`ループを中断・続行する`break`と`continue`、そして単一の分岐で済む`if`文をサポートします。
これがLeanを使用して証明を書く際に邪魔になるように見えるかもしれませんが、実際にはこれはモナドトランスフォーマーを一般的に使う際により便利な構文であることが多いです。
その背後では、`do`ブロックに記述されているモナドはこれらの追加エフェクトをサポートするために`ExceptT`と`StateT`を適切に利用することによって拡張されています。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プログラミングにおける依存型"><a class="header" href="#プログラミングにおける依存型">プログラミングにおける依存型</a></h1>
<p>ほとんどの静的型付けプログラミング言語では、型の世界とプログラムの世界の間には隔たりが存在します。
型とプログラムはそれぞれ異なる文法を持ち、別々の時点で用いられます。
通常、型はコンパイル時にプログラムが特定の不変条件に従っていることを検証するために使われます。
一方プログラムは実行時に計算を行うために実装されます。
これらが相互作用する際は、型ケース演算子の「instance-of」チェックや、型チェッカーへのキャスト演算子によって実行時まで使用できない情報を提供する形で行われることが一般的です。
つまり、この相互作用では、型がプログラムの世界へ挿入され、限定された実行時の意味を持つようになるわけです。</p>
<p>しかし、Leanはこのような厳格な区分を設けていません。
Leanにおいては、プログラムが型を算出し、型にはプログラムを含むことができます。
プログラムを型に配置することにより、その完全な計算能力をコンパイル時に利用できますし、関数から型を返す能力により、型はプログラミングプロセスにおける第一級の市民となります。</p>
<p><em>依存型</em> とは、非型の式を含む型のことを意味します。
依存型の典型例としては、関数に名前付き引数を渡すことが挙げられます。
例えば、関数 <code>natOrStringThree</code> は、渡された <code>Bool</code> の値に応じて自然数か文字列のどちらかを返します。</p>
<pre><code class="language-lean">def natOrStringThree (b : Bool) : if b then Nat else String :=
  match b with
  | true =&gt; (3 : Nat)
  | false =&gt; &quot;three&quot;
</code></pre>
<p>依存型の他の例には以下のようなものがあります：</p>
<ul>
<li><a href="getting-to-know/polymorphism.html">ポリモーフィズムに関する導入セクション</a>には、引数の値に依存する関数の返り値の型をもつ <code>posOrNegThree</code> が含まれます。</li>
<li><a href="type-classes/pos.html#literal-numbers"><code>OfNat</code> 型クラス</a>は使われる具体的な自然数リテラルに依存します。</li>
<li>検証器の例で使われる <a href="functor-applicative-monad/applicative.html#validated-input"><code>CheckedInput</code> 構造体</a>は、検証が発生した年に依存します。</li>
<li><a href="functor-applicative-monad/applicative.html#subtypes">サブタイプ</a>は特定の値に対する命題を含んでいます。</li>
<li><a href="props-proofs-indexing.html">配列のインデックス指定</a>の正当性に関する全ての関心のある命題が、値を含む型であり、したがって依存型であるとされています。</li>
</ul>
<p>依存型は、型システムの能力を著しく拡張します。
引数の値に基づいて変化する戻り値の型を可能にし、その結果、他の型システムでは型付けが難しいプログラムを容易に作成することができます。
同時に、依存型は関数の返り値を制限する型シグネチャを可能にし、コンパイル時に強力な不変条件を強制することを許可します。</p>
<p>しかし、依存型を使ったプログラミングは非常に複雑になる可能性があり、関数型プログラミングを超えるスキルが必要になってきます。
表現豊かな仕様を満たすことは複雑となりがちで、実際には自らに束縛を課し、それによってプログラムを完成させることができないリスクもあります。
一方で、このプロセスを通じて新しい認識に到達することもありえ、それは達成可能な洗練された型によって表現されるでしょう。
この章では依存型プログラミングの表面をかい摘んでおり、それ自体が深いトピックで、本一冊に値する内容です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インデックス付き族"><a class="header" href="#インデックス付き族">インデックス付き族</a></h1>
<p>多相的帰納型は型引数を取ります。
例えば、<code>List</code> はリスト内のエントリの型を決定する引数を取り、<code>Except</code> は例外または値の型を決定する引数を取ります。
これらの型引数は、データ型の構造の中で同じであり、_パラメータ_と呼ばれています。</p>
<p>しかし、帰納型への引数がすべての構造で同じである必要はありません。
構造によって型への引数が異なる帰納型は、_インデックス付き族_と呼ばれ、変化する引数は_インデックス_と呼ばれます。
インデックス付き族の「こんにちは世界」は、リストの長さに加えてエントリの型を含むリストの型で、通常「ベクトル」と呼ばれます：</p>
<pre><code class="language-lean">inductive Vect (α : Type u) : Nat → Type u where
   | nil : Vect α 0
   | cons : α → Vect α n → Vect α (n + 1)
</code></pre>
<p>関数宣言は、コロンの前にいくつかの引数を取り、それが定義全体で利用可能であることを示します。また、コロンの後に引数を取り、それらにパターンマッチングしたいという意思を示したり、ケースバイケースで関数を定義します。
帰納的データ型も同様の原則を持っています：引数 <code>α</code> は、データ型宣言の先頭、コロンの前に名前付けされ、これは <code>Vect</code> のすべての出現で最初の引数として提供されなければならないパラメータであることを示しています。一方、<code>Nat</code> 引数はコロンの後に現れ、これはインデックスであり、場合によっては異なる可能性があることを示します。
実際には、<code>nil</code> と <code>cons</code> のコンストラクタ宣言での <code>Vect</code> の三つの出現は、最初の引数として <code>α</code> を一貫して提供していますが、二つ目の引数はそれぞれ異なります。</p>
<p><code>nil</code> の宣言は、それが型 <code>Vect α 0</code> のコンストラクタであることを述べています。
これは、<code>Vect.nil</code> を <code>Vect String 3</code> が期待される文脈で使用することは型エラーであることを意味します。ちょうど、<code>[1, 2, 3]</code> が <code>List String</code> を期待する文脈で型エラーであるように：</p>
<pre><code class="language-lean">example : Vect String 3 := Vect.nil
</code></pre>
<pre><code class="language-output error">type mismatch
  Vect.nil
has type
  Vect String 0 : Type
but is expected to have type
  Vect String 3 : Type
</code></pre>
<p>この例での <code>0</code> と <code>3</code> の不一致は、<code>0</code> と <code>3</code> が自体型ではないにも関わらず、他のどの型の不一致としても、全く同じ役割を果たしています。</p>
<p>インデックス付き族は、異なるインデックス値で異なるコンストラクタが使用可能になるため、型の_族_と呼ばれます。
ある意味では、インデックス付き族は型ではなく、関連する型のコレクションであり、インデックスの値を選択することによってコレクションから型が選ばれます。
<code>Vect</code> にインデックス <code>5</code> を選択すると、コンストラクタ <code>cons</code> のみが使用可能ですし、<code>0</code> を選択すると <code>nil</code> のみが使用可能になります。</p>
<p>インデックスがまだ不明である場合（例えば、それが変数であるために）、それが分かるまでどのコンストラクタも使用することができません。
長さ <code>n</code> を使用すると、<code>Vect.nil</code> も <code>Vect.cons</code> も使用できないため、変数 <code>n</code> は <code>0</code> か <code>n + 1</code> に一致する <code>Nat</code> を示すべきかわかりません：</p>
<pre><code class="language-lean">example : Vect String n := Vect.nil
</code></pre>
<pre><code class="language-output error">type mismatch
  Vect.nil
has type
  Vect String 0 : Type
but is expected to have type
  Vect String n : Type
</code></pre>
<pre><code class="language-lean">example : Vect String n := Vect.cons &quot;Hello&quot; (Vect.cons &quot;world&quot; Vect.nil)
</code></pre>
<pre><code class="language-output error">type mismatch
  Vect.cons &quot;Hello&quot; (Vect.cons &quot;world&quot; Vect.nil)
has type
  Vect String (0 + 1 + 1) : Type
but is expected to have type
  Vect String n : Type
</code></pre>
<p>リストの長さをその型の一部とすることは、型をより情報量の多いものにします。
例えば、<code>Vect.replicate</code> は指定された値のコピーが何個も含まれる <code>Vect</code> を作成する関数です。
これを正確に言う型は：</p>
<pre><code class="language-lean">def Vect.replicate (n : Nat) (x : α) : Vect α n := _
</code></pre>
<p>引数 <code>n</code> は結果の長さとして現れます。
アンダースコアのプレースホルダーに関連付けられたメッセージは、手がかりとなるタスクを述べています：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n : Nat
x : α
⊢ Vect α n
</code></pre>
<p>インデックス付き族を扱うとき、Leanがコンストラクタのインデックスが期待される型のインデックスと一致していることを確認できる時にのみ、コンストラクタを適用することができます。
しかし、どちらのコンストラクタにも <code>n</code> に一致するインデックスはありません—<code>nil</code> は <code>Nat.zero</code> に、そして <code>cons</code> は <code>Nat.succ</code> に一致します。
先述の型エラーの例のように、変数 <code>n</code> は引数として関数に提供される <code>Nat</code> に基づいて、いずれかの値になる可能性があります。
解決策は、パターンマッチングを使用して、両方の可能性のあるケースを考慮することです：</p>
<pre><code class="language-lean">def Vect.replicate (n : Nat) (x : α) : Vect α n :=
  match n with
  | 0 =&gt; _
  | k + 1 =&gt; _
</code></pre>
<p>期待される型に <code>n</code> が出現するので、<code>n</code> にパターンマッチングを行うことは、マッチの二つのケースで期待される型を_洗練_します。
最初のアンダースコアでは、期待される型は <code>Vect α 0</code> になっています：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n : Nat
x : α
⊢ Vect α 0
</code></pre>
<p>二つ目のアンダースコアでは、それは <code>Vect α (k + 1)</code> になっています：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n : Nat
x : α
k : Nat
⊢ Vect α (k + 1)
</code></pre>
<p>パターンマッチングが値の構造を発見するだけでなく、プログラムの型を洗練するとき、それは_依存型パターンマッチング_と呼ばれます。</p>
<p>洗練された型により、コンストラクタを適用することが可能になります。
最初のアンダースコアは <code>Vect.nil</code> にマッチし、二つ目は <code>Vect.cons</code> にマッチします：</p>
<pre><code class="language-lean">def Vect.replicate (n : Nat) (x : α) : Vect α n :=
  match n with
  | 0 =&gt; .nil
  | k + 1 =&gt; .cons _ _
</code></pre>
<p><code>.cons</code> の下の最初のアンダースコアは型 <code>α</code> であるべきです。
使用可能な <code>α</code> があります、すなわち <code>x</code>：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n : Nat
x : α
k : Nat
⊢ α
</code></pre>
<p>二つ目のアンダースコアは <code>Vect α k</code> であるべきで、これは <code>replicate</code> への再帰的な呼び出しによって生成されます：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n : Nat
x : α
k : Nat
⊢ Vect α k
</code></pre>
<p>これが <code>replicate</code> の最終定義です：</p>
<pre><code class="language-lean">def Vect.replicate (n : Nat) (x : α) : Vect α n :=
  match n with
  | 0 =&gt; .nil
  | k + 1 =&gt; .cons x (replicate k x)
</code></pre>
<p>関数を書くときに有益な情報提供をするだけでなく、<code>Vect.replicate</code> の情報量の多い型は、クライアントのコードがソースコードを読まなくても多くの予期しない関数を排除することを可能にします。
<code>List</code> に対する <code>replicate</code> のバージョンは、間違った長さのリストを生成するかもしれません：</p>
<pre><code class="language-lean">def List.replicate (n : Nat) (x : α) : List α :=
  match n with
  | 0 =&gt; []
  | k + 1 =&gt; x :: x :: replicate k x
</code></pre>
<p>しかし、<code>Vect.replicate</code> でこの間違いを犯すことは型エラーです：</p>
<pre><code class="language-lean">def Vect.replicate (n : Nat) (x : α) : Vect α n :=
  match n with
  | 0 =&gt; .nil
  | k + 1 =&gt; .cons x (.cons x (replicate k x))
</code></pre>
<pre><code class="language-output error">application type mismatch
  cons x (cons x (replicate k x))
argument
  cons x (replicate k x)
has type
  Vect α (k + 1) : Type ?u.1998
but is expected to have type
  Vect α k : Type ?u.1998
</code></pre>
<p>関数 <code>List.zip</code> は二つのリストを組み合わせることで、最初のリストの最初のエントリと二つ目のリストの最初のエントリをペアリングし、最初のリストの2番目のエントリを二つ目のリストの2番目のエントリとペアリングし、以下同様に続けます。
<code>List.zip</code> は米国オレゴン州の最も高い3つのピークとデンマークの最も高い3つのピークを組み合わせるために使用できます：</p>
<pre><code class="language-lean">[&quot;Mount Hood&quot;,
 &quot;Mount Jefferson&quot;,
 &quot;South Sister&quot;].zip [&quot;Møllehøj&quot;, &quot;Yding Skovhøj&quot;, &quot;Ejer Bavnehøj&quot;]
</code></pre>
<p>その結果は、3つのペアのリストです：</p>
<pre><code class="language-lean">[(&quot;Mount Hood&quot;, &quot;Møllehøj&quot;),
 (&quot;Mount Jefferson&quot;, &quot;Yding Skovhøj&quot;),
 (&quot;South Sister&quot;, &quot;Ejer Bavnehøj&quot;)]
</code></pre>
<p>リストの長さが異なる場合に何が起こるべきかはいくぶん明らかではありません。
多くの言語と同様に、Leanはリストの片方に余分なエントリがある場合、それを無視することを選択します。
例えば、オレゴン州で最も高い5つのピークの高さとデンマークで最も高い3つのピークの高さを組み合わせると、3つのペアが得られます。
特に、</p>
<pre><code class="language-lean">[3428.8, 3201, 3158.5, 3075, 3064].zip [170.86, 170.77, 170.35]
</code></pre>
<p>は、次のように評価されます</p>
<pre><code class="language-lean">[(3428.8, 170.86), (3201, 170.77), (3158.5, 170.35)]
</code></pre>
<p>このアプローチは常に答えを返すので便利ですが、リストが意図せず異なる長さを持っている場合にデータを失うリスクを伴います。
F#は異なるアプローチを取ります：そのバージョンの <code>List.zip</code> は長さが一致しないときに例外を投げます。この <code>fsi</code> セッションで見ることができます：</p>
<pre><code class="language-fsharp">&gt; List.zip [3428.8; 3201.0; 3158.5; 3075.0; 3064.0] [170.86; 170.77; 170.35];;
</code></pre>
<pre><code class="language-output error">System.ArgumentException: The lists had different lengths.
list2 is 2 elements shorter than list1 (Parameter 'list2')
   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?](String arg1, String arg2, Int32 diff) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 24
   at Microsoft.FSharp.Primitives.Basics.List.zipToFreshConsTail[a,b](FSharpList`1 cons, FSharpList`1 xs1, FSharpList`1 xs2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 918
   at Microsoft.FSharp.Primitives.Basics.List.zip[T1,T2](FSharpList`1 xs1, FSharpList`1 xs2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 929
   at Microsoft.FSharp.Collections.ListModule.Zip[T1,T2](FSharpList`1 list1, FSharpList`1 list2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/list.fs:line 466
   at &lt;StartupCode$FSI_0006&gt;.$FSI_0006.main@()
Stopped due to error
</code></pre>
<p>これは偶然情報を破棄することを避けますが、プログラムをクラッシュさせることにはそれ自体問題があります。
<code>Option</code> や <code>Except</code> モナドを使用した Lean の同等のものは、安全性の価値がないかもしれない負担を伴います。</p>
<p>しかし、<code>Vect</code> を使って、両方の引数が同じ長さであることを要求する型の <code>zip</code> バージョンを書くことができます：</p>
<pre><code class="language-lean">def Vect.zip : Vect α n → Vect β n → Vect (α × β) n
  | .nil, .nil =&gt; .nil
  | .cons x xs, .cons y ys =&gt; .cons (x, y) (zip xs ys)
</code></pre>
<p>この定義には <code>Vect.nil</code> または <code>Vect.cons</code> のどちらかがある場合にのみパターンがあり、Leanは「ケース不足」エラーなしで定義を受け入れます。これは <code>List</code> に対する類似の定義から結果として生じるものです：</p>
<pre><code class="language-lean">def List.zip : List α → List β → List (α × β)
  | [], [] =&gt; []
  | x :: xs, y :: ys =&gt; (x, y) :: zip xs ys
</code></pre>
<pre><code class="language-output error">missing cases:
(List.cons _ _), []
[], (List.cons _ _)
</code></pre>
<p>これは、最初のパターンで使用されるコンストラクタ、<code>nil</code> または <code>cons</code> が、長さ <code>n</code> について型チェッカーの知識を_洗練_するためです。
最初のパターンが <code>nil</code> の場合、型チェッカーはそれに加えて長さが <code>0</code> であったことをさらに決定できるので、2番目のパターンの唯一の可能な選択は <code>nil</code> です。
同様に、最初のパターンが <code>cons</code> の場合、型チェッカーは長さがいくつかの <code>Nat</code> <code>k</code> に対して <code>k+1</code> であったことを決定できるので、2番目のパターンの唯一の可能な選択は <code>cons</code> です。
実際に、<code>nil</code> と <code>cons</code> を一緒に使用するケースを追加すると型エラーになります、なぜなら長さが一致しないからです：</p>
<pre><code class="language-lean">def Vect.zip : Vect α n → Vect β n → Vect (α × β) n
  | .nil, .nil =&gt; .nil
  | .nil, .cons y ys =&gt; .nil
  | .cons x xs, .cons y ys =&gt; .cons (x, y) (zip xs ys)
</code></pre>
<pre><code class="language-output error">{{#example_out Examples/DependentTypesれは型エラーです。また、`nil`と`cons`を一緒に使用するパターンを追加するのも型エラーになります。これは長さが一致しないからです。長さの洗練が観察されるのは、`n`を明示的な引数にすることでです：
```lean
def Vect.zip : (n : Nat) → Vect α n → Vect β n → Vect (α × β) n
  | 0, .nil, .nil =&gt; .nil
  | k + 1, .cons x xs, .cons y ys =&gt; .cons (x, y) (zip k xs ys)
</code></pre>
<h2 id="練習問題-10"><a class="header" href="#練習問題-10">練習問題</a></h2>
<p>依存型とともにプログラミングを行う感覚を掴むには経験が必要であり、このセクションの練習問題は非常に重要です。
各練習問題については、コードを進めながら型チェッカーがどのような間違いを捉え、どのような間違いを捉えられないのかを試しながら体験してみることで、エラーメッセージへの感覚を養う良い方法です。</p>
<ul>
<li>
<p><code>Vect.zip</code>がオレゴン州の最高峰3つとデンマークの最高峰3つを組み合わせる際に正しい答えを出すかダブルチェックしてください。<code>List</code>のようなシンタックスシュガーが<code>Vect</code>にはないため、<code>oregonianPeaks : Vect String 3</code>と<code>danishPeaks : Vect String 3</code>を定義することから始めると役立つかもしれません。</p>
</li>
<li>
<p><code>(α → β) → Vect α n → Vect β n</code>の型を持つ関数<code>Vect.map</code>を定義してください。</p>
</li>
<li>
<p>各<code>Vect</code>のエントリを函数で一つずつ組み合わせる関数<code>Vect.zipWith</code>を定義します。
この関数には<code>(α → β → γ) → Vect α n → Vect β n → Vect γ n</code>という型があります。</p>
</li>
<li>
<p>ペアの<code>Vect</code>をペアの<code>Vect</code>に分割する関数<code>Vect.unzip</code>を定義してください。この関数には<code>Vect (α × β) n → Vect α n × Vect β n</code>という型があります。</p>
</li>
<li>
<p><code>Vect</code>の_終わり_にエントリを追加する関数<code>Vect.snoc</code>を定義してください。その型は<code>Vect α n → α → Vect α (n + 1)</code>であり、<code>#eval Vect.snoc (.cons &quot;snowy&quot; .nil) &quot;peaks&quot;</code>は<code>Vect.cons &quot;snowy&quot; (Vect.cons &quot;peaks&quot; (Vect.nil))</code>を生成するべきです。<code>snoc</code>という名前は、トラディショナルな関数型プログラミングの洒落であり、<code>cons</code>を逆にしたものです。</p>
</li>
<li>
<p><code>Vect</code>の順番を逆にする関数<code>Vect.reverse</code>を定義してください。</p>
</li>
<li>
<p>次の型を持つ関数<code>Vect.drop</code>を定義してください：<code>(n : Nat) → Vect α (k + n) → Vect α k</code>。
<code>#eval danishPeaks.drop 2</code>が<code>Vect.cons &quot;Ejer Bavnehøj&quot; (Vect.nil)</code>を生成することを確認することで動作を検証してください。</p>
</li>
<li>
<p><code>Vect</code>の最初の<code>n</code>エントリを返す<code>(n : Nat) → Vect α (k + n) → Vect α n</code>型の関数<code>Vect.take</code>を定義してください。例で動作することを確認してください。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宇宙デザインパターン"><a class="header" href="#宇宙デザインパターン">宇宙デザインパターン</a></h1>
<p>Leanでは、他の型を分類する<code>Type</code>、<code>Type 3</code>、<code>Prop</code>などの型は宇宙として知られています。
しかし、<em>宇宙</em> という用語は、Leanの型のサブセットを表すために使用されるデータ型と、そのデータ型のコンストラクタを実際の型に変換する関数を用いるデザインパターンにも使われます。
このデータ型の値は、それらの型の_コード_ と呼ばれます。</p>
<p>Leanの組み込みの宇宙のように、このパターンで実装された宇宙は、どのように実現されるかのメカニズムは異なるものの、使用可能な型の一部の集合を記述する型です。
Leanには、他の型を直接記述する<code>Type</code>、<code>Type 3</code>、<code>Prop</code>などの型が存在します。
この配置は <em>Russell流の宇宙</em> と呼ばれます。
このセクションで説明されているユーザー定義の宇宙は、その型をすべて_データ_ として表現し、これらのコードを真に実際の型に解釈する明示的な関数を含みます。
この配置は <em>Tarski流の宇宙</em> と呼ばれます。
依存型理論に基づいた言語のようにLeanの場合、通常はRussell流の宇宙が使用されますが、Tarski流の宇宙はこれらの言語でAPIを定義するための有用なパターンです。</p>
<p>カスタム宇宙を定義すると、APIで使用できる型の閉じたコレクションを選り分けることができます。
型のコレクションが閉じているため、コード上での再帰によりプログラムは宇宙の_任意_ の型で機能します。
カスタム宇宙の一例は、<code>Nat</code>を意味する<code>nat</code>、<code>Bool</code>を意味する<code>bool</code>といったコードがあります：</p>
<pre><code class="language-lean">inductive NatOrBool where
  | nat | bool

abbrev NatOrBool.asType (code : NatOrBool) : Type :=
  match code with
  | .nat =&gt; Nat
  | .bool =&gt; Bool
</code></pre>
<p>コードに対するパターンマッチングにより、型を洗練させることができます。ちょうど<code>Vect</code>のコンストラクタに対するパターンマッチングが期待される長さを洗練させるようにです。
例えば、この宇宙の型を文字列からデシリアライズするプログラムは次のように書けます：</p>
<pre><code class="language-lean">def decode (t : NatOrBool) (input : String) : Option t.asType :=
  match t with
  | .nat =&gt; input.toNat?
  | .bool =&gt;
    match input with
    | &quot;true&quot; =&gt; some true
    | &quot;false&quot; =&gt; some false
    | _ =&gt; none
</code></pre>
<p><code>t</code>に対する依存型のパターンマッチングにより、期待される結果型<code>t.asType</code>はそれぞれ<code>NatOrBool.nat.asType</code>および<code>NatOrBool.bool.asType</code>に洗練され、これらは実際の型<code>Nat</code>と<code>Bool</code>に計算されます。</p>
<p>コードは他のデータと同じように再帰可能です。
型<code>NestedPairs</code>は対と自然数の型の任意の可能なネスティングを符号化します：</p>
<pre><code class="language-lean">inductive NestedPairs where
  | nat : NestedPairs
  | pair : NestedPairs → NestedPairs → NestedPairs

abbrev NestedPairs.asType : NestedPairs → Type
  | .nat =&gt; Nat
  | .pair t1 t2 =&gt; asType t1 × asType t2
</code></pre>
<p>この場合、解釈関数<code>NestedPairs.asType</code>は再帰的です。
これは、宇宙の<code>BEq</code>を実装するためにコード上の再帰が必要であることを意味します：</p>
<pre><code class="language-lean">def NestedPairs.beq (t : NestedPairs) (x y : t.asType) : Bool :=
  match t with
  | .nat =&gt; x == y
  | .pair t1 t2 =&gt; beq t1 x.fst y.fst &amp;&amp; beq t2 x.snd y.snd

instance {t : NestedPairs} : BEq t.asType where
  beq x y := t.beq x y
</code></pre>
<p><code>NestedPairs</code>宇宙のすべての型にはすでに<code>BEq</code>インスタンスがありますが、インスタンス宣言のデータ型の可能性のあるすべてのケースを自動的にチェックすることはありません。なぜなら、<code>NestedPairs</code>のように無限に多くのケースがある可能性があるからです。
コード上での再帰に頼らずに直接<code>BEq</code>インスタンスに訴えようとすると、エラーが発生します：</p>
<pre><code class="language-lean">instance {t : NestedPairs} : BEq t.asType where
  beq x y := x == y
</code></pre>
<pre><code class="language-output error">failed to synthesize instance
  BEq (NestedPairs.asType t)
</code></pre>
<p>エラーメッセージの<code>t</code>は未知の型<code>NestedPairs</code>の値を意味します。</p>
<h2 id="型クラス-vs-宇宙"><a class="header" href="#型クラス-vs-宇宙">型クラス vs 宇宙</a></h2>
<p>型クラスでは、必要なインターフェースの実装がある限り、APIでオープンエンドの型コレクションを使用することができます。
ほとんどの場合、これが好ましいです。
APIのすべての使用事例を事前に予測することは困難であり、型クラスはライブラリーコードが元の著者が予想したよりも多くの型で利用されることを可能にする便利な方法です。</p>
<p>一方、Tarski流宇宙は、あらかじめ決められた型のコレクションでのみAPIを使用可能に制限します。
これはいくつかの状況で有用です：</p>
<ul>
<li>どの型が渡されているかによって関数が非常に異なる動作をするべきとき - 型そのものにパターンマッチすることはできませんが、型のコードにパターンマッチングをすることは許されています</li>
<li>外部システムが本質的に提供できるデータの型を限定し、余分な柔軟性が望まれていないとき</li>
<li>いくつかの操作の実装以上の型に関する追加の性質が必要なとき</li>
</ul>
<p>型クラスは、JavaやC#のインターフェースと同じ状況で多くの場合に有用ですが、Tarski流宇宙は封印クラスが使用される場面で有用ですが、通常の帰納的データ型では使用できない状況で有用です。</p>
<h2 id="有限型の宇宙"><a class="header" href="#有限型の宇宙">有限型の宇宙</a></h2>
<p>APIで使用できる型をあらかじめ決められたコレクションに制限することで、オープンエンドのAPIでは不可能な操作が可能になることがあります。例えば。通常は関数を等価比較することはできません。関数は同じ入力に対して同じ出力をマッピングするときに等しいとみなされるべきです。これを確認するには無限の時間がかかる場合があります。なぜなら型<code>Nat → Bool</code>の二つの関数を比較するには、それぞれの<code>Nat</code>に対して関数が同じ<code>Bool</code>を返すかどうかを確認する必要があるからです。</p>
<p>つまり、無限の型からの関数はそれ自体が無限です。関数をテーブルと見なすことができ、無限の引数型を持つ関数には囲む場合が示される各ケースを表すために無限に多くの行が必要です。しかし、有限の型からの関数にはテーブルに必要な行が有限になります。これにより、その関数を有限とすることができます。有限の引数型を持つ二つの関数は、すべての可能な引数を列挙して、それぞれの引数に対して関数を呼び出し、次いで結果を比較することにより、等価性をチェックすることができます。高階関数の等価性をチェックするには、与えられた型のすべての可能な関数を生成する必要があり、さらに各引数型の要素を戻り値型の各要素に写像できるように戻り値型も有限でなければならないことが必要です。これは速い方法ではありませんが、有限の時間で完了します。</p>
<p>一つの方法として有限型を宇宙で表すことができます：</p>
<pre><code class="language-lean">inductive Finite where
  | unit : Finite
  | bool : Finite
  | pair : Finite → Finite → Finite
  | arr : Finite → Finite → Finite

abbrev Finite.asType : Finite → Type
  | .unit =&gt; Unit
  | .bool =&gt; Bool
  | .pair t1 t2 =&gt; asType t1 × asType t2
  | .arr t1 t2 =&gt; asType t1 → asType t2
</code></pre>
<p>この宇宙では、コンストラクタ<code>arr</code>が関数型に対応し、<code>arr</code>ow（矢印）で書かれます。</p>
<p>この宇宙の二つの値を等価比較することは、<code>NestedPairs</code>宇宙とほぼ同じです。唯一重要な違いは<code>arr</code>のケースの追加で、これはヘルパー<code>Finite.enumerate</code>を使用して<code>t1</code>によってコード化された型からすべての値を生成し、二つの関数がすべての可能な入力に対して等しい結果を返すかどうかをチェックします：</p>
<pre><code class="language-lean">def Finite.beq (t : Finite) (x y : t.asType) : Bool :=
  match t with
  | .unit =&gt; true
  | .bool =&gt; x == y
  | .pair t1 t2 =&gt; beq t1 x.fst y.fst &amp;&amp; beq t2 x.snd y.snd
  | .arr t1 t2 =&gt;
    t1.enumerate.all fun arg =&gt; beq t2 (x arg) (y arg)
</code></pre>
<p>標準ライブラリ関数<code>List.all</code>は、リストのすべてのエントリで提供された関数が<code>true</code>を返すかどうかをチェックします。この関数は、ブーリアンの関数を等価比較するために使用することができます：</p>
<pre><code class="language-lean">#eval Finite.beq (.arr .bool .bool) (fun _ =&gt; true) (fun b =&gt; b == b)
</code></pre>
<pre><code class="language-output info">true
</code></pre>
<p>また標準ライブラリの関数を比較するために使用することができます：</p>
<pre><code class="language-lean">#eval Finite.beq (.arr .bool .bool) (fun _ =&gt; true) not
</code></pre>
<pre><code class="language-output info">false
</code></pre>
<p>関数合成などのツールを使って作成された関数を比較することもできます：</p>
<pre><code class="language-lean">#eval Finite.beq (.arr .bool .bool) id (not ∘ not)
</code></pre>
<pre><code class="language-output info">true
</code></pre>
<p>これは、<code>Finite</code>宇宙がライブラリーで作成された特別なアナローグでなく、Leanの_実際_ の関数型を符号化しているからです。</p>
<p><code>enumerate</code>の実装も<code>Finite</code>からのコードに対する再帰によります。</p>
<pre><code class="language-lean">  def Finite.enumerate (t : Finite) : List t.asType :=
    match t with
    | .unit =&gt; [()]
    | .bool =&gt; [true, false]
    | .pair t1 t2 =&gt; t1.enumerate.product t2.enumerate
    | .arr t1 t2 =&gt; t1.functions t2.enumerate
</code></pre>
<p><code>Unit</code>のケースでは、単一の値があります。
<code>Bool</code>のケースでは、返す値が二つあります（<code>true</code>と<code>false</code>）。
ペアのケースでは、結果は<code>t1</code>によってコード化される型の値と<code>t2</code>によってコード化される型の値のデカルト積になるべきです。
言い換えると、<code>t1</code>からのすべての値は<code>t2</code>からのすべての値と組にされるべきです。
ヘルパー関数<code>List.product</code>は通常の再帰関数で確かに書けますが、ここではアイデンティティモナドでの<code>for</code>を使って定義されています：</p>
<pre><code class="language-lean">def List.product (xs : List α) (ys : List β) : List (α × β) := Id.run do
  let mut out : List (α × β) := []
  for x in xs do
    for y in ys do
      out := (x, y) :: out
  pure out.reverse
</code></pre>
<p>最後に、関数のケースの<code>Finite.enumerate</code>は、引数としてターゲットするすべての戻り値のリストを取るヘルパー「<code>Finite.functions</code>」へと移譲します。</p>
<p>一般に、ある有限型から結果値のコレクションへのすべての関数を生成することは、その関数のテーブルを生成することと見なすことができます。
各関数は各入力に出力を割り当てるため、与えられた関数は\(k\)の可能な引数があるときにそのテーブルに\(k\)行があります。
各行が\(n\)の可能な出力のいずれかを選択できるため、\(n^k\)の潜在的な関数を生成することがあります。</p>
<p>再度、有限型からあるリストの値への関数を生成することは、有限型を記述するコードに対する再帰に依存しています：</p>
<pre><code class="language-lean">  def Finite.functions (t : Finite) (results : List α) : List (t.asType → α) :=
    match t with
</code></pre>
<p><code>Unit</code>からの関数のテーブルには一行含まれます。それは関数が提供される入力に基づいて異なる結果を選択できないからです。
これは各潜在的な入力に対して一つの関数を生成することを意味します。</p>
<pre><code class="language-lean">      | .unit =&gt;
        results.map fun r =&gt;
          fun () =&gt; r
</code></pre>
<p>結果値が\(n\)個あるとき、<code>Bool</code>からの関数には\(n^2\)種類があります。なぜなら各個別の<code>Bool → α</code>型の関数は、<code>Bool</code>を使って特定の<code>α</code>の二つのうちの一つを選択するからです：</p>
<pre><code class="language-lean">      | .bool =&gt;
        (results.product results).map fun (r1, r2) =&gt;
          fun
            | true =&gt; r1
            | false =&gt; r2
</code></pre>
<p>ペアからの関数を生成することはカリー化を活用することで達成できます。
ペアからの関数は、ペアの最初の要素を受け取り、ペアの二番目の要素を待っている関数を返す関数に変換することができます。
これにより、<code>Finite.functions</code>をこの場合に再帰的に使用することを可能にします：</p>
<pre><code class="language-lean">      | .pair t1 t2 =&gt;
        let f1s := t1.functions &lt;| t2.functions results
        f1s.map fun f =&gt;
          fun (x, y) =&gt;
            f x y
</code></pre>
<p>高階関数を生成することは少し頭の体操になります。各高階関数は、その引数として関数を取ります。この引数関数は入出力の振る舞いに基づいて他の関数から区別することができます。一般的に、高階関数は引数関数を可能な引数すべてに適用し、その結果に基づいたあらゆる可能な振る舞いを実行できます。これにより高階関数を構築する手段が示唆されます：</p>
<ul>
<li>引数関数自体のすべての可能な引数のリストから開始します。</li>
<li>可能な各引数について、引数関数を可能な引数に適用した結果の観察に基づいて発生する可能なすべての振る舞いを構築します。これは<code>Finite.functions</code>および残りの可能な引数に対する再帰を使用して行うことができます。なぜなら再帰の結果は、残りの可能な引数の観察に基づいた振る舞いを基にした機能を表しているからです。<code>Finite.functions</code>は現在の引数に対する観察に基づくこれらの実現方法をすべて構築します。</li>
<li>これらの観察に対する潜在的な振る舞いごとに、引数関数を現在の可能な引数に適用する高階関数を構築します。その結果は観察振る舞いに渡されます。</li>
<li>再帰の基底ケースは、各結果値に対して何も観察しない高階関数です―それは引数関数を無視し、単に結果値を返します。</li>
</ul>
<p>この再帰関数を直接定義することは、Leanが全体の関数が終了することを証明するのが不可能となる原因となります。しかし、より単純な形の再帰である_右折り畳み_を使うことによって、関数が終了することが明確となり終了チェッカーにそれを伝えることができます。右折り畳みは3つの引数を取ります：リストの頭をリストの尾に対する再帰の結果と結びつけるステップ関数、リストが空の時に返すデフォルト値、および処理するリスト。そしてそれはリストを解析し、リスト内の各<code>::</code>をステップ関数への呼び出しで置き換え、<code>[]</code>をデフォルト値で置き換えることで、基本的には：</p>
<pre><code class="language-lean">def List.foldr (f : α → β → β) (default : β) : List α → β
  | []     =&gt; default
  | a :: l =&gt; f a (foldr f default l)
</code></pre>
<p>リスト内の<code>Nat</code>の合計は<code>foldr</code>を使って計算できます：</p>
<pre><code class="language-lean">[1, 2, 3, 4, 5].foldr (· + ·) 0
===&gt;
(1 :: 2 :: 3 :: 4 :: 5 :: []).foldr (· + ·) 0
===&gt;
(1 + 2 + 3 + 4 + 5 + 0)
===&gt;
15
</code></pre>
<p><code>foldr</code>を使って、高階関数は以下のように作成されます：</p>
<pre><code class="language-lean">      | .arr t1 t2 =&gt;
        let args := t1.enumerate
        let base :=
          results.map fun r =&gt;
            fun _ =&gt; r
        args.foldr
          (fun arg rest =&gt;
            (t2.functions rest).map fun more =&gt;
              fun f =&gt; more (f arg) f)
          base
</code></pre>
<p><code>Finite.Functions</code>の完全な定義は次のとおりです：</p>
<pre><code class="language-lean">  def Finite.functions (t : Finite) (results : List α) : List (t.asType → α) :=
    match t with
      | .unit =&gt;
        results.map fun r =&gt;
          fun () =&gt; r
      | .bool =&gt;
        (results.product results).map fun (r1, r2) =&gt;
          fun
            | true =&gt; r1
            | false =&gt; r2
      | .pair t1 t2 =&gt;
        let f1s := t1.functions &lt;| t2.functions results
        f1s.map fun f =&gt;
          fun (x, y) =&gt;
            f x y
      | .arr t1 t2 =&gt;
        let args := t1.enumerate
        let base :=
          results.map fun r =&gt;
            fun _ =&gt; r
        args.foldr
          (fun arg rest =&gt;
            (t2.functions rest).map fun more =&gt;
              fun f =&gt; more (f arg) f)
          base
</code></pre>
<p><code>Finite.enumerate</code>と<code>Finite.functions</code>は互いに呼び出されるので、<code>mutual</code>ブロック内で定義されなければなりません。言い換えれば、<code>Finite.enumerate</code>の定義の直前に<code>mutual</code>キーワードがあります：</p>
<pre><code class="language-lean">mutual
  def Finite.enumerate (t : Finite) : List t.asType :=
    match t with
</code></pre>
<p>そして<code>Finite.functions</code>の定義の直後に<code>end</code>キーワードがあります：</p>
<pre><code class="language-lean">      | .arr t1 t2 =&gt;
        let args := t1.enumerate
        let base :=
          results.map fun r =&gt;
            fun _ =&gt; r
        args.foldr
          (fun arg rest =&gt;
            (t2.functions rest).map fun more =&gt;
              fun f =&gt; more (f arg) f)
          base
end
</code></pre>
<p>このアルゴリズムは機能の比較には特に実用的ではありません。チェックするケースの数は指数関数的に増加し、<code>((Bool × Bool) → Bool) → Bool</code>のような単純な型でさえ65536個の異なる関数を説明します。なぜこんなに多くありますか？上述の理由に基づいて、型\( T \)によって記述される値の数を表すために\( \left| T \right| \)を使うと、
\[ \left| \left( \left( \mathtt{Bool} \times \mathtt{Bool} \right) \rightarrow \mathtt{Bool} \right) \rightarrow \mathtt{Bool} \right| \]
は
\[ \left|\mathrm{Bool}\right|^{\left| \left( \mathtt{Bool} \times \mathtt{Bool} \right) \rightarrow \mathtt{Bool} \right| }, \]
であり、それは
\[ 2^{2^{\left| \mathtt{Bool} \times \mathtt{Bool} \right| }}, \]
つまり
\[ 2^{2^4} \]
または65536です。
ネストされた指数関数は急速に増加し、多くの高階関数が存在します。</p>
<h2 id="練習問題-11"><a class="header" href="#練習問題-11">練習問題</a></h2>
<ul>
<li><code>Finite</code>によって記述される型にある任意の値を文字列に変換する関数を書いてください。関数はそのテーブルとして表されるべきです。</li>
<li><code>Finite</code>と<code>Finite.beq</code>に空の型<code>Empty</code>を追加してください。</li>
<li><code>Finite</code>と<code>Finite.beq</code>に<code>Option</code>を追加してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="実例-型指定されたクエリ"><a class="header" href="#実例-型指定されたクエリ">実例: 型指定されたクエリ</a></h1>
<p>インデックス付きファミリーは、他の言語に似せて設計されることになるAPIの構築に非常に有用です。
これらは、不正なHTMLを生成することができないHTMLコンストラクタのライブラリを書くため、設定ファイルフォーマットの特定のルールをエンコードするため、または複雑なビジネスの制約をモデル化するために使用できます。
このセクションでは、Leanを使用して関係代数のサブセットをインデックス付きファミリを使ってエンコードする方法、およびそれがより強力なデータベースクエリ言語の構築に使用することができるテクニックを簡単にデモンストレーションする内容を説明します。</p>
<p>このサブセットでは、フィールド名の非交差性のような要件を実施するために型システムを使用し、スキーマを値の型に反映させるために型レベルの計算を使用します。
しかしながら、このシステムは現実的ではありません - データベースはリンクリストのリンクリストとして表され、型システムはSQLのそれよりもずっと単純であり、関係代数の演算子は本当にSQLのそれには一致しません。
しかし、有用な原則やテクニックを示すのに十分な大きさです。</p>
<h2 id="データの宇宙"><a class="header" href="#データの宇宙">データの宇宙</a></h2>
<p>この関係代数では、列に含まれることができる基本データは、型 <code>Int</code>、<code>String</code>、<code>Bool</code> となり、これらは宇宙 <code>DBType</code> によって記述されます：</p>
<pre><code class="language-lean">inductive DBType where
  | int | string | bool

abbrev DBType.asType : DBType → Type
  | .int =&gt; Int
  | .string =&gt; String
  | .bool =&gt; Bool
</code></pre>
<p><code>asType</code> を使用すると、これらのコードが型のために使用されることができます。
例えば：</p>
<pre><code class="language-lean">#eval (&quot;Mount Hood&quot; : DBType.string.asType)
</code></pre>
<pre><code class="language-output info">&quot;Mount Hood&quot;
</code></pre>
<p>形容されたデータベースのタイプのいずれかの値について平等を比較することが可能です。
しかし、これをLeanに説明するには少し手間がかかります。
単に <code>BEq</code> を直接使用すると失敗します：</p>
<pre><code class="language-lean">def DBType.beq (t : DBType) (x y : t.asType) : Bool :=
  x == y
</code></pre>
<pre><code class="language-output info">failed to synthesize instance
  BEq (asType t)
</code></pre>
<p>ネストされたペアの宇宙と同様に、型クラス検索は自動的に <code>t</code> の値の各可能性をチェックしません
解決策は、<code>x</code> および <code>y</code> の型を洗練させるためにパターンマッチングを使用することです：</p>
<pre><code class="language-lean">def DBType.beq (t : DBType) (x y : t.asType) : Bool :=
  match t with
  | .int =&gt; x == y
  | .string =&gt; x == y
  | .bool =&gt; x == y
</code></pre>
<p>この関数のバージョンでは、<code>x</code> および <code>y</code> はそれぞれのケースにおいて <code>Int</code>、<code>String</code>、<code>Bool</code> の型を持ち、これらの型はすべて <code>BEq</code> インスタンスを持っています。
<code>dbEq</code> の定義は、コードによって記述された型の <code>BEq</code> インスタンスを定義するために使用することができます：</p>
<pre><code class="language-lean">instance {t : DBType} : BEq t.asType where
  beq := t.beq
</code></pre>
<p>これはコード自体のインスタンスと同じではありません：</p>
<pre><code class="language-lean">instance : BEq DBType where
  beq
    | .int, .int =&gt; true
    | .string, .string =&gt; true
    | .bool, .bool =&gt; true
    | _, _ =&gt; false
</code></pre>
<p>前者のインスタンスでは、コードによって記述された型から描画された値を比較することを可能にしますが、後者はコード自体の比較を可能にします。</p>
<p><code>Repr</code> インスタンスは、同じテクニックを使用して書くことができます。
<code>Repr</code> クラスのメソッドは <code>reprPrec</code> と呼ばれるのは、値を表示するときに演算子の優先順位のようなものを考慮に入れるように設計されているためです。
型を依存パターンマッチングによって洗練させることによって、<code>Int</code>、<code>String</code>、<code>Bool</code> の <code>Repr</code> インスタンスの <code>reprPrec</code> メソッドを使用することができます：</p>
<pre><code class="language-lean">instance {t : DBType} : Repr t.asType where
  reprPrec :=
    match t with
    | .int =&gt; reprPrec
    | .string =&gt; reprPrec
    | .bool =&gt; reprPrec
</code></pre>
<h2 id="スキーマとテーブル"><a class="header" href="#スキーマとテーブル">スキーマとテーブル</a></h2>
<p>スキーマは、データベースの各列の名前とタイプを記述します：</p>
<pre><code class="language-lean">structure Column where
  name : String
  contains : DBType

abbrev Schema := List Column
</code></pre>
<p>実際には、スキーマは表の行を記述する宇宙と見なすことができます。
空のスキーマは単位型を記述し、単一列を持つスキーマはその値を単独で記述し、少なくとも二つの列を持つスキーマはタプルによって表されます：</p>
<pre><code class="language-lean">abbrev Row : Schema → Type
  | [] =&gt; Unit
  | [col] =&gt; col.contains.asType
  | col1 :: col2 :: cols =&gt; col1.contains.asType × Row (col2::cols)
</code></pre>
<p><a href="dependent-types/../getting-to-know/polymorphism.html#Prod">多様体型についての初期セクション</a>で説明されているように、Leanの積型とタプルは右結合です。
これはネストされたペアが普通のフラットタプルと等価であることを意味します。</p>
<p>テーブルは、共有スキーマを持つ行のリストです：</p>
<pre><code class="language-lean">abbrev Table (s : Schema) := List (Row s)
</code></pre>
<p>例えば、山の頂上への訪問の日記は、スキーマ <code>peak</code> を用いて表されます：</p>
<pre><code class="language-lean">abbrev peak : Schema := [
  ⟨&quot;name&quot;, DBType.string⟩,
  ⟨&quot;location&quot;, DBType.string⟩,
  ⟨&quot;elevation&quot;, DBType.int⟩,
  ⟨&quot;lastVisited&quot;, .int⟩
]
</code></pre>
<p>この書籍の著者による、訪問された頂上の選抜は通常のタプルリストとして現れます：</p>
<pre><code class="language-lean">def mountainDiary : Table peak := [
  (&quot;Mount Nebo&quot;,       &quot;USA&quot;,     3637, 2013),
  (&quot;Moscow Mountain&quot;,  &quot;USA&quot;,     1519, 2015),
  (&quot;Himmelbjerget&quot;,    &quot;Denmark&quot;,  147, 2004),
  (&quot;Mount St. Helens&quot;, &quot;USA&quot;,     2549, 2010)
]
</code></pre>
<p>別の例は、滝とそれらへの訪問の日記で構成されています：</p>
<pre><code class="language-lean">abbrev waterfall : Schema := [
  ⟨&quot;name&quot;, .string⟩,
  ⟨&quot;location&quot;, .string⟩,
  ⟨&quot;lastVisited&quot;, .int⟩
]

def waterfallDiary : Table waterfall := [
  (&quot;Multnomah Falls&quot;, &quot;USA&quot;, 2018),
  (&quot;Shoshone Falls&quot;,  &quot;USA&quot;, 2014)
]
</code></pre>
<h3 id="再帰と宇宙再訪"><a class="header" href="#再帰と宇宙再訪">再帰と宇宙、再訪</a></h3>
<p>行をタプルとして便利に構成するという事実には、コストが伴います：二つのベースケースを別々に扱うという <code>Row</code> の事実は、<code>Row</code> を使用する型で定義され、コード（つまり、スキーマ）上で再帰的に定義された関数は同じ区別を行う必要があります。
ここで問題になるケースの一つは、スキーマ上での再帰を使用して行の平等性を検証する関数を定義する平等チェックです。
この例はLeanの型チェッカーを通過しません：</p>
<pre><code class="language-lean">def Row.bEq (r1 r2 : Row s) : Bool :=
  match s with
  | [] =&gt; true
  | col::cols =&gt;
    match r1, r2 with
    | (v1, r1'), (v2, r2') =&gt;
      v1 == v2 &amp;&amp; bEq r1' r2'
</code></pre>
<pre><code class="language-output error">type mismatch
  (v1, r1')
has type
  ?m.6559 × ?m.6562 : Type (max ?u.6571 ?u.6570)
but is expected to have type
  Row (col :: cols) : Type
</code></pre>
<p>問題は、パターン <code>col :: cols</code> が行の型を十分に洗練していないためです。
これは、Leanがまだ <code>Row</code> の定義の <code>[col]</code> シングルトンパターンまたは <code>col1 :: col2 :: cols</code> パターンのどちらが一致したかを判断できないため、<code>Row</code> への呼び出しはペア型に縮小しないためです。
解決策は、<code>Row</code> の構造を <code>Row.bEq</code> の定義に反映することです：</p>
<pre><code class="language-lean">def Row.bEq (r1 r2 : Row s) : Bool :=
  match s with
  | [] =&gt; true
  | [_] =&gt; r1 == r2
  | _::_::_ =&gt;
    match r1, r2 with
    | (v1, r1'), (v2, r2') =&gt;
      v1 == v2 &amp;&amp; bEq r1' r2'

instance : BEq (Row s) where
  beq := Row.bEq
</code></pre>
<p>他のコンテキストとは異なり、型に出現する関数は、その入力/出力動作のみの観点からのみ考慮されるわけではありません。
これらの型を使用するプログラムは、その構造が型レベル関数で使用されるパターンマッチングと再帰的行動と一致するように強制されます。
依存型プログラミングの大きな部分は、適切な型レベルの関数を選択し、それに正しい計算動作をすることです。</p>
<h3 id="列ポインタ"><a class="header" href="#列ポインタ">列ポインタ</a></h3>
<p>いくつかのクエリは、ある特定の列がスキーマに含まれている場合にのみ意味があります。
例えば、高度が1000メートル以上の山を返すクエリは、整数を含む <code>&quot;elevation&quot;</code> 列があるスキーマのコンテキストでのみ意味があります。
スキーマが特定の列を含むことを示す一つの方法は、それに直接ポインタを提供することであり、ポインタをインデックス付きファミリとして定義することで無効なポインタを除外することが可能です。</p>
<p>列がスキーマに存在するには二つの方法があります：それはスキーマの始まりにあるか、それ以降のスキーマのどこかにあります。
最終的に、列がスキーマの後半にある場合、それはスキーマのいくつかの尾部の始まりになります。</p>
<p>インデックス付きファミリ <code>HasCol</code> は、仕様をLeanコードに翻訳したものです：</p>
<pre><code class="language-lean">inductive HasCol : Schema → String → DBType → Type where
  | here : HasCol (⟨name, t⟩ :: _) name t
  | there : HasCol s name t → HasCol (_ :: s) name t
</code></pre>
<p>ファミリーの三つの引数はスキーマ、列名、およびそのタイプです。
すべてがインデックスですが、列名とタイプの後にスキーマを置くために引数を並べ替えることで、名前とタイプをパラメータにすることができます。
コンストラクタ <code>here</code> は、スキーマが望ましい名前とタイプを持つ列 <code>⟨name, t⟩</code> で始まるときに使用することができます。これはスキーマの最初の列へのポインタであり、最初の列が望ましい名前とタイプを持っているときにのみ使用できます。
コンストラクタ <code>there</code> は、より小さいスキーマへのポインタを一つの列をそれに付け加えたスキーマへのポインタに変換します。</p>
<p><code>&quot;elevation&quot;</code> が <code>peak</code> の三番目の列であるため、<code>there</code> を使って最初の二つの列を過ぎて探すことができます。その後、それは最初の列です。</p>
<p>Continue translating...</p>
<div style="break-before: page; page-break-before: always;"></div><p>以下は、指定された <code>.md</code> ファイルを日本語に翻訳したものです：</p>
<h1 id="インデックスパラメータおよびユニバースレベル"><a class="header" href="#インデックスパラメータおよびユニバースレベル">インデックス、パラメータ、およびユニバースレベル</a></h1>
<p>帰納型のインデックスとパラメータの区別は、構成要素の間で変化するかしないかという型の引数を記述する方法以上のものです。
帰納型への引数がパラメータなのかインデックスなのかは、それらのユニバースレベルの関係を決定する時にも重要です。
特に、帰納型はパラメータと同じユニバースレベルを持つことができますが、インデックスよりも大きいユニバースにある必要があります。
この制約は、Leanが定理証明者であると同時にプログラミング言語として使われるために必要です—これがないと、Leanの論理は矛盾をおこします。
エラーメッセージを試すことは、これらのルールを示すだけでなく、型の引数がパラメータなのかインデックスなのかを決定する正確なルールを説明する良い方法です。</p>
<p>一般的に、帰納型の定義はそのパラメータをコロンの前に、そしてそのインデックスをコロンの後に取ります。
パラメータは関数引数のように名前を与えられますが、インデックスはその型のみが記述されます。
これは <code>Vect</code> の定義で見ることができます：</p>
<pre><code class="language-lean">inductive Vect (α : Type u) : Nat → Type u where
   | nil : Vect α 0
   | cons : α → Vect α n → Vect α (n + 1)
</code></pre>
<p>この定義では、<code>α</code> はパラメータであり、<code>Nat</code> はインデックスです。
パラメータは定義全体を通じて参照することができます（例えば、<code>Vect.cons</code> はその最初の引数の型として <code>α</code> を使用します）、しかし常に一貫して使用されなければなりません。
インデックスは変わることを期待されているため、データ型定義の先頭で引数として提供されるのではなく、各構造体で個別の値が割り当てられます。</p>
<p>パラメータを持つ非常にシンプルなデータ型は <code>WithParameter</code> です：</p>
<pre><code class="language-lean">inductive WithParameter (α : Type u) : Type u where
  | test : α → WithParameter α
</code></pre>
<p>ユニバースレベル <code>u</code> はパラメータと帰納型自体のために使われますが、それがパラメータがデータ型のユニバースレベルを増加させないことを示しています。
同様に、複数のパラメータが存在する場合、帰納型は最大のユニバースレベルを受け取ります：</p>
<pre><code class="language-lean">inductive WithTwoParameters (α : Type u) (β : Type v) : Type (max u v) where
  | test : α → β → WithTwoParameters α β
</code></pre>
<p>パラメータがデータ型のユニバースレベルを増加させないので、取り扱うのがより便利です。
Leanはコロンの後（インデックスとして記述されていますが）に記述されたような引数がパラメータのように使用される場合にそれをパラメータに変換しようとします：
以下の両方の帰納データ型は、コロンの後にパラメータを記述しています：</p>
<pre><code class="language-lean">inductive WithParameterAfterColon : Type u → Type u where
  | test : α → WithParameterAfterColon α

inductive WithParameterAfterColon2 : Type u → Type u where
  | test1 : α → WithParameterAfterColon2 α
  | test2 : WithParameterAfterColon2 α
</code></pre>
<p>パラメータが最初のデータ型宣言で名前が付けられていない場合、それは各構造体で違う名前を使用することができますが、それらは一貫して使用されなければなりません。
次の宣言は受け入れられます：</p>
<pre><code class="language-lean">inductive WithParameterAfterColonDifferentNames : Type u → Type u where
  | test1 : α → WithParameterAfterColonDifferentNames α
  | test2 : β → WithParameterAfterColonDifferentNames β
</code></pre>
<p>しかし、この柔軟性はパラメータの名前を明示的に宣言するデータ型には及ばないものです：</p>
<pre><code class="language-lean">inductive WithParameterBeforeColonDifferentNames (α : Type u) : Type u where
  | test1 : α → WithParameterBeforeColonDifferentNames α
  | test2 : β → WithParameterBeforeColonDifferentNames β
</code></pre>
<pre><code class="language-output error">inductive datatype parameter mismatch
  β
expected
  α
</code></pre>
<p>同様に、インデックスに名前を付けようとするとエラーが発生します：</p>
<pre><code class="language-lean">inductive WithNamedIndex (α : Type u) : Type (u + 1) where
  | test1 : WithNamedIndex α
  | test2 : WithNamedIndex α → WithNamedIndex α → WithNamedIndex (α × α)
</code></pre>
<pre><code class="language-output error">inductive datatype parameter mismatch
  α × α
expected
  α
</code></pre>
<p>適切なユニバースレベルを使用し、コロンの後にインデックスを配置することにより、受け入れられる宣言が結果します：</p>
<pre><code class="language-lean">inductive WithIndex : Type u → Type (u + 1) where
  | test1 : WithIndex α
  | test2 : WithIndex α → WithIndex α → WithIndex (α × α)
</code></pre>
<p>Leanは時々、帰納型宣言のコロンの後の引数が全ての構造体で一貫して使用され、どのインデックスの後ろにも来ない場合にパラメータであると判断できますが、全てのパラメータはインデックスの前になければなりません。
インデックスの後にパラメータを置くことを試みると、引数はインデックスと見なされることになり、その結果、データ型のユニバースレベルが増加する必要があります：</p>
<pre><code class="language-lean">inductive ParamAfterIndex : Nat → Type u → Type u where
  | test1 : ParamAfterIndex 0 γ
  | test2 : ParamAfterIndex n γ → ParamAfterIndex k γ → ParamAfterIndex (n + k) γ
</code></pre>
<pre><code class="language-output error">invalid universe level in constructor 'ParamAfterIndex.test1', parameter 'γ' has type
  Type u
at universe level
  u+2
it must be smaller than or equal to the inductive datatype universe level
  u+1
</code></pre>
<p>パラメータは型である必要はありません。
次の例は、<code>Nat</code> のような普通のデータ型がパラメータとして使用できることを示しています：</p>
<pre><code class="language-lean">inductive NatParam (n : Nat) : Nat → Type u where
  | five : NatParam 4 5
</code></pre>
<pre><code class="language-output error">inductive datatype parameter mismatch
  4
expected
  n
</code></pre>
<p>提案されている <code>n</code> を使用すると、宣言が受け入れられます：</p>
<pre><code class="language-lean">inductive NatParam (n : Nat) : Nat → Type u where
  | five : NatParam n 5
</code></pre>
<p>これらの実験から何が結論付けられるでしょうか？
パラメータとインデックスのルールは以下の通りです：</p>
<ol>
<li>各構成要素の型でパラメータは同じように使われなければなりません。</li>
<li>全てのパラメータは全てのインデックスの前になければなりません。</li>
<li>定義されているデータ型のユニバースレベルは、最も大きいパラメータと同じかそれ以上でなければならず、最も大きいインデックスより厳密に大きくなければなりません。</li>
<li>コロンの前に書かれた名前のある引数は常にパラメータであり、コロンの後の引数は通常インデックスです。Leanはコロンの後の引数の使用が一貫している場合、それをパラメータにすると判断するかもしれませんが、それがインデックスの後ろに来ない場合です。</li>
</ol>
<p>疑わしい場合、Leanのコマンド <code>#print</code> を使用して帰納型引数のうちどれがパラメータであるかをチェックできます。
例えば、<code>Vect</code> の場合、パラメータの数が1であることを指摘しています：</p>
<pre><code class="language-lean">#print Vect
</code></pre>
<pre><code class="language-output info">inductive Vect.{u} : Type u → Nat → Type u
number of parameters: 1
constructors:
Vect.nil : {α : Type u} → Vect α 0
Vect.cons : {α : Type u} → {n : Nat} → α → Vect α n → Vect α (n + 1)
</code></pre>
<p>データ型に引数の順番を決める際には、どの引数がパラメータでどの引数がインデックスであるべきかを考えることが重要です。
できるだけ多くの引数をパラメータにすることはユニバースレベルを制御下に保つのに役立ち、これにより複雑なプログラムがタイプチェックしやすくなることがあります。
これを可能にする一つの方法は、引数リストで全てのパラメータが全てのインデックスの前に来るようにすることです。</p>
<p>さらに、Leanがコロンの後の引数がパラメータであることを使用法によって決定できるにもかかわらず、パラメータを明確な名前で書くことは良い考えです。
これにより、読者に意図が明確になり、構造体間で引数が間違って不一致で使用されていた場合にLeanがエラーを報告することになります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依存型を使ったプログラミングの落とし穴"><a class="header" href="#依存型を使ったプログラミングの落とし穴">依存型を使ったプログラミングの落とし穴</a></h1>
<p>依存型の柔軟性により、型の言語が十分に表現力を持ち、それほど表現力のない型システムでは記述できない変化を記述できるため、より有用なプログラムが型チェッカーによって受け入れられます。
同時に、依存型が非常に細かい仕様を表現できることにより、より多くのバグを含むプログラムが型チェッカーにより拒否されます。
この力は、コストがかかります。</p>
<p>型を返す関数（<code>Row</code>など）の内部と、それらが生成する型との密接な結合は、より大きな難しさの一例です。関数を型に使用する際に、その関数のインターフェースと実装の区別が崩れ始めます。
通常、型シグネチャや関数の入出力動作を変えない限り、リファクタリングはすべて有効です。
関数は、より効率的なアルゴリズムやデータ構造を使用するように書き換えることができ、バグを修正し、コードの明快さを改善しても、クライアントコードを壊さずに済むのです。
ただし、関数を型に使用した場合、関数の実装の内部が型の一部となり、他のプログラムへの_インターフェース_の一部となります。</p>
<p>例として、<code>Nat</code>上の加算の次の二つの実装を考えてみましょう。
<code>Nat.plusL</code>は最初の引数に対して再帰的です：</p>
<pre><code class="language-lean">def Nat.plusL : Nat → Nat → Nat
  | 0, k =&gt; k
  | n + 1, k =&gt; plusL n k + 1
</code></pre>
<p>一方、<code>Nat.plusR</code>は二番目の引数に対して再帰的です：</p>
<pre><code class="language-lean">def Nat.plusR : Nat → Nat → Nat
  | n, 0 =&gt; n
  | n, k + 1 =&gt; plusR n k + 1
</code></pre>
<p>加算の両実装は基本となる数学的概念に忠実であり、同じ引数を与えられると同じ結果を返します。</p>
<p>しかし、これらの二つの実装は型に使用される際にはかなり異なるインターフェースを提示します。
例として、二つの<code>Vect</code>を連結する関数を考えてみましょう。
この関数は、引数の長さの合計が判るような長さの<code>Vect</code>を返すべきです。
<code>Vect</code>は本質的には型がより情報豊富な<code>List</code>なので、<code>List.append</code>と全く同じように、最初の引数にパターンマッチを使い再帰的に関数を書くのは理にかなっています。
型シグネチャと、プレースホルダーを指し示す初期のパターンマッチから始めると、次の二つのメッセージが出ます：</p>
<pre><code class="language-lean">def appendL : Vect α n → Vect α k → Vect α (n.plusL k)
  | .nil, ys =&gt; _
  | .cons x xs, ys =&gt; _
</code></pre>
<p>最初のメッセージは<code>nil</code>のケースで、プレースホルダーを<code>plusL 0 k</code>の長さを持つ<code>Vect</code>に置き換えるべきだと述べています：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)
</code></pre>
<p>二番目のメッセージは<code>cons</code>のケースで、プレースホルダーを<code>plusL (n✝ + 1) k</code>の長さを持つ<code>Vect</code>に置き換えるべきだと述べています：</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k n✝ : Nat
x : α
xs : Vect α n✝
ys : Vect α k
⊢ Vect α (Nat.plusL (n✝ + 1) k)
</code></pre>
<p><code>n</code>の後の記号を_ダガー_と呼び、Leanが内部的に発明した名前を示すために使用されます。
内部で、最初の<code>Vect</code>に対するパターンマッチは、構成要素<code>cons</code>にインデックス<code>n + 1</code>があり、<code>Vect</code>の尾部が長さ<code>n</code>を持っているため、第一の<code>Nat</code>の値を洗練させました。
ここで、<code>n✝</code>は引数<code>n</code>より一つ小さい<code>Nat</code>です。</p>
<h2 id="素性の等価性definitional-equality"><a class="header" href="#素性の等価性definitional-equality">素性の等価性（Definitional Equality）</a></h2>
<p><code>plusL</code>の定義にはパターンケース<code>0, k =&gt; k</code>があります。
これは最初のプレースホルダーで使われる長さに適用されるため、プレースホルダーの型<code>Vect α (Nat.plusL 0 k)</code>を<code>Vect α k</code>と書くこともできます。
同様に、<code>plusL</code>にはパターンケース<code>n + 1, k =&gt; plusN n k + 1</code>が含まれます。
これにより、第二のプレースホルダーの型は同様に<code>Vect α (plusL n✝ k + 1)</code>と書くことができます。</p>
<p>舞台裏で何が起こっているのかを明らかにする最初のステップは、<code>Nat</code>の引数を明示的に書くことです。これはエラーメッセージをダガー無しにすることにもつながります。なぜなら今プログラムの中で名前が明示的に書かれるからです：</p>
<pre><code class="language-lean">def appendL : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusL k)
  | 0, k, .nil, ys =&gt; _
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusL (n + 1) k)
</code></pre>
<p>プレースホルダーに型の簡単なバージョンを注釈すると、型エラーが発生しないため、プログラムに書かれた型はLean自身が見つけた型に等価です：</p>
<pre><code class="language-lean">def appendL : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusL k)
  | 0, k, .nil, ys =&gt; (_ : Vect α k)
  | n + 1, k, .cons x xs, ys =&gt; (_ : Vect α (n.plusL k + 1))
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusL n k + 1)
</code></pre>
<p>第一のケースでは<code>Vect α k</code>を要求し、<code>ys</code>はその型です。
これは、空のリストを他のリストに追加するとその他のリストが返されるという方法と平行しています。
最初のプレースホルダーの代わりに<code>ys</code>を入れることで、埋められるべき残り一つのプレースホルダー以外のプログラムが出来上がります：</p>
<pre><code class="language-lean">def appendL : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusL k)
  | 0, k, .nil, ys =&gt; ys
  | n + 1, k, .cons x xs, ys =&gt; (_ : Vect α (n.plusL k + 1))
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusL n k + 1)
</code></pre>
<p>ここで非常に重要なことが起きています。
<code>Nat.plusL 0 k</code>が期待されるコンテキストで<code>Vect α k</code>が受け取られました。
しかし、<code>Nat.plusL</code>は<code>abbrev</code>ではないので、型チェック中に実行されるかのようには見えません。
別のことが起きています。</p>
<p>何が起きているのかを理解する鍵は、Leanは型チェック中に<code>abbrev</code>を展開するだけではないということです。
また、二つの型が互いに等価かどうかをチェックするときに計算を行うことができるため、一方の型の式を他方の型が期待されるコンテキストで使用することができます。
この性質は_素性の等価性_と呼ばれ、それは微妙です。</p>
<p>確かに、書かれた内容が同一の二つの型は素性の等価性と見なされるべきです。<code>Nat</code>と<code>Nat</code>、または<code>List String</code>と<code>List String</code>は等しいと考えられるべきです。
異なるデータ型から構築された任意の二つの具体的な型は等しくありませんので、<code>List Nat</code>は<code>Int</code>と等しくありません。
また、内部名の単なるリネームによって異なる型も等しいので、<code>(n : Nat) → Vect String n</code>は<code>(k : Nat) → Vect String k</code>と同じです。
型が通常のデータを含むので、素性の等価性はまたデータが等しいときを記述する必要もあります。
同じコンストラクタの使用は等しく、<code>0</code>は<code>0</code>に等しく、<code>[5, 3, 1]</code>は<code>[5, 3, 1]</code>に等しくなります。</p>
<p>しかし型は単なる関数の矢印やデータ型、コンストラクタ以上のものを含みます。
型はまた_変数_や_関数_を含みます。
変数の素性の等価性は比較的単純です。つまり、各変数はそれ自体にのみ等しいので、<code>(n k : Nat) → Vect Int n</code>は<code>(n k : Nat) → Vect Int k</code>とは素性の等価性を持ちません。
一方、関数の場合はより複雑です。
数学では、二つの関数が同一の入出力動作を持っている場合に等しいと考えられますが、それをチェックする効率的なアルゴリズムは存在せず、素性の等価性のポイント全体がどちらの型も交換可能であるかをLeanがチェックすることにあります。
代わりに、Leanは二つの関数が素性の等価性を持つと考えるのは、それらが定義的に等しい本文を持つ<code>fun</code>式の両方のときです。
言い換えれば、二つの関数は同じアルゴリズムを使用し、同じヘルパーを呼び出す必要があります。
これは通常は非常に役に立たないので、関数の素性の等価性は、主に全く同じ定義された関数が二つの型で発生するときに利用されます。</p>
<p>関数が型で呼ばれたとき、素性の等価性のチェックは関数呼び出しを減らすことを伴うかもしれません。
型<code>Vect String (1 + 4)</code>は<code>Vect String (3 + 2)</code>と素性の等価性を持つのは、<code>1 + 4</code>が<code>3 + 2</code>に素性の等価性を持つためです。
それらが等しいかどうかをチェックするために、両方が<code>5</code>に減らされ、コンストラクタールールが5回使用されます。
関数がデータに適用された素性の等価性は、まずそれらが既に同じかどうかを見ることによってチェックされます。つまり、<code>[&quot;a&quot;, &quot;b&quot;] ++ [&quot;c&quot;]</code>を<code>[&quot;a&quot;, &quot;b&quot;] ++ [&quot;c&quot;]</code>と等しいかどうかをチェックするために減らす必要はありません。
そうでなければ、関数は呼び出され、それが値で置き換えられ、値がチェックされるです。</p>
<p>すべての関数の引数が具体的なデータではありません。
例えば、型はコンストラクタ<code>zero</code>と<code>succ</code>から構築されていない<code>Nat</code>を含むかもしれません。
型<code>(n : Nat) → Vect String n</code>において、変数<code>n</code>は<code>Nat</code>ですが、関数が呼び出される前にはそれがどの<code>Nat</code>なのかは知ることができません。
実際、関数は最初に<code>0</code>で呼ばれ、次に<code>17</code>で、その次は<code>33</code>で呼ばれるかもしれません。
<code>appendL</code>の定義で見られたように、型が<code>Nat</code>である変数は<code>plusL</code>のような関数に渡されるかもしれません。
確かに、型<code>(n : Nat) → Vect String n</code>は型<code>(n : Nat) → Vect String (Nat.plusL 0 n)</code>に素性の等価性を持ちます。</p>
<p><code>n</code>と<code>Nat.plusL 0 n</code>が素性の等価性を持っているということは、<code>plusL</code>のパターンマッチがその_最初の_引数を検査するということです。
これは問題を引き起こします：<code>(n : Nat) → Vect String n</code>は<code>(n : Nat) → Vect String (Nat.plusL n 0)</code>と素性の等価性を持っていません。これは、加算の左右の恒等性を持っているはずですが、パターンマッチが変数に対してスタックするためです。
<code>n</code>の実際の値がわかるまで、<code>Nat.plusL n 0</code>のどのケースを選べばいいのかがわからないからです。</p>
<p>同じ問題がクエリ例の<code>Row</code>関数にも現れます。
型<code>Row (c :: cs)</code>はあらゆるデータ型に還元されません。なぜなら<code>Row</code>の定義は一人称リストと2つ以上のエントリを持つリストのための別々のケースを持っているからです。
言い換えれば、変数<code>cs</code>を具体的な<code>List</code>コンストラクタにマッチしなければスタックしてしまいます。
これがほぼすべての<code>Row</code>を取り扱う、または構築する関数が<code>Row</code>自体と同じ3つのケースにマッチする必要がある理由です。それをアンスタックすると、パターンマッチングやコンストラクタに使用できる具体的な型が明らかになります。</p>
<p><code>appendL</code>の足りないケースには<code>Vect α (Nat.plusL n k + 1)</code>が要求されます。
インデックスの中に<code>+ 1</code>があることから、次のステップは<code>Vect.cons</code>の使用であることが示唆されます：</p>
<pre><code class="language-lean">def appendL : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusL k)
  | 0, k, .nil, ys =&gt; ys
  | n + 1, k, .cons x xs, ys =&gt; .cons x (_ : Vect α (n.plusL k))
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusL n k)
</code></pre>
<p><code>appendL</code>への再帰的な呼び出しは所望の長さの<code>Vect</code>を構築できます:</p>
<pre><code class="language-lean">def appendL : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusL k)
  | 0, k, .nil, ys =&gt; ys
  | n + 1, k, .cons x xs, ys =&gt; .cons x (appendL n k xs ys)
</code></pre>
<p>プログラムが完成した今、<code>n</code>と<code>k</code>に明示的なマッチングを除去することで、関数を読みやすく、また呼び出しやすくすることができます:</p>
<pre><code class="language-lean">def appendL : Vect α n → Vect α k → Vect α (n.plusL k)
  | .nil, ys =&gt; ys
  | .cons x xs, ys =&gt; .cons x (appendL xs ys)
</code></pre>
<p>定義上の等価性を用いて型を比較することは、定義上の等価性に関わるすべてのもの、含む関数定義の内部、を依存型やインデックス付きのファミリーを使うプログラムの_インターフェース_の一部にします。関数の内部を型にさらけ出すことは、そのプログラムを使用するプログラムがもはや型検査に合格しないかもしれないというリスクをもたらす可能性があります。 特に、<code>plusL</code>が<code>appendL</code>の型に用いられていることは、<code>plusL</code>の定義を同等な<code>plusR</code>に置き換えることができないことを意味します。</p>
<h2 id="加算におけるスタック"><a class="header" href="#加算におけるスタック">加算におけるスタック</a></h2>
<p><code>plusR</code>を使って<code>append</code>が定義された場合はどうなるでしょうか？ 同じように、明示的な長さと各ケースでのプレースホルダーアンダースコアで始めると、以下のような有用なエラーメッセージが表示されます:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusR k)
  | 0, k, .nil, ys =&gt; _
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusR 0 k)
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusR (n + 1) k)
</code></pre>
<p>しかし、最初のプレースホルダーに<code>Vect α k</code>型注釈を配置しようとすると、型不一致のエラーが生じます:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusR k)
  | 0, k, .nil, ys =&gt; (_ : Vect α k)
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><code class="language-output error">type mismatch
  ?m.3036
has type
  Vect α k : Type ?u.2973
but is expected to have type
  Vect α (Nat.plusR 0 k) : Type ?u.2973
</code></pre>
<p>このエラーは、<code>plusR 0 k</code>と<code>k</code>が定義上等価では_ない_と指摘しています。</p>
<p>これは<code>plusR</code>が以下の定義を持っているためです:</p>
<pre><code class="language-lean">def Nat.plusR : Nat → Nat → Nat
  | n, 0 =&gt; n
  | n, k + 1 =&gt; plusR n k + 1
</code></pre>
<p>そのパターンマッチングは_第二_引数に対して行われており、変数<code>k</code>がその位置に存在することが、計算を行えないように阻止しています。 Leanの標準ライブラリの<code>Nat.add</code>は<code>plusL</code>ではなく<code>plusR</code>に相当し、この定義を使おうとするとまさに同じ困難に直面します:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n + k)
  | 0, k, .nil, ys =&gt; (_ : Vect α k)
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><code class="language-output error">type mismatch
  ?m.3068
has type
  Vect α k : Type ?u.2973
but is expected to have type
  Vect α (0 + k) : Type ?u.2973
</code></pre>
<p>加算が変数で_スタック_しています。 スタックを解消するには<a href="dependent-types/../type-classes/standard-classes.html#equality-and-ordering">命題等価</a>を必要とします。</p>
<h2 id="命題等価"><a class="header" href="#命題等価">命題等価</a></h2>
<p>命題等価は、二つの式が等しいことを数学的に主張するものです。 定義上の等価性が必要な時にLeanが自動的に検査する一方で、命題等価性の主張は明確な証明が必要です。 一度等価命題が証明されると、プログラム内で型を変更し、一方の等価性を他方に置き換えることができ、型検査をスタックから解放することができます。</p>
<p>定義上の等価性がこれほど制限されているのはアルゴリズムで検査できるようにするためです。 命題等価性はより豊かですが、コンピュータが一般的に二つの式が命題的に等しいかどうかを検査することはできませんが、提案された証明が実際に証明であることを検証できます。 定義上の等価性と命題等価性の間の分割は、人間と機械間の労働分担を表しています：面倒な等価性は定義上の等価性の一部として自動的にチェックされるので、命題等価性の興味深い問題を解決するために人間の頭脳を解放します。
同様に、定義上の等価性は型検査によって自動的に呼び出されるのに対し、命題等価性は明示的に訴える必要があります。</p>
<p><a href="dependent-types/../props-proofs-indexing.html">命題、証明、およびインデックス</a>で、<code>simp</code>を使っていくつかの等価性ステートメントが証明されています。これらすべての等価性ステートメントは、実際にはすでに定義上の等価性であることです。 通常、命題等価性ステートメントは、それらが定義上の等価性であるか、既に証明されている等価性に十分に近い形にまで導かれた後、<code>simp</code>のようなツールを利用して簡略化されたケースを処理することで証明されます。 <code>simp</code>タクティクは非常に強力です：舞台裏では、証明を構築するためにいくつかの高速で自動化されたツールを使用しています。 <code>rfl</code>というよりシンプルなタクティクは、命題等価性を証明するために定義上の等価性を特に使用します。 <code>rfl</code>の名前は、すべてがそれ自体と等しいという等価性の特性である_反射性_を短くしたものです。</p>
<p><code>appendR</code>をスタックから解放するには、<code>k = Nat.plusR 0 k</code>の証明が必要ですが、これは<code>plusR</code>がその第二引数の変数にスタックするため、定義上の等価性ではありません。 それを計算させるには、<code>k</code>を具体的なコンストラクタにしなければなりません。 これはパターンマッチングのための仕事です。</p>
<p>特に、<code>k</code>が_どんな_ <code>Nat</code>でもありうるので、このタスクには<code>(k : Nat) → k = Nat.plusR 0 k</code>の証明を返すことができる関数が必要です。 初期のパターンズとプレースホルダーで始まって、以下のようなメッセージが出力されます:</p>
<pre><code class="language-lean">def plusR_zero_left : (k : Nat) → k = Nat.plusR 0 k
  | 0 =&gt; _
  | k + 1 =&gt; _
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
⊢ 0 = Nat.plusR 0 0
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 (k + 1)
</code></pre>
<p>パターンマッチングを通じて<code>k</code>を<code>0</code>に絞り込んだ後、最初のプレースホルダーは定義上で成立しているステートメントの証拠を代表します。 <code>rfl</code>タクティクがそれを処理し、第二のプレースホルダーだけが残されます:</p>
<pre><code class="language-lean">def plusR_zero_left : (k : Nat) → k = Nat.plusR 0 k
  | 0 =&gt; by rfl
  | k + 1 =&gt; _
</code></pre>
<p>第二のプレースホルダーは少し厄介です。 式<code>Nat.plusR 0 k + 1</code>は定義上で<code>Nat.plusR 0 (k + 1)</code>と等価です。 これは、ゴールが<code>k + 1 = Nat.plusR 0 k + 1</code>としても書くことができることを意味します:</p>
<pre><code class="language-lean">def plusR_zero_left : (k : Nat) → k = Nat.plusR 0 k
  | 0 =&gt; by rfl
  | k + 1 =&gt; (_ : k + 1 = Nat.plusR 0 k + 1)
</code></pre>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 k + 1
</code></pre>
<p>等価性ステートメントの両側の<code>+ 1</code>の下には、関数自体が返す別のインスタンスがあります。 他の言い方をすれば、<code>k</code>に対する再帰呼び出しは<code>k = Nat.plusR 0 k</code>であることを証明する証拠を返すはずです。 等価性が等価性でなかったら、それは関数引数に適用されないでしょう。 言い換えれば、もし<code>x = y</code>ならば、<code>f x = f y</code>です。 標準ライブラリには<code>congrArg</code>という関数があり、一つの関数と等価性の証明を受け取り、等価性の両側にその関数が適用された新しい証明を返します。 この場合、関数は<code>(· + 1)</code>です:</p>
<pre><code class="language-lean">def plusR_zero_left : (k : Nat) → k = Nat.plusR 0 k
  | 0 =&gt; by rfl
  | k + 1 =&gt;
    congrArg (· + 1) (plusR_zero_left k)
</code></pre>
<p>命題等価性はプログラム内で右向きの三角演算子<code>▸</code>を使って展開されます。 最初の引数として等価性の証明を受け取り、第二の引数として他の式を受け取るこのオペレーターは、第二の引数の型の中で等価性の左側のインスタンスを右側のものと置き換えることができます。 つまり、以下の定義にはタイプエラーが含まれていません:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusR k)
  | 0, k, .nil, ys =&gt; plusR_zero_left k ▸ (_ : Vect α k)
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<p>最初のプレースホルダーは予想通りの型を持っています:</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k
</code></pre>
<p>これで<code>ys</code>で記入できるようになります:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusR k)
  | 0, k, .nil, ys =&gt; plusR_zero_left k ▸ ys
  | n + 1, k, .cons x xs, ys =&gt; _
</code></pre>
<p>残りのプレースホルダーを埋めるには、もう一度加算のインスタンスをスタックから解放する必要があります:</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (Nat.plusR (n + 1) k)
</code></pre>
<p>ここで証明しなければならないステートメントは、<code>Nat.plusR (n + 1) k = Nat.plusR n k + 1</code>であり、これを<code>▸</code>と組み合わせて式の一番上に<code>+ 1</code>を引き出すことができれば、<code>cons</code>のインデックスと一致させることができます。</p>
<p>証明は、<code>plusR</code>に対する第二の引数としての<code>k</code>にパターンマッチングする再帰関数です。 <code>plusR</code>自体がその第二引数にパターンマッチングしているので、パターンマッチングを通じてそれを「スタックから解放」し、計算の動作を明らかにすることができます。 この証明の骨格は<code>plusR_zero_left</code>に非常に似ています:</p>
<pre><code class="language-lean">def plusR_succ_left (n : Nat) : (k : Nat) → Nat.plusR (n + 1) k = Nat.plusR n k + 1
  | 0 =&gt; by rfl
  | k + 1 =&gt; _
</code></pre>
<p>残りのケースの型は定義上で<code>Nat.plusR (n + 1) k + 1 = Nat.plusR n (k + 1) + 1</code>と等しいので、<code>plusR_zero_left</code>で行われたのと同じように<code>congrArg</code>を使って解決できます:</p>
<pre><code class="language-output error">don't know how to synthesize placeholder
context:
n k : Nat
⊢ Nat.plusR (n + 1) (k + 1) = Nat.plusR n (k + 1) + 1
</code></pre>
<p>これにより完成した証明になります:</p>
<pre><code class="language-lean">def plusR_succ_left (n : Nat) : (k : Nat) → Nat.plusR (n + 1) k = Nat.plusR n k + 1
  | 0 =&gt; by rfl
  | k + 1 =&gt; congrArg (· + 1) (plusR_succ_left n k)
</code></pre>
<p>完成した証明は<code>appendR</code>の第二のケースでスタックから解放するために使うことができます:</p>
<pre><code class="language-lean">def appendR : (n k : Nat) → Vect α n → Vect α k → Vect α (n.plusR k)
  | 0, k, .nil, ys =&gt; plusR_zero_left k ▸ ys
  | n + 1, k, .cons x xs, ys =&gt; plusR_succ_left n k ▸ .cons x (appendR n k xs ys)
</code></pre>
<p><code>appendR</code>の長さの引数を再び暗黙的にすると、証明に訴えるために明示的に名前をつけることはなくなりますが、Leanの型検査は裏で十分な情報を持っており、自動的にそれらを埋めることができます。 他の値では型がマッチしないためです:</p>
<pre><code class="language-lean">def appendR : Vect α n → Vect α k → Vect α (n.plusR k)
  | .nil, ys =&gt; plusR_zero_left _ ▸ ys
  | .cons x xs, ys =&gt; plusR_succ_left _ _ ▸ .cons x (appendR xs ys)
</code></pre>
<h2 id="長所と短所"><a class="header" href="#長所と短所">長所と短所</a></h2>
<p>インデックス付きファミリーは重要な特性を持っています：それらに対するパターンマッチングは定義上の等価性に影響を与えます。 例えば、<code>Vect</code>に対する<code>match</code>式の<code>nil</code>ケースでは、単に長さが<code>0</code>に_なります_。 定義上の等価性は非常に便利です。なぜならそれは常に活発であって、明示的に呼び出す必要がないからです。</p>
<p>しかし、依存型とパターンマッチングに定義上の等価性を使用することは、ソフトウェアエンジニアリングに重大な欠点を有しています。まず、関数は型で使われるために特別に書かれなければなりません。型で使うことが便利な関数は、最も効率的なアルゴリズムを使用していないかもしれません。一度関数が型を使用してさらけ出されると、その実装はインターフェースの一部となり、将来のリファクタリングに困難をもたらします。 二つ目に、定義上の等価性は遅い可能性があります。 当事者が2つの式が定義上等しいかどうかをチェックするように求めた場合、質問である関数が複雑で多くの抽象化の層を持っている場合、大量のコードを実行する必要があるかもしれません。 三つ目に、定義上の等価性の失敗によるエラーメッセージは必ずしも理解しやすいわけではありません。な</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 概要

## 依存型

型が関数呼び出しや通常のデータコンストラクタのような非型コードを含む依存型は、型システムの表現力を大幅に増加させます。
引数の_value_から型を_compute_する能力は、関数の戻り値の型が提供された引数に基づいて変化することを意味します。
これは例えば、データベースのスキーマや特定のクエリに依存したデータベースクエリの結果型を、クエリの結果に対する潜在的に失敗するキャスト操作を必要とせずに持たせるために使用することができます。
クエリが変わると、それを実行した結果として得られる型も変わり、即時のコンパイル時のフィードバックを可能にします。

関数の戻り値の型が値に依存する場合、パターンマッチングによる値の分析は型が_refined_される結果をもたらし、値を表すための変数がパターン内のコンストラクタに置き換えられます。
関数の型シグネチャは、戻り値の型が引数値にどのように依存しているかを文書化し、パターンマッチングは潜在的な引数ごとに戻り値の型がどのように達成されるかを説明します。

型の中に現れる通常のコードは型チェック中に実行されますが、無限ループする可能性がある`partial`関数は呼び出されません。
ほとんどの場合、この計算は[この本の最初に紹介された](../getting-to-know/evaluating.md)通常の評価のルールに従い、式がその値によって逐次置き換えられるまで続き、最終的な値が見つかります。
型チェック中の計算は、実行時の計算と重要な違いがあります：型内のいくつかの値は、まだ未知の_variables_の可能性があります。
これらの場合、パターンマッチングは「スタック」状態になり、特定のコンストラクタが選択されるまで、例えばパターンマッチングによって、進行しません。
型レベルの計算は、プログラムの十分に知られている部分だけを評価し、他の部分を放置する部分評価の一種と見なすことができます。

## ユニバースパターン

依存型を扱う際の一般的なパターンは、型システムの特定のサブセットを区切ることです。
例えば、データベースクエリライブラリは可変長文字列、固定長文字列、あるいは特定の範囲の数値を返すことができますが、関数、ユーザ定義のデータ型、または`IO`アクションを返すことはありません。
型システムのドメイン固有のサブセットは、まず希望する型の構造に一致するコンストラクタを持つデータ型を定義することによって、そしてその後、このデータ型の値をオーソドックスな型に解釈する関数を定義することによって定義されます。
コンストラクタは問題の型の_codes_として参照され、この全体のパターンはしばしば_Tarski風のユニバース_あるいはコンテキストが明確な場合は単に_ユニバース_と呼ばれることがあります。

カスタムユニバースは、興味のある各型に対してインスタンスを定義する型クラスを定義する代替手段です。
型クラスは拡張可能ですが、拡張性が常に望まれるわけではありません。
カスタムユニバースを定義することは、直接型を使用することに対していくつかの利点があります：
 * ユニバース内の_any_型に対して機能する汎用操作（例えば等価性テストやシリアライゼーション）は、コード上での再帰によって実装することができます。
 * 外部システムに受け入れられる型を正確に表現することができ、コードデータ型の定義は何が期待されるかを文書化するために役立ちます。
 * Leanのパターンマッチング完全性チェッカーは、忘れられたコードがないことを保証する一方で、型クラスに基づくソリューションは、欠けているインスタンスのエラーをクライアントコードに委ねます。

## 索引付きファミリー

データ型は、二つの別々の種類の引数を取ることができます：_パラメータ_はデータ型の各コンストラクタ内で同一ですが、_インデックス_はコンストラクタ間で変化することがあります。
特定のインデックスの選択に対して、データ型の一部のコンストラクタのみが利用可能になります。
例として、`Vect.nil`は長さのインデックスが`0`の場合にのみ利用でき、`Vect.cons`は長さのインデックスがある`n+1`に対してのみ利用できます。
パラメータは通常、データ型宣言のコロンの前に名前付きの引数として書かれ、インデックスは関数型のコロン後の引数として表現されますが、Leanはコロン後の引数がパラメータとして使用される場合を推論することができます。

索引付きファミリは、コンパイラによってチェックされるデータ間の複雑な関係を表現することを可能にします。
データ型の不変条件は直接エンコードされ、暫定的な方法でさえそれらを破る方法はありません。
コンパイラにデータ型の不変条件について情報を提供することは、大きな利点をもたらします：コンパイラは今やプログラマーにそれを満たすために何をしなければならないかを伝えることができるのです。
アンダースコアによるコンパイル時エラーの戦略的な使用は、Leanにプログラミング思考プロセスの一部を委ねることができ、プログラマーの心を他のことに向けるために開放することが可能です。

しかし、索引付きファミリを使って不変条件をエンコードすることは困難を引き起こす可能性があります。
まず第一に、それぞれの不変条件を持つデータ型が必要で、それには独自のサポートライブラリも必要です。
`List.append`と`Vect.append`は交換可能ではありません。
これはコードの重複を引き起こす可能性があります。
第二に、索引付きファミリを便利に使うためには、型中で使用される関数の再帰構造が型チェックされているプログラムの再帰構造と一致する必要があります。
索引付きファミリでのプログラミングは、正しい偶然が起こるように手配する芸術です。
偶然が欠けている場合には、等価性証明に依存して回避することは可能ですが、難しく、さらにそれは暗号のような正当性を持つプログラムでいっぱいになることをもたらします。
第三に、型チェック中に大きな値で複雑なコードを実行することは、コンパイル時に遅延を引き起こす可能性があります。
複雑なプログラムでこれらの遅延を避けるには、特殊な技術が要求されることがあります。

## 定義上の等価性と命題上の等価性

Leanの型チェッカーは、時々、二つの型を交換可能とみなすべきかをチェックする必要があります。
型は任意のプログラムを含むことができるため、それは任意のプログラムの等価性をチェックする能力を持たなければなりません。
しかしながら、任意のプログラムを完全に一般的な数学的等価性でチェックするための効率的なアルゴリズムは存在しません。
この問題を解決するため、Leanには二つの等価性の概念が含まれています：

 * _定義上の等価性_は、基本的には計算と束縛変数のリネーミングを無視した構文表現の等価性をチェックする等価性の下限近似です。Leanは、それが必要な状況において自動的に定義上の等価性をチェックします。

 * _命題上の等価性_は、プログラマーによって明示的に証明され、明示的に呼び出される必要があります。それに見返りとして、Leanは証明が有効であり、呼び出しが正しい目標を達成していることを自動的にチェックします。

これら二つの等価性の概念はプログラマーとLean自体との間の労働の分離を表しています。
定義上の等価性は単純ですが自動的であり、一方命題上の等価性は手動ですが表現力があります。
命題上の等価性は、型レベルの計算でそうでなければスタックしてしまうプログラムを解除するために使用することができます。

しかし、型レベルの計算を解除するために命題上の等価性を頻繁に使用することは、通常はコードの臭いを発散します。
それは通常、偶然性がよくエンジニアリングされていないことを意味し、タイプとインデックスを再設計するか、必要な不変条件を強制するために異なる技術を使用する方が通常は良いアイデアです。
代わりに、プログラムが仕様を満たしていることを証明するためや、サブタイプの一部として命題上の等価性を使用するときには、疑わしくないことになります。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="間奏曲戦術帰納そして証明"><a class="header" href="#間奏曲戦術帰納そして証明">間奏曲：戦術、帰納、そして証明</a></h1>
<h2 id="証明とユーザーインターフェースに関する注意"><a class="header" href="#証明とユーザーインターフェースに関する注意">証明とユーザーインターフェースに関する注意</a></h2>
<p>この本は、証明が一度に書かれてLeanに提出され、Leanが残された作業についてのエラーメッセージで返答するかのように証明のプロセスを提示しています。実際にLeanと対話するプロセスはもっと快適です。Leanはカーソルを通じて証明に関する情報を提供し、証明を簡単にする多くのインタラクティブな機能があります。詳細については、ご使用のLean開発環境のドキュメントを参照してください。</p>
<p>この本のアプローチは証明を段階的に構築し、その結果として現れるメッセージを示すことで、Leanが証明の執筆中にどのようなインタラクティブなフィードバックを提供するかを示していますが、それは専門家が使うプロセスよりもはるかに遅いです。同時に、不完全な証明が完全さに向かって進化することを見ることは、証明に関する有用な視点です。証明の執筆におけるスキルが向上するにつれて、Leanのフィードバックがエラーのようには感じられず、自身の思考プロセスをサポートするものと感じるようになるでしょう。インタラクティブなアプローチを学ぶことは非常に重要です。</p>
<h2 id="再帰と帰納"><a class="header" href="#再帰と帰納">再帰と帰納</a></h2>
<p>前章の <code>plusR_succ_left</code> と <code>plusR_zero_left</code> という関数は、二つの視点から見ることができます。一方で、これらは命題に対する証拠を組み立てる再帰的関数で、他の再帰的関数がリスト、文字列、あるいは他のデータ構造を構築するようなものです。また他方で、これらは <em>数学的帰納法</em> による証明に対応しています。</p>
<p>数学的帰納法は、以下の二ステップで自然数に対して命題を証明する技法です：</p>
<ol>
<li>命題が \( 0 \) に対して成り立つことを示します。これを <em>基底ケース</em> といいます。</li>
<li>ある任意に選んだ数 \( n \) に対して命題が成り立つと仮定すると、 \( n + 1 \) に対しても成り立つことを示します。これを <em>帰納ステップ</em> といい、\( n \) に対して命題が成立するという仮定を <em>帰納仮説</em> といいます。</li>
</ol>
<p><em>全ての</em> 自然数に対して個別に命題をチェックすることは不可能なため、帰納法は原理的には任意の特定の自然数に拡張できる証明を書く手段を提供します。例えば、数 3 に対する具体的な証明が必要であれば、まず基底ケースを使い、その後帰納ステップを三度用いて、0、1、2、そして最終的に 3 に対する命題を示すことによって構築することができます。このようにして、それは全ての自然数に対する命題を証明します。</p>
<h2 id="帰納戦術"><a class="header" href="#帰納戦術">帰納戦術</a></h2>
<p>帰納法による証明を <code>congrArg</code> のような補助関数を使う再帰的関数として書くのは、証明の背後にある意図を表現するのに常にうまくいくわけではありません。再帰的関数は確かに帰納法の構造を持っていますが、それらはおそらく証明の <em>符号化</em> とみなされるべきでしょう。さらに、Leanの戦術システムは、再帰的関数を明示的に書くことによって得られない証明の構築を自動化する数多くの機会を提供しています。Leanは証明全体を単一の戦術ブロックで実行する帰納 <em>戦術</em> を提供します。裏で、Leanは帰納法の使用に対応する再帰的関数を構築します。</p>
<p><code>plusR_zero_left</code> を帰納戦術で証明するには、まずその署名を書いて（これは本当に証明なので <code>theorem</code> を使います）、定義の本体として <code>by induction k</code> を使用します：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k
</code></pre>
<p>その結果として生じるメッセージは、二つの目標があることを示しています：</p>
<pre><code class="language-output error">unsolved goals
case zero
⊢ Nat.zero = Nat.plusR 0 Nat.zero

case succ
n✝ : Nat
n_ih✝ : n✝ = Nat.plusR 0 n✝
⊢ Nat.succ n✝ = Nat.plusR 0 (Nat.succ n✝)
</code></pre>
<p>戦術ブロックは、Leanの型チェッカーがファイルを処理する間に実行されるプログラムで、Cプリプロセッサマクロのようなずっと強力なものです。戦術は実際のプログラムを生成します。</p>
<p>戦術言語には多数の目標があり得ます。各目標は、いくつかの仮定を伴う型から成り立っています。これらは、プレースホルダーとしてのアンダースコアを使うことに類似しています。目標における型は証明されるべきものを表し、仮定はスコープ内にあり使用可能なものを表します。<code>case zero</code> のケースでは仮定はなく、型は <code>Nat.zero = Nat.plusR 0 Nat.zero</code> となります。これは定理のステートメントで <code>k</code> の代わりに <code>0</code> を使ったものです。<code>case succ</code> のケースでは、「n✝」と「n_ih✝」という名前の2つの仮定があります。裏で、<code>induction</code> 戦術は全体的な型を洗練する依存型のパターンマッチを作成し、「n✝」はパターンの中の <code>Nat.succ</code> への引数を表します。仮定 <code>n_ih✝</code> は、生成された関数を <code>n✝</code> に再帰的に呼び出した結果を表します。その型は定理全体の型であり、ただ <code>k</code> の代わりに <code>n✝</code> を使っています。「case succ」のゴールの一部として満たされるべき型は、全体の定理のステートメントであり、「k」の代わりに「Nat.succ n✝」が使われています。</p>
<p><code>induction</code> 戦術の使用から生じる二つの目標は、数学的帰納法の説明における基底ケースと帰納ステップに対応しています。基底ケースは <code>case zero</code> です。<code>case succ</code> では、「n_ih✝」は帰納仮説に対応し、全体の「case succ」は帰納ステップです。</p>
<p>証明を書く次のステップは、順番に二つの目標に焦点を合わせることです。<code>do</code> ブロックで &quot;nothing&quot; を示すために <code>pure ()</code> を使うことができるように、戦術言語には &quot;何もしない&quot; というステートメント <code>skip</code> もあります。これは、戦術が必要であるがまだどれを使うべきかはっきりしないときに使用することができます。<code>induction</code> ステートメントの最後に <code>with</code> を追加することはパターンマッチングに似た構文を提供します：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; skip
  | succ n ih =&gt; skip
</code></pre>
<p>二つの <code>skip</code> ステートメントにはそれぞれメッセージが関連付けられています。最初のものは基底ケースを示しています：</p>
<pre><code class="language-output error">unsolved goals
case zero
⊢ Nat.zero = Nat.plusR 0 Nat.zero
</code></pre>
<p>二番目のものは帰納ステップを示しています：</p>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ n = Nat.plusR 0 (Nat.succ n)
</code></pre>
<p>帰納ステップでは、ダガー付きのアクセスできない名前が <code>succ</code> の後に提供された名前、すなわち「n」と「ih」に置き換えられています。</p>
<p><code>induction ... with</code> の後のケースはパターンではありません。それらはゴールの名前に続いてゼロ個以上の名前から成り立っています。名前はゴールに導入された仮定のために使用されます。ゴールが導入するよりも多くの名前を提供するとエラーとなります：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; skip
  | succ n ih lots of names =&gt; skip
</code></pre>
<pre><code class="language-output error">too many variable names provided at alternative 'succ', #5 provided, but #2 expected
</code></pre>
<p>基底ケースに焦点を当てると、<code>rfl</code> 戦術は再帰的関数内で使うのと同じようによく機能します：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt; skip
</code></pre>
<p>再帰的関数バージョンの証明では、型注釈が期待される型を理解しやすいものにしました。戦術言語では、ゴールを解決しやすくするために特定の方法で変換する多くの方法があります。<code>unfold</code> 戦術は、定義された名前をその定義に置き換えます：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
</code></pre>
<p>今、ゴールの等式の右側が <code>Nat.plusR 0 (Nat.succ n)</code> ではなく <code>Nat.plusR 0 n + 1</code> になりました：</p>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ n = Nat.plusR 0 n + 1
</code></pre>
<p>関数群のような <code>congrArg</code> やオペレーターのような <code>▸</code> に訴える代わりに、等式の証明を使って証明ゴールを変換する戦術があります。最も重要なのは <code>rw</code> で、これは等式の証明のリストを受け取り、ゴールの左側を右側で置き換えます。これは <code>plusR_zero_left</code> の中でほとんど正しいことを行います：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
    rw [ih]
</code></pre>
<p>しかし、書き換えの方向が間違っていました。<code>n</code> を <code>Nat.plusR 0 n</code> で置き換えることにより、ゴールをより単純ではなく複雑にしました：</p>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ Nat.succ (Nat.plusR 0 n) = Nat.plusR 0 (Nat.plusR 0 n) + 1
</code></pre>
<p>これは <code>rewrite</code> への呼び出しで <code>ih</code> の前に左矢印を配置することで修正できます。これは等式の右側を左側で置き換えるように指示します：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    unfold Nat.plusR
    rw [←ih]
</code></pre>
<p>この書き換えは等式の両側を同一にし、Leanは独自に <code>rfl</code> を処理してくれます。証明は完成です。</p>
<h2 id="戦術ゴルフ"><a class="header" href="#戦術ゴルフ">戦術ゴルフ</a></h2>
<p>今までのところ、戦術言語はその真価を示していません。上記の証明は再帰的関数よりも短くなく、単に全Lean言語ではなくドメイン固有言語で書かれているだけです。しかし、戦術での証明はより短く、より簡単、そしてより保守しやすくある可能性があります。ゴルフのゲームでより低いスコアが良いのと同様に、戦術ゴルフでの証明でより短いのが良いです。</p>
<p><code>plusR_zero_left</code> の帰納ステップは、簡約戦術 <code>simp</code> を使って証明することができます。<code>simp</code> を単独で使っても助けにはなりません：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp
</code></pre>
<pre><code class="language-output error">simp made no progress
</code></pre>
<p>しかし、<code>simp</code> は定義群を使うように設定することができます。<code>simp</code> に <code>Nat.plusR</code> の定義を考慮に入れるように依頼すると、より簡単なゴールになります：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
⊢ n = Nat.plusR 0 n
</code></pre>
<p>特に、ゴールは現在帰納仮説と同一です。簡約化が単純な等式のステートメントを自動的に証明するだけでなく、<code>Nat.succ A = Nat.succ B</code> のようなゴールも <code>A = B</code> で置き換えるため、帰納仮説 <code>ih</code> がちょうど正しい型なので、<code>exact</code> 戦術がそれを使うべきであることを示すことができます：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
    exact ih
</code></pre>
<p>しかし、「exact」の使用はややもろいです。証明を「ゴルフ」化する間に帰納仮説の名前が変更されることがあり、それによってこの証明が機能しなくなる可能性があります。<code>assumption</code> 戦術は、<em>全ての</em> 仮定がそれに一致する場合に現在のゴールを解決します：</p>
<pre><code class="language-leantac">theorem plusR_zero_left (k : Nat) : k = Nat.plusR 0 k := by
  induction k with
  | zero =&gt; rfl
  | succ n ih =&gt;
    simp [Nat.plusR]
    assumption
</code></pre>
<p>このように、<code>assumption</code> 戦術を使用することで、ゴールの名前を覚える必要なく、現在のゴールに一致する任意の仮定を使って直ちに解決できます。これが、特に戦術ゴルフの文脈では好まれる理由です。証明のロバスト性を向上させ、将来の変更に対しても安定性を保つために役立つからです。</p>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>戦術による証明は、Leanの強力なインターフェイスを通じて、証明の構築を大いに自動化することができます。この章では、特に帰納法に焦点を当て、戦術を使用して証明を簡略化し、保守しやすくする方法を見てきました。</p>
<p>証明のプロセスはしばしば反復的であり、特定の戦術のセットを試すことから始まります。その後、少しずつ改善していき、よりコンパクトで理解しやすい証明へと進化させていくものです。</p>
<p>Lean における戦術言語は、日時点では、より堅牢で読みやすい証明を作成するために必要な柔軟性を提供します。しかし、戦術ゴルフのアプローチは、時として証明をより短くしようとするあまり、読みやすさや明確さを犠牲にする可能性もあるということを忘れてはいけません。状況に応じて適切なバランスを見つけることが、良い証明を構築する上での鍵となります。</p>
<p>各戦術の詳細や応用については、Leanのドキュメントや、詳細なチュートリアルを参照してください。実践を通じて、それぞれの戦術がどのような役割を果たすのか、どのように利用していくのかの感覚をつかむことができるでしょう。</p>
<p>証明者の皆様がLeanの戦術を使われる際には、この章で紹介したテクニックや戦術のアイデアが役に立つことを願っています。そして、それぞれの証明が少しずつでも洗練されていくことで、より強固で elegant(エレガント)な形で知識を積み上げていく喜びを感じていただければ幸いです。</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code># プログラミング、証明、そしてパフォーマンス

この章ではプログラミングに焦点を当てます。
プログラムは正しい結果を計算する必要がありますが、それを効率的に実行することも大切です。
効率的な関数型プログラムを書くためには、データ構造を適切に利用する方法と、プログラムの実行に必要な時間とメモリを考慮することが重要です。

また、この章では証明についても触れています。
Leanで効率的なプログラミングにおいて、最も重要なデータ構造の一つは配列です。配列を安全に使うためには、配列のインディックスが有効範囲内にあることを証明する必要があります。
さらに、多くの興味深い配列アルゴリズムは、構造的再帰のパターンに従わず、代わりに配列を繰り返し処理します。
これらのアルゴリズムは終了するものですが、Leanが自動で終了を保証するわけではありません。
証明はプログラムがなぜ終了するのかを示すために役立ちます。

プログラムを書き換えて速度を上げると、しばしば理解が難しいコードになってしまいます。
証明はまた、まったく異なるアルゴリズムや実装技術が使われた場合でも、二つのプログラムが同じ結果を計算することを示すことができます。
このようにして、遅いけれども理解しやすいプログラムは、速く複雑なバージョンの仕様書として機能することが可能です。

証明とプログラミングを組み合わせることで、プログラムはより安全かつ効率的になります。
証明によって、ランタイム時の境界チェックを省略できるようになり、さまざまなテストが不要になることもあり、ランタイムパフォーマンスのコストをかけずに非常に高い信頼性をプログラムに提供できます。
しかし、プログラムに関する定理を証明する作業は時間がかかることもあり、コストがかかる場合もあるため、他のツールの方が経済的な選択となることがよくあります。

対話型定理証明は複雑なトピックです。
この章は、Leanを用いてプログラミングを行う中で実際に遭遇する証明の一端を垣間見るだけです。
多くの興味深い定理はプログラミングとは直接関係がありません。
さらに学びたい方のために、リソースのリストは「[次のステップ](next-steps.md)」をご覧ください。
しかし、プログラミングを学ぶ際同様に、実際に証明を書く経験が学びにとって代わることはありません。始める時が来たのです！
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="末尾再帰"><a class="header" href="#末尾再帰">末尾再帰</a></h1>
<p>Leanの<code>do</code>記法では、<code>for</code>や<code>while</code>などの伝統的なループ構文を使用することが可能ですが、これらの構成は背後で再帰関数の呼び出しに変換されます。
多くのプログラミング言語において、再帰関数はループと比較して重要な不利点を持っています：ループはスタック上のスペースを消費しないのに対して、再帰関数は再帰呼び出しの数に比例してスタック空間を消費します。
スタック空間は典型的に限られており、自然に再帰関数として表されるアルゴリズムをループに書き換え、明示的にヒープ割り当てスタックを伴うことがしばしば必要です。</p>
<p>関数型プログラミングでは、通常は逆のことが当てはまります。
可変ループとして自然に表されるプログラムはスタック空間を消費する場合がありますが、それらを再帰関数に書き換えると、高速に実行されることがあります。
これは関数型プログラミング言語の重要な側面である <em>末尾呼び出し除去</em> によるものです。
末尾呼び出しとは、一つの関数から別の関数への呼び出しが、新しいスタックフレームをプッシュするのではなく、通常のジャンプにコンパイルされるものであり、末尾呼び出し除去とはこの変換を行うプロセスです。</p>
<p>末尾呼び出し除去は単なる任意の最適化ではありません。
その存在は効率的な関数型コードを書くことができるようにするための根本的な部分です。
これが有用であるためには、信頼できるものでなければなりません。
プログラマーは信頼できる方法で末尾呼び出しを特定し、コンパイラがそれらを除去することを信頼できると確信する必要があります。</p>
<p>関数<code>NonTail.sum</code>は<code>Nat</code>のリストの内容を加算します：</p>
<pre><code class="language-lean">def NonTail.sum : List Nat → Nat
  | [] =&gt; 0
  | x :: xs =&gt; x + sum xs
</code></pre>
<p>この関数をリスト<code>[1, 2, 3]</code>に適用すると、次の評価ステップのシーケンスが生じます：</p>
<pre><code class="language-lean">NonTail.sum [1, 2, 3]
===&gt;
1 + (NonTail.sum [2, 3])
===&gt;
1 + (2 + (NonTail.sum [3]))
===&gt;
1 + (2 + (3 + (NonTail.sum [])))
===&gt;
1 + (2 + (3 + 0))
===&gt;
1 + (2 + 3)
===&gt;
1 + 5
===&gt;
6
</code></pre>
<p>評価ステップにおいて、括弧は<code>NonTail.sum</code>への再帰呼び出しを示しています。
言い換えると、３つの数字を加算するために、プログラムはまずリストが空でないかを確認する必要があります。
リストの先頭（<code>1</code>）をリストの末尾の合計に加算するためには、まずリストの末尾の合計を計算する必要があります：</p>
<pre><code class="language-lean">1 + (NonTail.sum [2, 3])
</code></pre>
<p>しかしリストの末尾の合計を計算するためには、プログラムはそれが空かどうかを確認する必要があります。
そしてそれは空ではありません - 末尾は自体が<code>2</code>を頭に持つリストです。
結果として待っているステップは<code>NonTail.sum [3]</code>の戻りを待つものです：</p>
<pre><code class="language-lean">1 + (2 + (NonTail.sum [3]))
</code></pre>
<p>実行時呼び出しスタックの全ポイントは、再帰的な呼び出しの結果に値<code>1</code>、<code>2</code>、<code>3</code>を加算する指示とともに追跡されます。
再帰呼び出しが完了するにつれて、呼び出しを行ったスタックフレームに制御が戻り、加算の各ステップが実行されます。
リストの先頭を保存し、それらを加算するための指示を保存することは無料ではありません。それはリストの長さに比例するスペースが必要です。</p>
<p>関数<code>Tail.sum</code>も<code>Nat</code>のリストの内容を加算します：</p>
<pre><code class="language-lean">def Tail.sumHelper (soFar : Nat) : List Nat → Nat
  | [] =&gt; soFar
  | x :: xs =&gt; sumHelper (x + soFar) xs

def Tail.sum (xs : List Nat) : Nat :=
  Tail.sumHelper 0 xs
</code></pre>
<p>これをリスト<code>[1, 2, 3]</code>に適用すると、次の評価ステップのシーケンスが生じます：</p>
<pre><code class="language-lean">Tail.sum [1, 2, 3]
===&gt;
Tail.sumHelper 0 [1, 2, 3]
===&gt;
Tail.sumHelper (0 + 1) [2, 3]
===&gt;
Tail.sumHelper 1 [2, 3]
===&gt;
Tail.sumHelper (1 + 2) [3]
===&gt;
Tail.sumHelper 3 [3]
===&gt;
Tail.sumHelper (3 + 3) []
===&gt;
Tail.sumHelper 6 []
===&gt;
6
</code></pre>
<p>内部のヘルパー関数は再帰的に自分自身を呼び出しますが、それをする際に最終結果を計算するために何も覚えておく必要がありません。
<code>Tail.sumHelper</code>が基本ケースに達したとき、制御は直接<code>Tail.sum</code>に戻されます。なぜなら、中間の<code>Tail.sumHelper</code>の呼び出しは自身の再帰呼び出しの結果を修正せずに単に返すからです。
言い換えると、各再帰的な<code>Tail.sumHelper</code>の呼び出しについて単一のスタックフレームを再利用することができます。
末尾呼び出し除去とは、まさにこのスタックフレームの再利用であり、<code>Tail.sumHelper</code>は <em>末尾再帰関数</em> として言及されます。</p>
<p><code>Tail.sumHelper</code>への最初の引数には、そうでなければ呼び出しスタックで追跡する必要がある全ての情報が含まれています。すなわち、これまでに遭遇した数字の合計です。
各再帰呼び出しでは、この引数が新しい情報で更新されます。新しい情報を呼び出しスタックに追加するのではありません。
呼び出しスタックからの情報を置き換えるような引数は <em>アキュムレータ</em> と呼ばれます。</p>
<p>執筆時点で、作者のコンピューター上では、<code>NonTail.sum</code>は216,856個以上のエントリを持つリストが渡されるとスタックオーバーフローでクラッシュします。一方で、<code>Tail.sum</code>は1億個の要素を持つリストをスタックオーバーフローなしに合計することができます。
<code>Tail.sum</code>を実行する際に新しいスタックフレームをプッシュする必要がないため、それは可変変数を持つ<code>while</code>ループに完全に相当します。各再帰呼び出しでは、スタック上の関数引数が単にリストの次のノードに置き換わります。</p>
<h2 id="末尾と非末尾の位置"><a class="header" href="#末尾と非末尾の位置">末尾と非末尾の位置</a></h2>
<p><code>Tail.sumHelper</code>が末尾再帰である理由は、再帰呼び出しが <em>末尾位置</em> にあるためです。
略式に言えば、関数呼び出しが末尾位置にあるとは、呼び出し元が返された値をどのようにも変更する必要がなく、ただ直接返すだけの場合です。
より公式には、末尾位置は式に対して明確に定義することができます。</p>
<p><code>match</code>式が末尾位置にある場合、その各ブランチも末尾位置にあります。
<code>match</code>が一つのブランチを選択すると、制御は直接それに進みます。
同様に、<code>if</code>式が末尾位置にあれば、その<code>if</code>式の両方のブランチが末尾位置です。
最後に、<code>let</code>式が末尾位置にあるならば、そのボディもそうです。</p>
<p>その他の位置は末尾位置ではありません。
関数またはコンストラクタへの引数は末尾位置にないです。なぜなら評価は引数の値に適用される関数またはコンストラクタを追跡する必要があるからです。
内部関数のボディは末尾位置にないです。なぜなら制御がそれに通過するとは限らないからです：関数ボディは関数が呼び出されるまで評価されません。
同様に、関数型のボディも末尾位置ではありません。
<code>(x : α) → E</code>で<code>E</code>を評価するには、結果の型が<code>(x : α) → ...</code>で囲まれている必要があると追跡する必要があります。</p>
<p><code>NonTail.sum</code>では、再帰呼び出しは<code>+</code>の引数であるため末尾位置にありません。
<code>Tail.sumHelper</code>では、再帰呼び出しはすぐ下にあるパターンマッチの下であり、それ自体が関数のボディであるため末尾位置にあります。</p>
<p>執筆時点で、Leanは再帰関数の直接的な末尾呼び出しのみを除去します。
これは、<code>f</code>の定義における<code>f</code>への末尾呼び出しが除去されることを意味しますが、他の関数<code>g</code>への末尾呼び出しは除去されません。
確かに、他の関数への末尾呼び出しを除去することも可能であり、スタックフレームを節約することもできますが、これはまだLeanでは実装されていません。</p>
<h2 id="リストの反転"><a class="header" href="#リストの反転">リストの反転</a></h2>
<p>関数<code>NonTail.reverse</code>は各サブリストの先頭を結果の末尾へと追加することでリストを反転させます：</p>
<pre><code class="language-lean">def NonTail.reverse : List α → List α
  | [] =&gt; []
  | x :: xs =&gt; reverse xs ++ [x]
</code></pre>
<p>これを使用して<code>[1, 2, 3]</code>を反転すると、次のようなステップのシーケンスになります：</p>
<pre><code class="language-lean">NonTail.reverse [1, 2, 3]
===&gt;
(NonTail.reverse [2, 3]) ++ [1]
===&gt;
((NonTail.reverse [3]) ++ [2]) ++ [1]
===&gt;
(((NonTail.reverse []) ++ [3]) ++ [2]) ++ [1]
===&gt;
(([] ++ [3]) ++ [2]) ++ [1]
===&gt;
([3] ++ [2]) ++ [1]
===&gt;
[3, 2] ++ [1]
===&gt;
[3, 2, 1]
</code></pre>
<p>末尾再帰バージョンは、アキュムレータで各ステップで<code>· ++ [x]</code>の代わりに<code>x :: ·</code>を使用します：</p>
<pre><code class="language-lean">def Tail.reverseHelper (soFar : List α) : List α → List α
  | [] =&gt; soFar
  | x :: xs =&gt; reverseHelper (x :: soFar) xs

def Tail.reverse (xs : List α) : List α :=
  Tail.reverseHelper [] xs
</code></pre>
<p>これは<code>NonTail.reverse</code>で計算する際に各スタックフレームに保存されたコンテキストが基本ケースから始めて適用されるからです。
各々の「記憶された」コンテキストは後入れ先出しの順番で実行されます。
一方で、アキュムレータをパスするバージョンは、元々の基本ケースからではなく、リストの最初のエントリから開始して、初期アキュムレータ値をリストを通じて左から右へ修正します。シリーズの還元ステップにおいて見ることができるように：</p>
<pre><code class="language-lean">Tail.reverse [1, 2, 3]
===&gt;
Tail.reverseHelper [] [1, 2, 3]
===&gt;
Tail.reverseHelper [1] [2, 3]
===&gt;
Tail.reverseHelper [2, 1] [3]
===&gt;
Tail.reverseHelper [3, 2, 1] []
===&gt;
[3, 2, 1]
</code></pre>
<p>言い換えると、非末尾再帰バージョンは基本ケースで始まり、リストを右から左へ再帰の結果の修正を行います。
リスト中のエントリはアキュムレータに対して先入れ先出しの順番で影響を与えます。
アキュムレータを持つ末尾再帰バージョンはリストの先頭から始まり、リストを通じて左から右へ初期アキュムレータ値を修正します。</p>
<p>加算は交換可能なので、<code>Tail.sum</code>ではこのことを考慮に入れる必要がありませんでした。
リストの連結は交換可能ではないので、逆の方向で実行されたときに同じ効果が得られる操作を慎重に見つける必要があります。
<code>NonTail.reverse</code>で再帰の結果の後に<code>[x]</code>を連結することは、結果が逆順で構築される際に、リストの始めに<code>x</code>を追加することと同じです。</p>
<h2 id="複数の再帰呼び出し"><a class="header" href="#複数の再帰呼び出し">複数の再帰呼び出し</a></h2>
<p><code>BinTree.mirror</code>の定義には、二つの再帰呼び出しがあります：</p>
<pre><code class="language-lean">def BinTree.mirror : BinTree α → BinTree α
  | .leaf =&gt; .leaf
  | .branch l x r =&gt; .branch (mirror r) x (mirror l)
</code></pre>
<p><code>reverse</code>や<code>sum</code>のような関数を<code>while</code>ループで行うのが典型的な命令型言語が、「この種のトラバーサルでは再帰関数を使用します。
この関数はアキュムレータをパスするスタイルを用いて末尾再帰に単純に書き直されることはできません。</p>
<p>通常、各再帰的なステップに複数の再帰呼び出しが必要な場合、アキュムレータをパスするスタイルを使用することは難しいでしょう。
この難しさは、再帰関数をループに書き換え、明示的なデータ構造を使用するという難しさに似ていますが、さらにLeanに対して関数が終了することを納得させるという複雑さが加わっています。
しかしながら、<code>BinTree.mirror</code>の場合のように、複数の再帰的な呼び出しがしばしばそれ自体に複数の再帰的な発生をもつコンストラクタを持つデータ構造を示します。
これらのケースでは、構造の深さはその全体的なサイズに比べてしばしば対数的であり、スタックとヒープ間のトレードオフはそれほど厳しくありません。これらの関数を末尾再帰的にするための系統的な技法がありますが、それは継続渡しスタイルを使用することなどですが、それらはこの章の範囲を超えています。</p>
<h2 id="練習問題-12"><a class="header" href="#練習問題-12">練習問題</a></h2>
<p>以下の非末尾再帰的な関数を累積引数を使った末尾再帰的な関数に変換してください：</p>
<pre><code class="language-lean">def NonTail.length : List α → Nat
  | [] =&gt; 0
  | _ :: xs =&gt; NonTail.length xs + 1 
</code></pre>
<pre><code class="language-lean">def NonTail.factorial : Nat → Nat
  | 0 =&gt; 1
  | n + 1 =&gt; factorial n * (n + 1)
</code></pre>
<p><code>NonTail.filter</code>の変換は、末尾再帰を通じて一定のスタック空間を使用し、入力リストの長さに比例する線形な時間で実行されるプログラムとなるべきです。
元のプログラムに対する許容可能な定数係数のオーバーヘッドが生じる場合があります：</p>
<pre><code class="language-lean">def NonTail.filter (p : α → Bool) : List α → List α
  | [] =&gt; []
  | x :: xs =&gt;
    if p x then
      x :: filter p xs
    else
      filter p xs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># 同値性の証明

末尾再帰とアキュムレータを使用するように書き換えられたプログラムは、元のプログラムとはかなり異なって見えることがあります。
元の再帰関数はよく理解しやすいですが、実行時にスタックを使い果たすリスクがあります。
両方のバージョンのプログラムを例でテストして単純なバグを除外した後、プログラムが同値であることを一度で証明するために証明が使用されることがあります。

## `sum`が等しいことの証明

`sum`の両方のバージョンが等しいことを証明するには、スタブ証明付きの定理のステートメントから始めます：

```leantac
theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  skip
</code></pre>
<p>予想通り、Leanは未解決のゴールを記述しています：</p>
<pre><code class="language-output error">unsolved goals
⊢ NonTail.sum = Tail.sum
</code></pre>
<p>ここでは<code>rfl</code>タクティックは適用されません。なぜなら<code>NonTail.sum</code>と<code>Tail.sum</code>は定義上等しくないためです。
しかし、関数が等しいということはただの定義的な等価性以上の方法で可能です。
それはまた、同じ入力で等価な出力を生成することを証明することによって二つの関数が等しいことを証明することができるということを意味します。
言い換えれば、\( f = g \) は、全ての可能な入力 \( x \) に対して \( f(x) = g(x) \) を証明することによって証明され得ます。
この原理は_関数拡張性_と呼ばれています。
関数拡張性はまさに<code>NonTail.sum</code>が<code>Tail.sum</code>と等しい理由です：彼らはどちらも数値のリストを合計する。</p>
<p>Leanのタクティック言語では、<code>funext</code>を使用して関数拡張性が呼び出され、任意の引数に使用される名前について続けられます。
任意の引数はコンテキストに仮定として追加され、ゴールはこの引数に適用された関数が等しいことを要求するように変わります：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
</code></pre>
<pre><code class="language-output error">unsolved goals
case h
xs : List Nat
⊢ NonTail.sum xs = Tail.sum xs
</code></pre>
<p>このゴールは引数<code>xs</code>に関する帰納法によって証明することができます。
両方の<code>sum</code>関数は空リストに適用されたときに<code>0</code>を返すため、これは基本ケースとなります。
入力リストの始めに数値を追加すると、両方の関数はその数値を結果に追加するため、これは帰納ステップとなります。
<code>induction</code>タクティックを呼び出すと2つのゴールが生じます：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; skip
  | cons y ys ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.nil
⊢ NonTail.sum [] = Tail.sum []
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ NonTail.sum (y :: ys) = Tail.sum (y :: ys)
</code></pre>
<p>空リストに対する基本ケースは<code>rfl</code>を用いて解決できます。なぜなら両方の関数は空リストに<code>0</code>を返すからです：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt; skip
</code></pre>
<p>帰納ステップを解決する最初のステップは、目標の単純化であり、<code>simp</code>に<code>NonTail.sum</code>と<code>Tail.sum</code>を展開するよう求めることです：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + NonTail.sum ys = Tail.sumHelper 0 (y :: ys)
</code></pre>
<p><code>Tail.sum</code>を展開すると、それが直ちに<code>Tail.sumHelper</code>に委譲することが明らかになります。これもまた単純化すべきです：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum, Tail.sumHelper]
</code></pre>
<p>結果として得られるゴールでは、<code>sumHelper</code>は計算を一歩進めて<code>y</code>をアキュムレータに加えています：</p>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + NonTail.sum ys = Tail.sumHelper y ys
</code></pre>
<p>帰納法の仮説との書き換えはゴールから<code>NonTail.sum</code>の全ての言及を取り除きます：</p>
<pre><code class="language-leantac">theorem non_tail_sum_eq_tail_sum : NonTail.sum = Tail.sum := by
  funext xs
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [NonTail.sum, Tail.sum, Tail.sumHelper]
    rw [ih]
</code></pre>
<pre><code class="language-output error">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
⊢ y + Tail.sum ys = Tail.sumHelper y ys
</code></pre>
<p>この新しいゴールは、リストの合計にある数値を加えることは、その数値を<code>sumHelper</code>の初期アキュムレータとして使用するのと同じであることを述べています。
明確性のため、この新しいゴールは別の定理として証明することができます：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
xs : List Nat
n : Nat
⊢ n + Tail.sum xs = Tail.sumHelper n xs
</code></pre>
<p>再び、これは基本ケースが<code>rfl</code>を使用する帰納法による証明です：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
⊢ n + Tail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<p>これは帰納的ステップであるため、ゴールは帰納法の仮説<code>ih</code>に一致するように単純化されるべきです。
<code>Tail.sum</code>および<code>Tail.sumHelper</code>の定義を使って単純化すると、以下のようになります：</p>
<pre><code class="language-leantac">theorem helper_add_sum_accum (xs : List Nat) (n : Nat) :
    n + Tail.sum xs = Tail.sumHelper n xs := by
  induction xs with
  | nil =&gt; rfl
  | cons y ys ih =&gt;
    simp [Tail.sum, Tail.sumHelper]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
⊢ n + Tail.sumHelper y ys = Tail.sumHelper (y + n) ys
</code></pre>
<p>理想的には、帰納法の仮説を使用して<code>Tail.sumHelper (y + n) ys</code>を置き換えることができますが、一致しません。
帰納法の仮説は<code>Tail.sumHelper n ys</code>に使用できますが、<code>Tail.sumHelper (y + n) ys</code>には使用できません。
言い換えれば、この証明は行き詰まっています。</p>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配列と終了性"><a class="header" href="#配列と終了性">配列と終了性</a></h1>
<p>効率的なコードを書くためには、適切なデータ構造を選択することが重要です。
リンクリストにはそれらの場所があります：一部のアプリケーションでは、リストの末尾を共有する能力が非常に重要です。
しかし、可変長の逐次的なデータコレクションに対するほとんどのユースケースは、メモリオーバーヘッドが少なく、局所性が良い配列によってよりよく対応されます。</p>
<p>ただし、配列はリストに対して以下の2つの欠点があります：</p>
<ol>
<li>配列はインデックスを通じてアクセスされるため、安全を保つためには<a href="programs-proofs/../props-proofs-indexing.html">証明義務</a>が課せられます。</li>
<li>左から右へと配列全体を処理するループは末尾再帰関数ですが、各呼び出しで減少する引数を持っていません。</li>
</ol>
<p>配列を効果的に使用するには、配列のインデックスが範囲内にあること、および配列のサイズに近づくインデックスがプログラムの終了をもたらすことをLeanに証明する方法を知っている必要があります。
これらはいずれも、命題の平等ではなく、不等命題を使用して表現されます。</p>
<h2 id="不等式"><a class="header" href="#不等式">不等式</a></h2>
<p>異なる型には異なる順序の概念があるため、不等式は <code>LE</code> および <code>LT</code> と呼ばれる2つの型クラスによって管理されます。
<a href="programs-proofs/../type-classes/standard-classes.html#equality-and-ordering">標準型クラスに関するセクション</a>のテーブルは、これらのクラスが構文とどのように関連しているかを説明しています：</p>
<table><thead><tr><th>式</th><th>展開</th><th>クラス名</th></tr></thead><tbody>
<tr><td><code>x &lt; y</code></td><td><code>LT.lt x y</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≤ y</code></td><td><code>LE.le x y</code></td><td><code>LE</code></td></tr>
<tr><td><code>x &gt; y</code></td><td><code>LT.lt y x</code></td><td><code>LT</code></td></tr>
<tr><td><code>x ≥ y</code></td><td><code>LE.le y x</code></td><td><code>LE</code></td></tr>
</tbody></table>
<p>言い換えれば、型は <code>&lt;</code> と <code>≤</code> 演算子の意味をカスタマイズすることができ、 <code>&gt;</code> と <code>≥</code>は <code>&lt;</code> と <code>≤</code> からそれぞれの意味を導き出しています。
<code>LT</code> と <code>LE</code> のクラスは <code>Bool</code>ではなく命題を返すメソッドを持っています：</p>
<pre><code class="language-lean">class LE (α : Type u) where
  le : α → α → Prop

class LT (α : Type u) where
  lt : α → α → Prop
</code></pre>
<p><code>Nat</code> の <code>LE</code> インスタンスは <code>Nat.le</code> に委譲します：</p>
<pre><code class="language-lean">instance : LE Nat where
  le := Nat.le
</code></pre>
<p><code>Nat.le</code> を定義するには、まだ紹介されていないLeanの機能が必要です：それは帰納的に定義された関係です。</p>
<h3 id="帰納的に定義された命題述語および関係"><a class="header" href="#帰納的に定義された命題述語および関係">帰納的に定義された命題、述語、および関係</a></h3>
<p><code>Nat.le</code> は <em>帰納的に定義された関係</em> です。
<code>inductive</code> を使用して新しいデータ型を作成できるのと同様に、新しい命題を作成するためにも使用できます。
命題が引数を取る場合、それは一部の引数に対しては真であるが、全てに対して真であるわけではない <em>述語</em> として参照されます。
複数の引数を取る命題は <em>関係</em> と呼ばれます。</p>
<p>帰納的に定義された命題の各コンストラクターは、それを証明する方法です。
言い換えれば、命題の宣言はそれが真であるさまざまな形の証拠を記述しています。
シングルコンストラクターを持つ引数なしの命題は証明が非常に簡単になることがあります：</p>
<pre><code class="language-lean">inductive EasyToProve : Prop where
  | heresTheProof : EasyToProve
</code></pre>
<p>証明はそのコンストラクターを使用することから成ります：</p>
<pre><code class="language-lean">theorem fairlyEasy : EasyToProve := by
  constructor
</code></pre>
<p>実際に、「True」という命題は、常に簡単に証明できるべきであり、<code>EasyToProve</code> と同じように定義されます：</p>
<pre><code class="language-lean">inductive True : Prop where
  | intro : True
</code></pre>
<p>引数を取らない帰納的に定義された命題は、帰納的に定義されたデータ型ほど興味深くありません。
データがそれ自体で興味深いからです—自然数 <code>3</code> は <code>35</code> とは異なり、3枚のピザを注文した人は35枚が30分後に彼らのドアに届いたら怒るでしょう。
命題のコンストラクターは命題が真である方法を記述していますが、一度命題が証明されると、どの基本的なコンストラクターが使用されたかを知る必要はありません。
これが <code>Prop</code> 宇宙におけるほとんどの興味深い帰納的に定義された型が引数を取る理由です。</p>
<p>帰納的に定義された述語 <code>IsThree</code> は、その引数が3であることを述べています：</p>
<pre><code class="language-lean">inductive IsThree : Nat → Prop where
  | isThree : IsThree 3
</code></pre>
<p>ここで使用されているメカニズムは、[<code>HasCol</code>]といった <a href="programs-proofs/../dependent-types/typed-queries.html#column-pointers">インデックス付きファミリー</a> と全く同様ですが、結果として得られる型は使用できるデータではなく証明可能な命題です。</p>
<p>この述語を使用すると、実際に3が3であることを証明することが可能です：</p>
<pre><code class="language-lean">theorem three_is_three : IsThree 3 := by
  constructor
</code></pre>
<p>同様に、<code>IsFive</code> はその引数が <code>5</code> であると述べる述語です：</p>
<pre><code class="language-lean">inductive IsFive : Nat → Prop where
  | isFive : IsFive 5
</code></pre>
<p>ある数が3であるならば、それに2を加えた結果は5であるべきです。
これは定理のステートメントとして表現できます：</p>
<pre><code class="language-leantac">theorem three_plus_two_five : IsThree n → IsFive (n + 2) := by
  skip
</code></pre>
<p>結果として得られるゴールは関数型です：</p>
<pre><code class="language-output error">unsolved goals
n : Nat
⊢ IsThree n → IsFive (n + 2)
</code></pre>
<p>したがって、<code>intro</code> タクティックを使用して引数を仮定に変換することができます：</p>
<pre><code class="language-leantac">theorem three_plus_two_five : IsThree n → IsFive (n + 2) := by
  intro three
</code></pre>
<pre><code class="language-output error">unsolved goals
n : Nat
three : IsThree n
⊢ IsFive (n + 2)
</code></pre>
<p><code>n</code> が3であるという仮定があれば、<code>IsFive</code> の構築子を使用して証明を完成することが可能です：</p>
<pre><code class="language-leantac">theorem three_plus_two_five : IsThree n → IsFive (n + 2) := by
  intro three
  constructor
</code></pre>
<p>しかし、これはエラーを発生させます：</p>
<pre><code class="language-output error">tactic 'constructor' failed, no applicable constructor found
n : Nat
three : IsThree n
⊢ IsFive (n + 2)
</code></pre>
<p>このエラーは、<code>n + 2</code> が定義上 <code>5</code> に等しくないために発生します。
通常の関数定義では、仮定 <code>three</code> に依存したパターンマッチングを使用して <code>n</code> を <code>3</code> に洗練させることができます。
依存するパターンマッチングのタクティックに相当するものは <code>cases</code> であり、その構文は <code>induction</code> のようです：</p>
<pre><code class="language-leantac">theorem three_plus_two_five : IsThree n → IsFive (n + 2) := by
  intro three
  cases three with
  | isThree =&gt; skip
</code></pre>
<p>残るケースでは、<code>n</code> は <code>3</code> に洗練されています：</p>
<pre><code class="language-output error">unsolved goals
case isThree
⊢ IsFive (3 + 2)
</code></pre>
<p><code>3 + 2</code> が定義上 <code>5</code> に等しいため、構築子は今適用可能です：</p>
<pre><code class="language-leantac">theorem three_plus_two_five : IsThree n → IsFive (n + 2) := by
  intro three
  cases three with
  | isThree =&gt; constructor
</code></pre>
<p>標準の偽の命題 <code>False</code> にはコンストラクターがないため、直接の証拠を提供することは不可能です。
<code>False</code> の証拠を提供する唯一の方法は、仮定自体が不可能である場合と同様に、タイプシステムが到達不可能であると見ることができるコードをマークするために <code>nomatch</code> を使用できる場合です。
<a href="programs-proofs/../props-proofs-indexing.html#connectives">初めての証明に関する間奏曲</a> で説明されているように、否定 <code>Not A</code> は <code>A → False</code> の略です。
<code>Not A</code> はまた <code>¬A</code> と書くことができます。</p>
<p>4が3でないということはありません：</p>
<pre><code class="language-leantac">theorem four_is_not_three : ¬ IsThree 4 := by
  skip
</code></pre>
<p>初期の証明ゴールには <code>Not</code> が含まれます：</p>
<pre><code class="language-output error">unsolved goals
⊢ ¬IsThree 4
</code></pre>
<p>実際にそれが関数型であることは、 <code>simp</code> を使用することで露見できます：</p>
<pre><code class="language-leantac">theorem four_is_not_three : ¬ IsThree 4 := by
  simp [Not]
</code></pre>
<pre><code class="language-output error">unsolved goals
⊢ IsThree 4 → False
</code></pre>
<p>ゴールが関数型であるため、<code>intro</code> を使用して引数を仮定に変換できます。
<code>simp</code> を保持する必要はありません、なぜなら <code>intro</code> は <code>Not</code> の定義自体をアンフォールドできるからです：</p>
<pre><code class="language-leantac">theorem four_is_not_three : ¬ IsThree 4 := by
  intro h
</code></pre>
<pre><code class="language-output error">unsolved goals
h : IsThree 4
⊢ False
</code></pre>
<p>この証明では、<code>cases</code> タクティックはすぐにゴールを解決します：</p>
<pre><code class="language-leantac">theorem four_is_not_three : ¬ IsThree 4 := by
  intro h
  cases h
</code></pre>
<p><code>Vect String 2</code> のパターンマッチに <code>Vect.nil</code> のケースを含める必要がないのと同じように、<code>IsThree 4</code> のケース証明に <code>isThree</code> のケースを含める必要はありません。</p>
<h3 id="自然数の不等式"><a class="header" href="#自然数の不等式">自然数の不等式</a></h3>
<p><code>Nat.le</code> の定義にはパラメータとインデックスがあります：</p>
<pre><code class="language-lean">inductive Nat.le (n : Nat) : Nat → Prop
  | refl : Nat.le n n
  | step : Nat.le n m → Nat.le n (m + 1)
</code></pre>
<p>パラメータ <code>n</code> は小さくなければならない数であり、インデックスは <code>n</code> 以上でなければならない数です。
<code>refl</code> コンストラクターは両方の数が等しい場合に使用され、<code>step</code> コンストラクターはインデックスが <code>n</code> より大きい場合に使用されます。</p>
<p>証拠の観点から、 \( n \leq k \) の証明はいくつかの数 \( d \) を見つけることで構成され、 \( n + d = m \) です。
Leanでは、証明は <code>Nat.le.refl</code> コンストラクターに \( d \) インスタンスの <code>Nat.le.step</code> でラップされて構成されます。
各 <code>step</code> コンストラクターはそのインデックス引数に1を加算するため、 \( d \) の <code>step</code> コンストラクターは大きい数に \( d \) を加算します。
たとえば、4が7以下であるという証拠は <code>refl</code> の周りに3つの <code>step</code> で構成されています：</p>
<pre><code class="language-lean">theorem four_le_seven : 4 ≤ 7 :=
  open Nat.le in
  step (step (step refl))
</code></pre>
<p>厳密な未満の関係は、左の数に1を加えることで定義されます：</p>
<pre><code class="language-lean">def Nat.lt (n m : Nat) : Prop :=
  Nat.le (n + 1) m

instance : LT Nat where
  lt := Nat.lt
</code></pre>
<p>4が7より厳密に小さいという証拠は <code>refl</code> の周りに2つの <code>step</code> で構成されています：</p>
<pre><code class="language-lean">theorem four_lt_seven : 4 &lt; 7 :=
  open Nat.le in
  step (step refl)
</code></pre>
<p>これは、<code>4 &lt; 7</code> が <code>5 ≤ 7</code> と等価であるためです。</p>
<h2 id="終了条件の証明"><a class="header" href="#終了条件の証明">終了条件の証明</a></h2>
<p>関数 <code>Array.map</code> は配列を関数で変換し、入力配列の各要素に関数を適用した結果を含む新しい配列を返します。
末尾再帰関数としてそれを書くことは、アキュムレータ内の出力配列を渡す関数に委譲する通常のパターンに従います。
アキュムレータは空の配列で初期化されます。
アキュムレータを渡すヘルパー関数は、配列の現在のインデックスを追跡する引数も取り、それは <code>0</code> から始まります：</p>
<pre><code class="language-lean">def Array.map (f : α → β) (arr : Array α) : Array β :=
  arrayMapHelper f arr Array.empty 0
</code></pre>
<p>ヘルパーは各繰り返しでインデックスがまだ範囲内にあるかどうかをチェックするべきです。
もしそうならば、変換された要素をアキュムレータの末尾に追加しインデックスを <code>1</code> 増やしてループを続けるべきです。
そうでなければ、プログラムは終了しアキュムレータを返すべきです。最初の実装では、Leanは配列インデックスが有効であることを証明できないため失敗します：</p>
<pre><code class="language-lean">def arrayMapHelper (f : α → β) (arr : Array α) (soFar : Array β) (i : Nat) : Array β :=
  if i &lt; arr.size then
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + 1)
  else soFar
</code></pre>
<pre><code class="language-output error">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
α : Type ?u.1704
β : Type ?u.1707
f : α → β
arr : Array α
soFar : Array β
i : Nat
⊢ i &lt; Array.size arr
</code></pre>
<p>しかし、条件式は既に配列インデックスの有効性が必要とする正確な条件（すなわち、<code>i &lt; arr.size</code>）をチェックしています。<code>if</code>に名前を追加すると問題が解決します。なぜなら、それは配列インデックスの戦略が使用できる前提を追加するからです：</p>
<pre><code class="language-lean">def arrayMapHelper (f : α → β) (arr : Array α) (soFar : Array β) (i : Nat) : Array β :=
  if inBounds : i &lt; arr.size then
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + 1)
  else soFar
</code></pre>
<p>しかし、Leanは修正されたプログラムを受け入れません。なぜなら、再帰的な呼び出しは入力コンストラクターのいずれかの引数に対して行われないからです。実際、アキュムレータとインデックスの両方が増えるのではなく、縮小しています：</p>
<pre><code class="language-output error">fail to show termination for
  arrayMapHelper
with errors
argument #6 was not used for structural recursion
  failed to eliminate recursive application
    arrayMapHelper f✝ arr (Array.push soFar (f✝ arr[i])) (i + 1)

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>それにもかかわらず、この関数は終了します。そのため、単に<code>partial</code>とマークすることは不幸です。</p>
<p>なぜ<code>arrayMapHelper</code>は終了するのでしょうか？各繰り返しは、インデックス<code>i</code>が配列<code>arr</code>の範囲内にまだあるかどうかをチェックします。もし範囲内であれば、<code>i</code>は増加し、ループは繰り返します。そうでなければ、プログラムは終了します。<code>arr.size</code>は有限数であるため、<code>i</code>は有限回数しか増加することはできません。各呼び出しで関数の引数が減少するわけではありませんが、<code>arr.size - i</code>はゼロに向かって減少します。</p>
<p>Leanに別の式を使用して終了を指示することを伝えるために、定義の最後に<code>termination_by</code>節を提供できます。<code>termination_by</code>節には2つのコンポーネントがあります：関数の引数の名前と、各呼び出しで減少するようなその名前を使用した式です。<code>arrayMapHelper</code>の場合、最終的な定義は次のようになります：</p>
<pre><code class="language-lean">def arrayMapHelper (f : α → β) (arr : Array α) (soFar : Array β) (i : Nat) : Array β :=
  if inBounds : i &lt; arr.size then
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + 1)
  else soFar
termination_by arrayMapHelper _ arr _ i _ =&gt; arr.size - i
</code></pre>
<p>同様の終了証明は<code>Array.find</code>という関数を書くために使用されます。これは配列内の最初の要素を検索し、その要素とそのインデックスの両方を返します：</p>
<pre><code class="language-lean">def Array.find (arr : Array α) (p : α → Bool) : Option (Nat × α) :=
  findHelper arr p 0
</code></pre>
<p>再び、ヘルパー関数は<code>i</code>が増加するにつれて<code>arr.size - i</code>が減少するために終了します：</p>
<pre><code class="language-lean">def findHelper (arr : Array α) (p : α → Bool) (i : Nat) : Option (Nat × α) :=
  if h : i &lt; arr.size then
    let x := arr[i]
    if p x then
      some (i, x)
    else findHelper arr p (i + 1)
  else none
termination_by findHelper arr p i =&gt; arr.size - i
</code></pre>
<p>すべての終了引数がこれほど簡単なわけではありません。しかし、関数の引数に基づいたいくつかの式が各呼び出しで減少するという基本的な構造は、すべての終了証明において発生します。ときには創造力が必要です。なぜなら、関数が終了する理由を把握するため、そしてときにはLeanが終了引数を受け入れるために追加の証明が必要です。</p>
<h2 id="練習問題-13"><a class="header" href="#練習問題-13">練習問題</a></h2>
<ul>
<li>配列に対して、<code>termination_by</code>節を使用し、末尾再帰アキュムレータ渡し関数を使用して<code>ForM (Array α)</code>インスタンスを実装してください。</li>
<li><code>termination_by</code>節を必要とせず、末尾再帰アキュムレータ渡し関数を使用して配列を反転する関数を実装してください。</li>
<li><code>Array.map</code>、<code>Array.find</code>及び<code>ForM</code>インスタンスをアイデンティティモナドの<code>for ... in ...</code>ループを使用し再実装し、結果のコードを比較してください。</li>
<li><code>for ... in ...</code>ループをアイデンティティモナドで使用し配列反転を再実装してください。それを末尾再帰関数と比較してください。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-markdown"># より多くの不等式

Leanの組み込みの証明自動化は、`arrayMapHelper` と `findHelper` が終了することを確認するのに十分です。
必要だったのは、各再帰呼び出しで減少する値を表す式を提供することだけでした。
しかし、Leanの組み込み自動化は魔法ではなく、しばしばいくつかの助けを必要とします。

## マージソート

終了証明が非自明な関数の一例は `List` 上のマージソートです。
マージソートは2つのフェーズで構成されます：まず、リストは半分に分かれます。
それぞれの半分はマージソートを使用してソートされ、そして結果は二つのソートされたリストを大きなソートされたリストに結合する関数を使用してマージされます。
基底ケースは空リストと単一要素のリストであり、どちらもすでにソートされたとみなされます。

二つのソートされたリストをマージするためには、考えるべき2つの基本ケースがあります：
 1. 入力リストの一方が空の場合、結果はもう一方のリストです。
 2. 両方のリストが空でない場合、それらの頭を比較すべきです。関数の結果は二つの頭のうち小さい方で、それに両方のリストの残りのエントリをマージした結果が続きます。

これはどちらのリストに対しても構造的に再帰的ではありません。
再帰が終了するのは、各再帰呼び出しでどちらかのリストからエントリが削除されるためですが、どちらのリストであっても構いません。
`termination_by` 句は両方のリストの長さの合計を減少値として使用します：
```lean
def merge [Ord α] (xs : List α) (ys : List α) : List α :=
  match xs, ys with
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    match Ord.compare x' y' with
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
termination_by merge xs ys =&gt; xs.length + ys.length
</code></pre>
<p>リストの長さを使用する代わりに、両方のリストを含んだペアを提供することもできます：</p>
<pre><code class="language-lean">def merge [Ord α] (xs : List α) (ys : List α) : List α :=
  match xs, ys with
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    match Ord.compare x' y' with
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
termination_by merge xs ys =&gt; (xs, ys)
</code></pre>
<p>これは、Leanが <code>WellFoundedRelation</code> という型クラスを通じてデータのサイズの概念を組み込んでおり、ペアに対するインスタンスが自動的に、ペアの第一または第二のアイテムが縮小する場合にそれをより小さなものと見なすからです。</p>
<p>リストを分割する簡単な方法は、入力リストの各エントリを二つの交互の出力リストに追加することです：</p>
<pre><code class="language-lean">def splitList (lst : List α) : (List α × List α) :=
  match lst with
  | [] =&gt; ([], [])
  | x :: xs =&gt;
    let (a, b) := splitList xs
    (x :: b, a)
</code></pre>
<p>マージソートは基底ケースに達しているかどうかを確認します。
もし達していれば、入力リストを返します。
そうでなければ、入力を分割し、それぞれの半分をソートした結果をマージします：</p>
<pre><code class="language-lean">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
</code></pre>
<p>Leanのパターンマッチコンパイラーは、<code>if</code>によって導入された仮定 <code>h</code> は <code>xs.length &lt; 2</code> をテストするために一つ以上のエントリを持たないリストを排除しているので、「ケースが不足している」というエラーはありません。
しかし、このプログラムは常に終了しますが、構造的に再帰的ではありません：</p>
<pre><code class="language-output error">fail to show termination for
  mergeSort
with errors
argument #3 was not used for structural recursion
  failed to eliminate recursive application
    mergeSort halves.fst

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>終了する理由は、<code>splitList</code>が常にその入力よりも短いリストを返すからです。
したがって、<code>halves.fst</code> と <code>halves.snd</code> の長さは <code>xs</code> の長さよりも少なくなります。
これは <code>termination_by</code> 句を使って表現することができます：</p>
<pre><code class="language-lean">def mergeSort [Ord α] (xs : List α) : List α :=
  if h : xs.length &lt; 2 then
    match xs with
    | [] =&gt; []
    | [x] =&gt; [x]
  else
    let halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
termination_by mergeSort xs =&gt; xs.length
</code></pre>
<p>この句により、エラーメッセージが変わります。
関数が構造的に再帰的ではないという不満ではなく、 Leanは <code>(splitList xs).fst.length &lt; xs.length</code> の自動証明に失敗したと指摘しています：</p>
<pre><code class="language-output error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
xs : List α
h : ¬List.length xs &lt; 2
halves : List α × List α := splitList xs
⊢ List.length (splitList xs).fst &lt; List.length xs
</code></pre>
<h2 id="リストを分割することはそれを短くする"><a class="header" href="#リストを分割することはそれを短くする">リストを分割することはそれを短くする</a></h2>
<p><code>(splitList xs).snd.length &lt; xs.length</code> を証明することも必要になります。
<code>splitList</code>は二つのリストにエントリを交互に追加するため、両方のステートメントを一度に証明するのが最も簡単で、証明の構造が <code>splitList</code>の実装に使用されたアルゴリズムに従うことができます。
言い換えると、<code>∀(lst : List), (splitList lst).fst.length &lt; lst.length ∧ (splitList lst).snd.length &lt; lst.length</code> を証明するのが最も簡単です。</p>
<p>残念ながら、このステートメントは偽です。
特に、<code>splitList []</code> は <code>([], [])</code> です。両方の出力リストは長さ <code>0</code> であり、これは入力リストの長さ <code>0</code> よりも短くありません。
同様に、<code>splitList [&quot;basalt&quot;]</code> は <code>([&quot;basalt&quot;], [])</code> に評価され、<code>[&quot;basalt&quot;]</code> は <code>[&quot;basalt&quot;]</code> より短くありません。
しかし、<code>splitList [&quot;basalt&quot;, &quot;granite&quot;]</code> は <code>([&quot;basalt&quot;], [&quot;granite&quot;])</code> に評価され、これらの出力リストは入力リストよりも短くなります。</p>
<p>実は、出力リストの長さは常に入力リストの長さ以下ですが、入力リストに少なくとも二つのエントリが含まれている場合にのみ、厳密に短くなります。
前者のステートメントを証明してから、後者のステートメントに拡張するのが最も簡単です。
定理ステートメントから始めます：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
⊢ List.length (splitList lst).fst ≤ List.length lst ∧ List.length (splitList lst).snd ≤ List.length lst
</code></pre>
<p><code>splitList</code>はリストに構造的に再帰的なので、証明は帰納法を使用すべきです。
<code>splitList</code>の構造的再帰は帰納法の証明に完全に一致します：帰納法の基底ケースは再帰の基底ケースに一致し、帰納ステップは再帰呼び出しに一致します。
<code>induction</code> タクティックは2つのゴールを与えます：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; skip
  | cons x xs ih =&gt; skip
</code></pre>
<pre><code class="language-output error">unsolved goals
case nil
α : Type u_1
⊢ List.length (splitList []).fst ≤ List.length [] ∧ List.length (splitList []).snd ≤ List.length []
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
α : Type u_1
x : α
xs : List α
ih : List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList (x :: xs)).fst ≤ List.length (x :: xs) ∧
    List.length (splitList (x :: xs)).snd ≤ List.length (x :: xs)
</code></pre>
<p><code>nil</code> ケースのゴールは、<code>splitList</code> の定義を展開するように指示することにより、単純化を呼び出すことによって証明することができます。なぜなら、空リストの長さは空リストの長さより小さいか等しいからです。
同様に、<code>splitList</code> とともに単純化することにより、<code>cons</code> ケースはゴールの長さに <code>Nat.succ</code> を配置します：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons
α : Type u_1
x : α
xs : List α
ih : List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs) ∧
    List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<p>これは、<code>List.length</code> の呼び出しがリスト <code>x :: xs</code> の頭を消費し、入力リストの長さと最初の出力リストの長さの両方を <code>Nat.succ</code> に変換するためです。</p>
<p>Leanで <code>A ∧ B</code> と書くのは <code>And A B</code> のショートカットです。
<code>And</code> は <code>Prop</code> 宇宙内の構造型です：</p>
<pre><code class="language-lean">structure And (a b : Prop) : Prop where
  intro ::
  left : a
  right : b
</code></pre>
<p>言い換えれば、<code>A ∧ B</code> の証明は <code>left</code> フィールドに <code>A</code> の証明と <code>right</code> フィールドに <code>B</code> の証明が適用された <code>And.intro</code> コンストラクタで構成されています。</p>
<p><code>cases</code> タクティックは、データ型の各コンストラクタまたは提案の潜在的な証明を順番に考慮するための証明を可能にします。
それは再帰を伴わない <code>match</code> 式に対応します。
構造に <code>cases</code> を使用すると、構造が分解され、各フィールドの構造に対する仮定が追加されます。これはパターンマッチ式がプログラムで使用するために構造のフィールドを抽出するようなものです。
構造には一つのコンストラクタしかないので、構造に <code>cases</code> を使用することは追加のゴールではありません。</p>
<p><code>ih</code> は <code>List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs</code> の証明であるので、<code>cases ih</code> を使用すると <code>List.length (splitList xs).fst ≤ List.length xs</code> という仮定と <code>List.length (splitList xs).snd ≤ List.length xs</code> という仮定になります：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons.intro
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs) ∧
    List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<p>証明のゴールも <code>And</code> なので、<code>constructor</code> タクティックを使って <code>And.intro</code> を適用することができ、各引数のゴールが作成されます：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
</code></pre>
<pre><code class="language-output error">unsolved goals
case cons.intro.left
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs)

case cons.intro.right
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<p><code>left</code> ゴールは <code>left✝</code> 仮定に非常に似ていますが、ゴールは不等式の両側を <code>Nat.succ</code> でラップします。
同様に、<code>right</code> ゴールは <code>right✝</code> 仮定に似ていますが、ゴールは <code>Nat.succ</code> を入力リストの長さにのみ追加します。
これらの <code>Nat.succ</code> のラッピングがステートメントの真実を保つことを証明する時がきました。</p>
<h3 id="両側に1を追加する"><a class="header" href="#両側に1を追加する">両側に1を追加する</a></h3>
<p><code>left</code> ゴールの場合、証明すべきステートメントは <code>Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m</code> です。
言い換えれば、もし <code>n ≤ m</code> であれば、両側に1を追加してもこの事実は変わりません。
なぜこれが真実なのでしょうか？
<code>n ≤ m</code> の証明は <code>m - n</code> という <code>Nat.le.step</code> コンストラクタのインスタンスであり、前よりも大きい数値に <code>refl</code> が適用される場合、同じ数の <code>step</code> コンストラクタがラップされます。</p>
<p>より形式的には、証明は <code>n ≤ m</code> の証拠に対する帰納法によるものです。
証拠が <code>refl</code> の場合、それは <code>n = m</code> なので、<code>Nat.succ n = Nat.succ m</code> であり <code>refl</code> を再び使用できます。
証拠が <code>step</code> の場合、帰納法の仮説は <code>Nat.succ n ≤ Nat.succ m</code> の証拠を提供し、目標は <code>Nat.succ n ≤ Nat.succ (Nat.succ m)</code> を示すことです。
これは帰納仮説と一緒に <code>step</code> を使用することによって行われます。</p>
<p>Leanでの定理ステートメントは：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  skip
</code></pre>
<p>エラーメッセージはそれを再確認します：</p>
<pre><code class="language-output error">unsolved goals
n m : Nat
⊢ n ≤ m → Nat.succ n ≤ Nat.succ m
</code></pre>
<p>最初のステップは、仮説 <code>n ≤ m</code> をスコープ内にもたらして名前を付ける <code>intro</code> タクティックを使用することです：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
</code></pre>
<pre><code class="language-output error">unsolved goals
n m : Nat
h : n ≤ m
⊢ Nat.succ n ≤ Nat.succ m
</code></pre>
<p>証明は <code>n ≤ m</code> の証拠の帰納法によるので、次のタクティックは <code>induction h</code> です：</p>
<pre><code class="language-leantac">theorem Nat.succ_le_succ : n ≤ m → Nat.succ n ≤ Nat.succ m := by
  intro h
  induction h
</code></pre>
<p>これにより、<code>Nat.le</code> の各コンストラクタについて一度に二つのゴールが得られます：</p>
<pre><code class="language-output error">unsolved goals
case refl
n m : Nat
⊢ Nat.succ n ≤ Nat.succ n

case step
n m m✝ : Nat
a✝ : Nat.le n m✝
a_ih✝ : Nat.succ n ≤ Nat.succ m✝
⊢ Nat.succ n ≤ Nat.succ (Nat.succ m✝)
</code></pre>
<p><code>refl</code> のゴールは <code>refl</code> を使用して解決することができますが、<code>constructor</code> タクティックが選びます。
<code>step</code> のゴールも <code>step</code> コンストラクタの使用を必要とします：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧
      (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
</code></pre>
<p>これで、対象の <code>And</code> の左右両側のゴールが得られました。</p>
<p>これらのゴールは、<code>And</code> 構造のフィールドに挙げられた名前と同じものです。よって、<code>case</code> タクティック（<code>cases</code> と混同しないように注意）を使って、それぞれに集中することができます：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧ (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
    case left =&gt; skip
    case right =&gt; skip
</code></pre>
<p>単一のエラーではなく、それぞれの <code>skip</code> の上にある二つのメッセージがあります。
<code>left</code> のゴールには、<code>Nat.succ_le_succ</code> を使用できます：</p>
<pre><code class="language-output error">unsolved goals
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ Nat.succ (List.length (splitList xs).snd) ≤ Nat.succ (List.length xs)
</code></pre>
<p>右側のゴールでは、<code>Nat.le_succ_of_le</code> が適合します：</p>
<pre><code class="language-output error">unsolved goals
α : Type u_1
x : α
xs : List α
left✝ : List.length (splitList xs).fst ≤ List.length xs
right✝ : List.length (splitList xs).snd ≤ List.length xs
⊢ List.length (splitList xs).fst ≤ Nat.succ (List.length xs)
</code></pre>
<p>両方の定理には、<code>n ≤ m</code> という前提条件が含まれます。
これらは <code>left✝</code> および <code>right✝</code> の仮定として見つかるため、<code>assumption</code> タクティックで最後のゴールを処理することができます：</p>
<pre><code class="language-leantac">theorem splitList_shorter_le (lst : List α) :
    (splitList lst).fst.length ≤ lst.length ∧ (splitList lst).snd.length ≤ lst.length := by
  induction lst with
  | nil =&gt; simp [splitList]
  | cons x xs ih =&gt;
    simp [splitList]
    cases ih
    constructor
    case left =&gt; apply Nat.succ_le_succ; assumption
    case right =&gt; apply Nat.le_succ_of_le; assumption
</code></pre>
<p>次に、少なくとも二つの要素を含むリストを分割した場合に、それぞれの結果が厳密に短くなることを証明する必要がある実際の定理に戻ります。そのためには次のように始めます：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x✝ : List.length lst ≥ 2
⊢ List.length (splitList lst).fst &lt; List.length lst ∧ List.length (splitList lst).snd &lt; List.length lst
</code></pre>
<p><code>lst</code> が少なくとも二つの要素を含んでいるため、<code>match</code> を使ってそれらを明らかにし、依存型のパターンマッチングを通じて型を詰めることができます：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    skip
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ List.length (splitList (x :: y :: xs)).fst &lt; List.length (x :: y :: xs) ∧
    List.length (splitList (x :: y :: xs)).snd &lt; List.length (x :: y :: xs)
</code></pre>
<p><code>simplify</code> を使うと <code>x</code> と <code>y</code> が取り除かれ、計算されたリストの長さがそれぞれ <code>Nat.succ</code> を増やします：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ Nat.succ (List.length (splitList xs).fst) &lt; Nat.succ (Nat.succ (List.length xs)) ∧
    Nat.succ (List.length (splitList xs).snd) &lt; Nat.succ (Nat.succ (List.length xs))
</code></pre>
<p><code>simplify</code> を <code>simp_arith</code> に置き換えると、これらの <code>Nat.succ</code> コンストラクタが取り除かれます。なぜなら、<code>simp_arith</code> では <code>n + 1 &lt; m + 1</code> が <code>n &lt; m</code> を意味するという事実を利用しているからです：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp_arith [splitList]
</code></pre>
<pre><code class="language-output error">unsolved goals
α : Type u_1
lst : List α
x y : α
xs : List α
x✝ : List.length (x :: y :: xs) ≥ 2
⊢ List.length (splitList xs).fst ≤ List.length xs ∧ List.length (splitList xs).snd ≤ List.length xs
</code></pre>
<p>このゴールは、<code>splitList_shorter_le</code> と一致するので、これを使用して証明を結論付けることができます：</p>
<pre><code class="language-leantac">theorem splitList_shorter (lst : List α) (_ : lst.length ≥ 2) :
    (splitList lst).fst.length &lt; lst.length ∧
      (splitList lst).snd.length &lt; lst.length := by
  match lst with
  | x :: y :: xs =&gt;
    simp_arith [splitList]
    apply splitList_shorter_le
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全な配列インデックス"><a class="header" href="#安全な配列インデックス">安全な配列インデックス</a></h1>
<p><code>Array</code>と<code>Nat</code>のための<code>GetElem</code>インスタンスは、提供された<code>Nat</code>が配列より小さいという証明が必要です。
実際には、これらの証明はしばしば関数にインデックスと共に渡される場合があります。
インデックスと証明を別々に渡すのではなく、<code>Fin</code>と呼ばれる型を使ってインデックスと証明をひとつの値に束ねることができます。
これによってコードが読みやすくなることがあります。
さらに、配列に対する多くの組み込み操作はインデックス引数を<code>Nat</code>ではなく<code>Fin</code>として取るので、これらの組み込み操作を使用するには<code>Fin</code>の使用方法を理解する必要があります。</p>
<p>型<code>Fin n</code>は<code>n</code>未満の数を表します。
言い換えると、<code>Fin 3</code>は<code>0</code>、<code>1</code>、<code>2</code>を意味し、<code>Fin 0</code>は全く値を持ちません。
<code>Fin</code>の定義は<code>Subtype</code>に似ており、<code>Fin n</code>は<code>Nat</code>とそれが<code>n</code>より小さいことの証明を含む構造です：</p>
<pre><code class="language-lean">structure Fin (n : Nat) where
  val  : Nat
  isLt : LT.lt val n
</code></pre>
<p>Leanには、<code>ToString</code>と<code>OfNat</code>のインスタンスが含まれており、<code>Fin</code>値を数値として便利に使用できるようになっています。
つまり、<code>#eval (5 : Fin 8)</code>の出力は<code>{val := 5, isLt := _}</code>のようなものではなく、<code>5</code>です。</p>
<p>与えられた数が上限より大きい場合、<code>OfNat</code>インスタンスの<code>Fin</code>は実行時エラーではなく、上限をモジュロとした値を返します。
これは、<code>#eval (45 : Fin 10)</code>がコンパイル時エラーではなく、<code>5</code>の結果になることを意味します。</p>
<p>返り値として、見つかったインデックスを<code>Fin</code>として返すことは、そのデータ構造にそれがどのように関連しているかをより明確にします。
<a href="programs-proofs/./arrays-termination.html#proving-termination">前節</a>の<code>Array.find</code>は、呼び出し元が直ちに配列を検索するために使用できないインデックスを返します。有効性についての情報が失われているからです。
より具体的な型を使うと、プログラムを著しく複雑にすることなく使用できる値が得られます：</p>
<pre><code class="language-lean">def findHelper (arr : Array α) (p : α → Bool) (i : Nat) : Option (Fin arr.size × α) :=
  if h : i &lt; arr.size then
    let x := arr[i]
    if p x then
      some (⟨i, h⟩, x)
    else findHelper arr p (i + 1)
  else none
termination_by findHelper arr p i =&gt; arr.size - i

def Array.find (arr : Array α) (p : α → Bool) : Option (Fin arr.size × α) :=
  findHelper arr p 0
</code></pre>
<h2 id="練習問題-14"><a class="header" href="#練習問題-14">練習問題</a></h2>
<p><code>Fin.next? : Fin n → Option (Fin n)</code>という関数を書いてください。これは、次に大きい<code>Fin</code>が範囲内であればそれを返し、そうでなければ<code>none</code>を返します。
以下のように</p>
<pre><code class="language-lean">#eval (3 : Fin 8).next?
</code></pre>
<p>が出力するのが</p>
<pre><code class="language-output info">some 4
</code></pre>
<p>となり、また</p>
<pre><code class="language-lean">#eval (7 : Fin 8).next?
</code></pre>
<p>が出力するのが</p>
<pre><code class="language-output info">none
</code></pre>
<p>であることを確認します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="挿入ソートと配列の変異"><a class="header" href="#挿入ソートと配列の変異">挿入ソートと配列の変異</a></h1>
<p>挿入ソートは、ソーティングアルゴリズムにおいて最悪のケースでの時間複雑性が最適ではないものの、それでも多くの有用な特性があります。</p>
<ul>
<li>理解と実装が簡単で直感的</li>
<li>追加のスペースを必要とせず、その場で処理するアルゴリズム</li>
<li>安定したソートアルゴリズム</li>
<li>入力がほぼソートされている場合に迅速</li>
</ul>
<p>その場で処理するアルゴリズムは、Leanがメモリを管理する方法によって、特に有用です。
ある場合では、配列を複製することが通常必要とされる操作を変異に最適化できるかもしれません。
これには、配列での要素の交換が含まれます。</p>
<p>JavaScript、JVM、.NETを含む自動メモリ管理を持つほとんどの言語やランタイムシステムは、トレース型ガベージコレクションを使用しています。
メモリの回収が必要になると、システムはコールスタックやグローバル値のようなルートから始めて、再帰的にポインタを追うことでどの値に到達できるかを決定します。
到達できない値は取り除かれ、メモリが解放されます。</p>
<p>参照カウントは、Python、Swift、Leanを含む多くの言語で使用される、トレース型ガベージコレクションの代替方法です。
参照カウントを使用するシステムでは、メモリ上の各オブジェクトにそのオブジェクトへの参照数を追跡するフィールドがあります。
新しい参照が設定されると、カウンターは増加されます。
参照がなくなると、カウンターは減少します。
カウンターがゼロに達すると、オブジェクトは即座に解放されます。</p>
<p>参照カウントには、トレース型ガベージコレクターと比較して、循環参照によるメモリリークへと繋がる可能性があるという大きな欠点があります。
オブジェクト\( A \)がオブジェクト\( B \)を参照していて、オブジェクト\( B \)がオブジェクト\( A \)を参照している場合、プログラム内の他の何もオブジェクト\( A \)または\( B \)を参照していなくても、これらは決して解放されません。
循環参照は、制御されていない再帰または可変参照から生じます。
Leanはどちらもサポートしていないため、循環参照を構築することは不可能です。</p>
<p>参照カウントは、Leanランタイムシステムのプリミティブがデータ構造の割り当てと解放をチェックし、参照カウントがゼロになりそうな場合、新たにオブジェクトを割り当てる代わりに既存のオブジェクトを再利用することを意味します。
これは、特に大規模な配列を扱う際に特に重要です。</p>
<p>Leanの配列に対する挿入ソートの実装は、以下の基準を満たすべきです：</p>
<ol>
<li><code>partial</code>アノテーションなしでLeanに関数を受け入れさせる</li>
<li>他に参照がない配列が渡された場合、新しい配列を割り当てるのではなく、その場で配列を変更するべきです</li>
</ol>
<p>最初の基準は簡単にチェックできます：Leanが定義を受け入れるならば、それは満たされています。
しかし、2番目はテストする方法を必要とします。
Leanは<code>dbgTraceIfShared</code>と呼ばれる組み込み関数を提供しており、以下のシグネチャを持っています：</p>
<pre><code class="language-lean">#check dbgTraceIfShared
</code></pre>
<pre><code class="language-output info">dbgTraceIfShared.{u} {α : Type u} (s : String) (a : α) : α
</code></pre>
<p>これは文字列と値を引数として取り、値が複数の参照を持っている場合に文字列を使用して標準エラーにメッセージを出力し、値を返します。
これは、厳密には純粋な関数ではありません。
ただし、関数が実際にメモリを再利用できることを開発中にチェックするためにのみ使用されることを意図しています。</p>
<p><code>dbgTraceIfShared</code>の使い方を学ぶ際には、<code>#eval</code>がコンパイルされたコードよりも多くの値を共有していると報告することがあるため、混乱する可能性があります。
エディターで実験するのではなく、<code>lake</code>で実行可能ファイルをビルドすることが重要です。</p>
<p>挿入ソートは二つのループで構成されています。
外側のループはソートされる配列を左から右にポインタを移動させます。
各繰り返しの後、ポインタの左側の配列の領域はソート済みであり、右側の領域がまだソートされていない可能性があります。
内側のループは、ポインタによって指し示される要素を適切な位置が見つかるまで左に移動させ、ループ不変量が復元されます。
つまり、各反復は配列の次の要素をソート済みの領域に挿入します。</p>
<h2 id="内側のループ"><a class="header" href="#内側のループ">内側のループ</a></h2>
<p>挿入ソートの内側のループは尾再帰関数として実装できます。これは、挿入される要素の配列とインデックスを引数とします。
挿入される要素は繰り返し左にある要素と交換され、もしそれが左にある要素より小さいか配列の始まりに達するまで交換が続きます。
内側のループは内部に持っている<code>Nat</code>について構造的再帰的です。これは配列にインデックスをつけるために使用される<code>Fin</code>にあります：</p>
<pre><code class="language-leantac">def insertSorted [Ord α] (arr : Array α) (i : Fin arr.size) : Array α :=
  match i with
  | ⟨0, _⟩ =&gt; arr
  | ⟨i' + 1, _⟩ =&gt;
    have : i' &lt; arr.size := by
      simp [Nat.lt_of_succ_lt, *]
    match Ord.compare arr[i'] arr[i] with
    | .lt | .eq =&gt; arr
    | .gt =&gt;
      insertSorted (arr.swap ⟨i', by assumption⟩ i) ⟨i', by simp [*]⟩
</code></pre>
<p>もしインデックス<code>i</code>が<code>0</code>ならば、ソートされた領域に挿入される要素は領域の始まりに達しており、最小です。
もしインデックスが<code>i' + 1</code>ならば、<code>i'</code>にある要素は<code>i</code>にある要素と比較されるべきです。
<code>i</code>が<code>Fin arr.size</code>である一方で、<code>i'</code>は<code>Nat</code>です。それは<code>i</code>の<code>val</code>フィールドから得られるからです。
それゆえ、<code>i'</code>を<code>arr</code>にインデックスとして使う前に<code>i' &lt; arr.size</code>を証明する必要があります。</p>
<p><code>i' &lt; arr.size</code>を示す証明を含む<code>have</code>表現を省略すると、以下の目標が明らかになります：</p>
<pre><code class="language-output error">unsolved goals
α : Type ?u.7
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
i' : Nat
isLt✝ : i' + 1 &lt; Array.size arr
⊢ i' &lt; Array.size arr
</code></pre>
<p>ヒント<code>Nat.lt_of_succ_lt</code>はLeanの標準ライブラリからの定理です。
そのシグネチャは<code>#check Nat.lt_of_succ_lt</code>で見つけられ、以下のようになります：</p>
<pre><code class="language-output info">Nat.lt_of_succ_lt {n m : Nat} (a✝ : Nat.succ n &lt; m) : n &lt; m
</code></pre>
<p>言い換えれば、これはもし<code>n + 1 &lt; m</code>ならば、<code>n &lt; m</code>であることを示しています。
<code>simp</code>に渡された<code>*</code>は、<code>i</code>から<code>isLt</code>フィールドを使って最終的な証明を得るために<code>Nat.lt_of_succ_lt</code>を組み合わせます。</p>
<p><code>i'</code>を使用して挿入される要素の左の要素が見つかり、二つの要素が比較された後、左にある要素が挿入される要素より小さいか等しいならば、ループは終了し不変量が復元されます。
もし左にある要素が挿入される要素より大きいならば、要素は交換され内側のループは再び始まります。
<code>Array.swap</code>はその両方のインデックスを<code>Fin</code>として取り、<code>i' &lt; arr.size</code>を確立する<code>have</code>によって使用されます。
次の内側ループを通して検討されるインデックスも<code>i'</code>ですが、この場合<code>by assumption</code>だけでは十分ではありません。
これは証明が元の配列<code>arr</code>のために記述されたからであり、二つの要素を交換した結果ではありません。
<code>simp</code>戦術のデータベースには配列の二つの要素を交換するとそのサイズは変わらないという事実が含まれており、<code>[*]</code>引数はそれに加えて<code>have</code>によって導入された前提を利用するように指示します。</p>
<h2 id="外側のループ"><a class="header" href="#外側のループ">外側のループ</a></h2>
<p>挿入ソートの外側のループは、ポインタを左から右に移動させ、各反復で<code>insertSorted</code>を呼び出して、ポインタにある要素を配列の正しい位置に挿入します。
ループの基本的な形は<code>Array.map</code>の実装に似ています：</p>
<pre><code class="language-lean">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
</code></pre>
<p>結果として得られるエラーも、<code>Array.map</code>に<code>termination_by</code>節がない場合に起こるエラーと同じです。これは再帰的な呼び出しの中で毎回減少する引数がないためです：</p>
<pre><code class="language-output error">fail to show termination for
  insertionSortLoop
with errors
argument #4 was not used for structural recursion
  failed to eliminate recursive application
    insertionSortLoop (insertSorted arr { val := i, isLt := h }) (i + 1)

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>終了証明を構築する前に、<code>partial</code>修飾子を使用して定義をテストし、期待通りの答えを返すことを確認すると便利です：</p>
<pre><code class="language-lean">partial def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
</code></pre>
<pre><code class="language-lean">#eval insertionSortLoop #[5, 17, 3, 8] 0
</code></pre>
<pre><code class="language-output info">#[3, 5, 8, 17]
</code></pre>
<pre><code class="language-lean">#eval insertionSortLoop #[&quot;metamorphic&quot;, &quot;igneous&quot;, &quot;sedentary&quot;] 0
</code></pre>
<pre><code class="language-output info">#[&quot;igneous&quot;, &quot;metamorphic&quot;, &quot;sedentary&quot;]
</code></pre>
<h3 id="終了"><a class="header" href="#終了">終了</a></h3>
<p>再度、関数は処理される配列のインデックスとサイズの差が各再帰呼び出しで減少するために終了することになります。
ただし、今回はLeanは<code>termination_by</code>を受け入れません：</p>
<pre><code class="language-lean">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><code class="language-output error">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Nat
h : i &lt; Array.size arr
⊢ Array.size (insertSorted arr { val := i, isLt := h }) - (i + 1) &lt; Array.size arr - i
</code></pre>
<p>問題はLeanが<code>insertSorted</code>が受け取ったものと同じサイズの配列を返すとは知りようがないことです。
<code>insertionSortLoop</code>が終了することを証明するためには、<code>insertSorted</code>が配列のサイズを変えないことをまず証明する必要があります。
エラーメッセージから未証明の終了条件を関数にコピーして<code>sorry</code>で「証明」し、関数を一時的に受け入れることを許可します：</p>
<pre><code class="language-leantac">def insertionSortLoop [Ord α] (arr : Array α) (i : Nat) : Array α :=
  if h : i &lt; arr.size then
    have : (insertSorted arr ⟨i, h⟩).size - (i + 1) &lt; arr.size - i := by
      sorry
    insertionSortLoop (insertSorted arr ⟨i, h⟩) (i + 1)
  else
    arr
termination_by insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><code class="language-output warning">declaration uses 'sorry'
</code></pre>
<p><code>insertSorted</code>は挿入される要素のインデックスに構造的再帰をしているため、基本ケースの証明は帰納法によって行われるべきです。
基本ケースでは、配列は変更されずに返されるため、その長さは変わらないに違いありません。
帰納法のステップのためには、次に小さいインデックスでの再帰呼び出しが配列の長さを変えないことが帰納法の仮定です。
考慮すべきは二つのケースです：要素がソートされた領域に完全に挿入され、配列は変更されずに返された場合はその長さも変わらず、あるいは要素は次のものと交換される前に再帰呼び出しがあります。
しかしながら、配列の二つ要素を交換することはサイズを変えませんし、帰納法の仮定は次のインデックスでの再帰呼び出しは引数としての同じサイズの配列を返すと述べています。
したがって、サイズは変わりません。</p>
<p>英語の定理のステートメントをLeanに翻訳し、この章のテクニックを使って進むことで基本ケースの証明を確立し帰納法ステップで進展を遂げることが十分です：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
</code></pre>
<p>帰納法ステップでの<code>insertSorted</code>を使用した単純化は<code>insertSorted</code>のパターンマッチを明らかにしました：</p>
<pre><code class="language-output error">unsolved goals
case succ
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
⊢ Array.size
      (match compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] with
      | Ordering.lt =&gt; arr
      | Ordering.eq =&gt; arr
      | Ordering.gt =&gt;
        insertSorted
          (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
          { val := j',
            isLt :=
              (_ :
                j' &lt;
                  Array.size
                    (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                      { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>あなたが<code>if</code>や<code>match</code>を含むゴールに直面したとき、<code>split</code>タクティックはコントロールフローの各パスについて1つの新しいゴールを置き換えます。</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split
</code></pre>
<p>さらに、各新しいゴールはそのゴールに到達したブランチを示す仮定を持っています。この場合の名前は<code>heq✝</code>です。</p>
<pre><code class="language-output error">unsolved goals
case succ.h_1
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.lt
⊢ Array.size arr = Array.size arr

case succ.h_2
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.eq
⊢ Array.size arr = Array.size arr

case succ.h_3
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>両方の単純なケースに対する証明を書くのが面倒な場合に<code>split</code>の後に<code>&lt;;&gt; try rfl</code>を追加すると、2つの単純なケースがすぐになくなり、唯一の1つのゴールだけが残ります：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split &lt;;&gt; try rfl
</code></pre>
<pre><code class="language-output error">unsolved goals
case succ.h_3
α : Type u_1
inst✝ : Ord α
arr : Array α
i : Fin (Array.size arr)
j' : Nat
ih : ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>残念ながら、帰納仮説はこのゴールを証明するのに十分ではありません。帰納仮説は<code>insertSorted</code>を<code>arr</code>に対して呼び出すとサイズが変化しないと述べているだけで、証明目標はスワップの結果に対する再帰的呼び出しがサイズを変化させないことを示すことです。証明を成功させるためには、減少したインデックスを引数として使用する_どの_配列に対しても有効な帰納仮説が必要です。</p>
<p><code>induction</code>タクティックの<code>generalizing</code>オプションを使用することで、より強い帰納仮説を得ることができます。このオプションは追加の仮定をコンテキストからベースケース、帰納仮説、および推論ステップの目標を生成するためのステートメントに結合します。<code>arr</code>について一般化することで、より強い仮説をもたらします：</p>
<pre><code class="language-leantac">theorem insert_sorted_size_eq [Ord α] (arr : Array α) (i : Fin arr.size) :
    (insertSorted arr i).size = arr.size := by
  match i with
  | ⟨j, isLt⟩ =&gt;
    induction j generalizing arr with
    | zero =&gt; simp [insertSorted]
    | succ j' ih =&gt;
      simp [insertSorted]
      split &lt;;&gt; try rfl
</code></pre>
<p>この結果として生じるゴールでは、<code>arr</code>は帰納仮説の「すべてのための」ステートメントの一部になっています：</p>
<pre><code class="language-output error">unsolved goals
case succ.h_3
α : Type u_1
inst✝ : Ord α
j' : Nat
ih :
  ∀ (arr : Array α),
    Fin (Array.size arr) →
      ∀ (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
arr : Array α
i : Fin (Array.size arr)
isLt : Nat.succ j' &lt; Array.size arr
x✝ : Ordering
heq✝ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
⊢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>しかしながら、この証明全体は扱いにくいものになりつつあります。次のステップは、スワップの結果の配列の長さを表す変数を導入し、それが<code>arr.size</code>と等しいことを示し、次にその変数が再帰呼び出しの結果から生じる配列の長さとも等しいことを示すことです。これらの等式ステートメントは連鎖させられ、最終的なゴールを証明するために使用することができます。しかしながら、帰納仮説が自動的に十分に強く、変数がすでに導入されているような定理ステートメントを注意深く再構成する方がはるかに容易です。再構成されたステートメントは次のように読めます：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特別な型"><a class="header" href="#特別な型">特別な型</a></h1>
<p>メモリ内でデータがどのように表現されるかを理解することは非常に重要です。
通常、データ型の定義からその表現を理解することができます。
各コンストラクタは、タグと参照カウントを含んだヘッダーを持つメモリ内のオブジェクトに対応します。
コンストラクタの引数は、他のオブジェクトへのポインターによってそれぞれ表現されます。
つまり、<code>List</code>は実際に連結リストであり、<code>structure</code>からフィールドを取り出すことは、実際にポインターをたどることを意味します。</p>
<p>しかしながら、このルールにはいくつかの重要な例外があります。
コンパイラによって特別に扱われる型がいくつか存在します。
例えば、型<code>UInt32</code>は<code>Fin (2 ^ 32)</code>として定義されますが、実行時にはマシンワードに基づく実際のネイティブ実装に置き換えられます。
同様に、<code>Nat</code>の定義は<code>List Unit</code>に似た実装を示唆しているものの、実際の実行時表現では、十分に小さい数値については即時のマシンワードを使用し、より大きな数値については効率的な任意精度の算術ライブラリを使用します。
Leanのコンパイラは、パターンマッチングを使用した定義からこの表現に対応する演算へと変換し、加算や減算などの演算への呼び出しは、下層の算術ライブラリの高速な演算にマップされます。
結局のところ、加算には加数のサイズに比例して時間がかかるべきではありません。</p>
<p>いくつかの型に特別な表現があるという事実は、それらを扱う際に注意が必要であることを意味します。
これらの型のほとんどは、コンパイラによって特別に扱われる<code>structure</code>で構成されています。
これらの構造体では、コンストラクタやフィールドアクセサを直接使用することで、効率的な表現から証明に便利ながら遅いものへの高価な変換がトリガーされる可能性があります。
例えば、<code>String</code>は文字のリストを含む構造体として定義されますが、実行時の文字列の表現はUTF-8を使用し、文字へのポインターの連結リストは使用しません。
文字のリストにコンストラクタを適用すると、UTF-8でエンコードされたバイト配列が生成され、構造のフィールドにアクセスすると、文字列の長さに比例する時間がかかり、UTF-8表現をデコードし、連結リストを割り当てます。
配列も同様に表現されます。
論理的な観点からは、配列は配列要素のリストを含む構造ですが、実行時表現は動的サイズの配列です。
実行時には、コンストラクタはリストを配列に変換し、フィールドアクセサは配列から連結リストを割り当てます。
さまざまな配列操作はコンパイラによって効率的なバージョンに置き換えられ、可能な場合は新しいものを割り当てる代わりに配列を変更します。</p>
<p>型自身と命題の証明は、コンパイルされたコードから完全に消去されます。
言い換えれば、彼らはスペースを取らず、証明の一部として行われたかもしれない計算も同様に消去されます。
これは、証明がインダクティブに定義されたリストとしての文字列や配列への便利なインターフェイスを利用することができ、それらについてのことを証明するために帰納法を使用できることを意味し、プログラム実行中に遅い変換ステップを課すことはありません。
これらの組み込み型の場合、データの便利な論理的表現はプログラムが遅くなることを示唆しません。</p>
<p>構造体型が単一の非型非証明フィールドのみを有する場合は、コンストラクタ自体は実行時に消え、その単一の引数に置き換えられます。
言い換えれば、サブタイプは間接参照の余分な層を持つのではなく、その基礎となる型に同一のものとして表現されます。
同様に、<code>Fin</code>はメモリ内でただの<code>Nat</code>であり、<code>Nat</code>または<code>String</code>の異なる使用を追跡するために単一フィールド構造を作成することができますが、パフォーマンスペナルティは発生しません。
コンストラクタに非型非証明引数がない場合は、コンストラクタも消えて定数値に置き換えられ、その他の場合はポインタが使用される場所に定数値が置かれます。
これは、<code>true</code>、<code>false</code>、および<code>none</code>がヒープ割り当てオブジェクトへのポインターではなく、定数値であることを意味します。</p>
<p>次の型には特別な表現があります：</p>
<table><thead><tr><th>型</th><th>論理的表現</th><th>実行時表現</th></tr></thead><tbody>
<tr><td><code>Nat</code></td><td>各<code>Nat.succ</code>から1つのポインター</td><td>効率的な任意精度整数</td></tr>
<tr><td><code>Int</code></td><td>正または負の値に対するコンストラクタを持つ和型</td><td>効率的な任意精度整数</td></tr>
<tr><td><code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code></td><td>適切な上限を持つ<code>Fin</code></td><td>固定精度のマシン整数</td></tr>
<tr><td><code>Char</code></td><td>有効なコードポイントであることの証明と組み合わさった<code>UInt32</code></td><td>通常の文字</td></tr>
<tr><td><code>String</code></td><td><code>data</code>というフィールドに<code>List Char</code>を含む構造体</td><td>UTF-8エンコードされた文字列</td></tr>
<tr><td><code>Array α</code></td><td><code>data</code>というフィールドに<code>List α</code>を含む構造体</td><td><code>α</code>値へのポインターの詰まった配列</td></tr>
<tr><td><code>Sort u</code></td><td>型</td><td>完全に消去</td></tr>
<tr><td>命題の証明</td><td>証拠としての型の提案されたデータ</td><td>完全に消去</td></tr>
</tbody></table>
<h2 id="練習問題-15"><a class="header" href="#練習問題-15">練習問題</a></h2>
<p><a href="programs-proofs/../type-classes/pos.html"><code>Pos</code>の定義</a>は、Leanが<code>Nat</code>を効率的な型にコンパイルするという利点を活用していません。
実行時には、基本的に連結リストです。
代わりに、Leanの高速な<code>Nat</code>型を内部で使用できるサブタイプを定義することができます。これは<a href="programs-proofs/../functor-applicative-monad/applicative.html#subtypes">サブタイプに関する最初のセクション</a>で説明されています。
実行時には、証明は消去されます。
結果として得られる構造には単一のデータフィールドのみがあり、この新しい表現の<code>Pos</code>は<code>Nat</code>と同一です。</p>
<p>定理 <code>∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0</code> を証明した後、この新しい<code>Pos</code>の表現の<code>ToString</code>および<code>Add</code>のインスタンスを定義します。そして、必要な定理を証明しながら、<code>Mul</code>のインスタンスを定義します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概要-2"><a class="header" href="#概要-2">概要</a></h1>
<h2 id="末尾再帰-1"><a class="header" href="#末尾再帰-1">末尾再帰</a></h2>
<p>末尾再帰とは、再帰コールの結果が直ちに返される再帰プログラムのことです。これらの再帰コールは <em>末尾コール</em> と呼ばれます。
末尾コールは面白い性質を持っており、コール命令ではなくジャンプ命令にコンパイルされ、新しいフレームをスタックにプッシュする代わりに、現行のスタックフレームを再利用できます。
言い換えれば、末尾再帰関数は実質的にループです。</p>
<p>再帰関数を速くする一般的な方法は、それを累積引数形式で書き直すことです。
再帰コールの結果を処理するためにコールスタックを使う代わりに、<em>累積変数</em> と呼ばれる追加の引数を使ってこの情報を集めます。
例えば、リストを逆にする末尾再帰関数の累積変数は、逆順になった既に見たリストエントリを含んでいます。</p>
<p>Leanでは、自己末尾コールのみがループに最適化されます。
言い換えれば、お互いに末尾コールで終わる二つの関数が最適化されることはありません。</p>
<h2 id="参照カウントとその場アップデート"><a class="header" href="#参照カウントとその場アップデート">参照カウントとその場アップデート</a></h2>
<p>Java、C#、そして多くのJavaScript実装で行われているようなトレース型ガベージコレクタを使用する代わりに、Leanではメモリ管理のために参照カウントを使います。
これはメモリ内の各値が、いくつの他の値に参照されているかを追跡するフィールドを持ち、ランタイムシステムが参照が現れたり消えたりするときにこれらのカウントを維持するということを意味します。
参照カウントはPython、PHP、Swiftでも使用されています。</p>
<p>新しいオブジェクトを割り当てるように求められたとき、Leanのランタイムシステムは参照カウントがゼロに減少している既存のオブジェクトを再利用することができます。
また、<code>Array.set</code> や <code>Array.swap</code> のような配列操作は、参照カウントが1の場合に配列を変更することができ、変更されたコピーを割り当てるのではなく配列を突然変異させます。
<code>Array.swap</code>が配列に対する唯一の参照を持っている場合、プログラムの他の部分では配列がコピーされたのか変更されたのかを判断することができません。</p>
<p>効率的なコードをLeanで書くには、末尾再帰を使用し、大きな配列がユニークに使われていることを確認する注意が必要です。
末尾コールは関数の定義を検査することによって特定できますが、値がユニークに参照されているかどうかを理解するためには、プログラム全体を読む必要があります。
デバッグヘルパー <code>dbgTraceIfShared</code> はプログラムの重要な位置で値が共有されていないことをチェックするために使うことができます。</p>
<h2 id="プログラムの正しさを証明する"><a class="header" href="#プログラムの正しさを証明する">プログラムの正しさを証明する</a></h2>
<p>累積引数スタイルでプログラムを書き直したり、実行を速める他の変換を行ったりすることは、プログラムを理解しづらくすることがあります。
明らかに正しいとされる元のプログラムのバージョンを保持し、最適化されたバージョンの実行仕様として使用することが有益である場合があります。
単体テストなどの技術はLeanでも他言語と同じように機能しますが、Leanはすべての可能な入力に対して両方のバージョンの関数が同じ結果を返すことを完全に保証する数学的な証明を使うことができます。</p>
<p>通常、二つの関数が等しいことを証明するには関数の外延性（<code>funext</code> タクティック）を使用します。これは、任意の入力に対して同じ値を返す二つの関数は等しいという原理です。
関数が再帰的である場合、その出力が同じである事を証明するために通常、帰納法が有効な方法です。
通常、関数の再帰的定義は特定の引数で再帰コールを行います；この引数は帰納法で使うのに良い選択です。
場合によっては、帰納法の仮説が十分強くありません。
この問題を解決するには、より一般的な定理のステートメントをどのように構築するかについての考えが通常必要です。その定理のステートメントは十分に強い帰納法の仮説を提供する必要があります。
特に、関数が累積引数バージョンに等しいことを証明するには、任意の初期累積値が元の関数の最終結果にどのように関連しているかを示す定理のステートメントが必要です。</p>
<h2 id="安全な配列インデックス-1"><a class="header" href="#安全な配列インデックス-1">安全な配列インデックス</a></h2>
<p>型 <code>Fin n</code> は <code>n</code> より厳格に小さい自然数を表します。
<code>Fin</code> は &quot;finite&quot;（有限）の略です。
サブタイプと同様に、<code>Fin n</code> は <code>Nat</code> を含み、この <code>Nat</code> が <code>n</code> より小さいという証明を持つ構造体です。
<code>Fin 0</code> のタイプには値がありません。</p>
<p><code>arr</code> が <code>Array α</code> の場合、<code>Fin arr.size</code> は常に <code>arr</code> に適したインデックスの数字を含んでいます。
<code>Array.swap</code> などの組み込みの配列オペレーターは分離された証明オブジェクトではなく、<code>Fin</code> の値を引数として取ります。</p>
<p>Leanは <code>Fin</code> のためにほとんどの有用な数値型クラスのインスタンスを提供します。
<code>Fin</code> の <code>OfNat</code> インスタンスは <code>Fin</code> が受け入れることができる数よりも大きい数字が提供された場合にコンパイル時に失敗するのではなく、モジュラー算術を実行します。</p>
<h2 id="暫定的な証明"><a class="header" href="#暫定的な証明">暫定的な証明</a></h2>
<p>証明を実際に行うことなく、ある声明が証明されたと仮定することは便利な場合があります。
これは、別の証明での書き換えに適していることや、配列アクセスが安全であることを決定すること、または再帰コールが元の引数よりも小さい値で行われることを示すことなどのタスクに対して、証明が適しているかどうかを確かめる際に有用です。
実際には他の証明がより役立つことが判明した場合に証明に時間を費やすことは非常にイライラすることです。</p>
<p><code>sorry</code> タクティックはLeanが本物の証明であるかのように声明を暫定的に受け入れるようにさせます。
これはC#で <code>NotImplementedException</code> を投げるスタブメソッドに似ているとみなすことができます。
<code>sorry</code> を使って依存する証明にはLeanで警告が含まれます。</p>
<p>注意してください！
<code>sorry</code> タクティックは <em>任何の</em> 声明を証明できます、偽の声明でさえも。
<code>3 &lt; 2</code> を証明すると、配列アクセスがランタイムまで残り、プログラムが予期せずクラッシュする原因となる可能性があります。
<code>sorry</code> を使うことは開発中に便利ですが、コードに残しておくことは危険です。</p>
<h2 id="終了証明"><a class="header" href="#終了証明">終了証明</a></h2>
<p>再帰関数が構造再帰を使用していない場合、Leanは自動的にそれが終了するかどうかを決定することができません。
これらの状況では、関数はただ <code>partial</code> とマークされるかもしれません。
しかし、関数が終了することの証明を提供することも可能です。</p>
<p>部分関数は重要な欠点を持っています：彼らは型検査や証明の間に展開されることはありません。
これは、Leanの対話型定理証明者としての価値を彼らに適用することができないことを意味します。
さらに、終了すると期待される関数が常に終了することを示すことによって、バグの潜在的な源泉をひとつ減らすことができます。</p>
<p>関数の終わりに許される <code>termination_by</code> 節を使って、再帰関数がなぜ終了するかの理由を指定することができます。
この節は関数の引数を各再帰コールに対してより小さいと期待される式にマッピングします。
減少するかもしれない式の例には、配列への成長するインデックスと配列のサイズとの差、各再帰コールで半分に切られたリストの長さ、または再帰コールの度に正確に一方が縮小するペアのリストがあります。</p>
<p>Leanはいくつかの式が各呼び出しで減少することを自動的に決定できる証明の自動化を含んでいますが、多くの興味深いプログラムは手作業による証明を必要とします。
これらの証明は値ではなく証明を地元で提供するための <code>let</code> のバージョンである <code>have</code> で提供することができます。</p>
<p>再帰関数を書く良い方法は、それらを <code>partial</code> と宣言し、テストでデバッグすることで彼らが正しい答えを返すまでにします。
それから、<code>partial</code> を除去し <code>termination_by</code> 節で置き換えることができます。
Leanは各再帰コールに対して、証明が必要な警告を表示します、その中には証明が必要なステートメントが含まれます。
これらのステートメントは <code>have</code> に配置され、証明は <code>sorry</code> です。
Leanがプログラムを受け入れ、それがまだそのテストをパスする場合、最後のステップはLeanがそれを受け入れることを可能にする定理を実際に証明することです。
このアプローチは、バグのあるプログラムが終了することを証明する時間を無駄にすることを防ぐことができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="次のステップ"><a class="header" href="#次のステップ">次のステップ</a></h1>
<p>この本は、Leanにおける関数型プログラミングの非常に基本的な内容、そしてほんの少しの対話型定理証明について紹介しています。依存型関数言語であるLeanを使うことは深いトピックであり、多くのことが言えます。あなたの興味に依存して、Lean 4を学ぶための以下のリソースが役立つかもしれません。</p>
<h2 id="leanの学習"><a class="header" href="#leanの学習">Leanの学習</a></h2>
<p>Lean 4自体については以下のリソースで説明されています：</p>
<ul>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean4/">Lean 4での定理証明</a> — Leanを使った証明を書くためのチュートリアルです。</li>
<li><a href="https://leanprover.github.io/lean4/doc/">Lean 4マニュアル</a> — 言語とその機能のリファレンスを提供しています。執筆時点ではまだ不完全ですが、この本よりも詳細に多くのLeanの側面について説明しています。</li>
<li><a href="https://djvelleman.github.io/HTPIwL/">Leanでそれを証明する方法</a> — ペーパーペンによる数学的証明の書き方を紹介する著名な教科書 <a href="https://www.cambridge.org/highereducation/books/how-to-prove-it/6D2965D625C6836CD4A785A2C843B3DA#overview"><em>How To Prove It</em></a> のLeanベースの対応物です。</li>
<li><a href="https://github.com/arthurpaulino/lean4-metaprogramming-book">Lean 4のメタプログラミング</a> — インフィックスオペレーターや記法からマクロ、カスタムタクティクス、そして完全なカスタム組み込み言語に至るまで、Leanの拡張メカニズムの概観を提供します。</li>
<li><a href="https://leanprover.github.io/functional_programming_in_lean/">Leanでの関数型プログラミング</a> — 再帰に関するジョークを楽しむ読者にとって興味深いものかもしれません。</li>
</ul>
<p>しかしながら、Leanの学習を続ける最良の方法は、コードを読んで書き始めること、そして立ち往生した時にはドキュメントを参照することです。さらに、<a href="https://leanprover.zulipchat.com/">Lean Zulip</a> は他のLeanユーザーと出会い、助けを求め、他の人を助けるための優れた場所です。</p>
<h2 id="標準ライブラリ"><a class="header" href="#標準ライブラリ">標準ライブラリ</a></h2>
<p>Lean自体は、箱から出してすぐには非常に最小限のライブラリしか含んでいません。Leanは自己ホスト型で、含まれているコードはLean自体を実装するのにちょうど十分です。多くのアプリケーションでは、より大きな標準ライブラリが必要です。</p>
<p><a href="https://github.com/leanprover/std4">std4</a> は進行中の標準ライブラリで、Leanのコンパイラ自体の範囲外である多くのデータ構造、タクティクス、型クラスのインスタンス、関数を含んでいます。<code>std4</code>を使うためには、最初にあなたが使用しているLean 4のバージョンと互換性のあるコミットをその履歴から見つけることがステップの一つです（つまり、<code>lean-toolchain</code>ファイルがプロジェクトのものと一致しているもの）。そして、適切なバージョンの<code>COMMIT_HASH</code>を以下のようにあなたの<code>lakefile.lean</code>のトップレベルに追加します：</p>
<pre><code class="language-lean">require std from git
  &quot;https://github.com/leanprover/std4/&quot; @ &quot;COMMIT_HASH&quot;
</code></pre>
<h2 id="leanにおける数学"><a class="header" href="#leanにおける数学">Leanにおける数学</a></h2>
<p>数学者向けのほとんどのリソースはLean 3用に書かれています。広範囲にわたる選択肢は<a href="https://leanprover-community.github.io/learn.html">コミュニティサイト</a>で利用可能です。Lean 4で数学を始めるには、数学ライブラリ<code>mathlib</code>をLean 3からLean 4に移植するプロセスに参加することがおそらく最も簡単です。さらなる情報については、<a href="https://github.com/leanprover-community/mathlib4"><code>mathlib4</code> README</a>をご覧ください。</p>
<h2 id="コンピューターサイエンスでの依存型の使用"><a class="header" href="#コンピューターサイエンスでの依存型の使用">コンピューターサイエンスでの依存型の使用</a></h2>
<p>CoqはLeanと多くの共通点がある言語です。コンピューターサイエンティストにとって、対話型の教科書である<a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a> シリーズは、コンピューターサイエンスにおけるCoqの適用に関して素晴らしい導入を提供します。LeanとCoqの基礎的なアイデアは非常に似ており、スキルはシステム間で容易に転用することができます。</p>
<h2 id="依存型を使ったプログラミング"><a class="header" href="#依存型を使ったプログラミング">依存型を使ったプログラミング</a></h2>
<p>インデックス付きファミリーや依存型を使用してプログラムを構築することに興味のあるプログラマーにとって、Edwin Bradyの<a href="https://www.manning.com/books/type-driven-development-with-idris"><em>Type Driven Development with Idris</em></a> は優れた導入書を提供しています。Coqのように、IdrisもLeanの近い親戚ですが、タクティクスを欠いています。</p>
<h2 id="依存型の理解"><a class="header" href="#依存型の理解">依存型の理解</a></h2>
<p><a href="https://thelittletyper.com/"><em>The Little Typer</em></a> は、公式には論理学やプログラミング言語理論を研究していないが、依存型理論の核となるアイデアを構築することに関心のあるプログラマー向けの本です。上記のリソースはできるだけ実践的であろうとしていますが、_The Little Typer_はプログラミングからの概念を使って非常に基本的から構築される依存型理論へのアプローチを提示します。免責事項：<em>Leanでの関数型プログラミング</em> の著者は、<em>The Little Typer</em> の著者でもあります。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
