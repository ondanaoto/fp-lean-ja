```markdown
# 概要

## 評価と実行

副作用とは、ファイルの読み込み、例外の投げ、工業機械の発動など、数学的表現の評価を超えたプログラム実行の側面を指します。
ほとんどの言語では評価中に副作用が発生可能ですが、Leanはそうではありません。
代わりにLeanには`IO`という型があり、副作用を使用するプログラムの_記述_を表しています。
これらの記述は、特定の計算を行うためにLean式の評価器を呼び出す言語の実行時システムによって実行されます。
型`IO α`の値は_`IO`アクション_と呼ばれます。
最も簡単なのは`pure`で、その引数を返し、実際の副作用はありません。

`IO`アクションは、全世界を引数として取り、副作用が発生した新しい世界を返す関数としても理解することができます。
`IO`ライブラリは、裏では世界が二重に、作られたり、破壊されたりすることはないように保証しています。
この副作用モデルは実際には実装できません。なぜなら全宇宙がメモリに収まりきるほど小さくはないからです。しかし現実世界は、プログラムを通じて渡されるトークンによって表されることができます。

プログラムが開始されるとき、`IO`アクション`main`が実行されます。
`main`は3つの型のうちの1つを持つことができます：
 * `main : IO Unit`は、コマンドライン引数を読むことができず常に退出コード`0`を返す簡単なプログラムに使用されます。
 * `main : IO UInt32`は、成功や失敗をシグナルすることができるが引数を取らないプログラムに使用されます。
 * `main : List String → IO UInt32`は、コマンドライン引数を取り、成功や失敗をシグナルするプログラムに使用されます。

## `do`記法

Lean標準ライブラリは、ファイルの読み込み・書き込みや標準入力・標準出力との対話など、副作用を代表とする基本的な`IO`アクションを提供します。
これらの基本的な`IO`アクションを使い、`do`記法を使用して大きな`IO`アクションに構成します。`do`記法は、副作用を持つプログラムの記述を作成するための組み込みのドメイン特化言語です。
`do`式は、_ステートメント_のシーケンスを含みます。これらは次のものがあります：
 * `IO`アクションを代表する式、
 * `let`と`:=`を使った通常のローカル定義は、提供された式の値を参照する名前を定義します。
 * `let`と`←`を使ったローカル定義は、提供された式の値を実行する結果を参照する名前を定義します。

`do`で書かれた`IO`アクションは、一つのステートメントずつ実行されます。

さらに、`do`の直下にある`if`や`match`式は、各ブランチに独自の`do`があるかのように暗黙的に考慮されます。
`do`式の内部では、_ネストされたアクション_は左矢印が直接カッコの下にある式です。
Leanコンパイラはそれらを最も近い包含する`do`まで暗黙的に持ち上げ、その後それらに一意な名前を与えます。
この一意な名前が、ネストされたアクションの原始的な場所に置き換えられます。

## プログラムのコンパイルと実行

`main`定義で構成される単一ファイルのLeanプログラムは`lean --run FILE`を使用して実行できます。
これはシンプルなプログラムを素早く始める良い方法ですが、ほとんどのプログラムは最終的に複数ファイルのプロジェクトになり、実行する前にコンパイルする必要があります。

Leanプロジェクトは、依存関係とビルド設定に関する情報を含めたライブラリと実行可能ファイルのコレクションである_パッケージ_によって構成されます。
パッケージはLeanビルドツールであるLakeを使って記述されます。
新しいディレクトリでLakeパッケージを作成するには`lake new`を使用し、また現在のディレクトリで作成するには`lake init`を使用します。
Lakeパッケージ構成は別のドメイン特化言語です。
プロジェクトをビルドするには`lake build`を使用します。

## 部分性

表現の評価の数学的モデルを守るための一つの結果は、すべての式が値を持つ必要があるということです。
これは、データ型のすべてのコンストラクタを網羅していない不完全なパターンマッチ、および無限ループに陥る可能性のあるプログラムを除外します。
Leanはすべての`match`式がすべてのケースを網羅し、すべての再帰関数が構造的に再帰的であるか終了の明示的な証明を持っていることを保証します。

ただし、POSIXストリームのような無限データを処理するために、実際に無限にループする可能性があるプログラムが必要な場合があります。
Leanは逃げ路を提供します：`partial`とマークされた関数の定義は終了する必要はありません。
これにはコストが伴います。
型がLean言語の第一級の一部であるため、関数は型を返すことができます。
しかし、部分関数は型チェック中に評価されません。なぜなら無限ループに陥る関数は型チェッカーを無限ループに結びつける可能性があるからです。
さらに、部分関数の定義を検査できない数学的証明は、それを使用するプログラムの形式的証明にはあまり適していません。
```