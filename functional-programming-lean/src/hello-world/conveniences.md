# 追加の便利機能


## ネストされたアクション

`feline` の多くの関数では、`IO` アクションの結果に名前をつけて、すぐさま一度だけ使用するという繰り返しパターンが見られます。
例えば、 `dump` では以下のようになります。
```lean
{{#include ../../../examples/feline/2/Main.lean:dump}}
```
このパターンは `stdout` で発生しています。
```lean
{{#include ../../../examples/feline/2/Main.lean:stdoutBind}}
```
同様に、`fileStream` には以下のスニペットが含まれています。
```lean
{{#include ../../../examples/feline/2/Main.lean:fileExistsBind}}
```

Lean が `do` ブロックをコンパイルする際、かっこ直下の左矢印で構成される表現は最も近い外側の `do` にリフトされ、その結果は一意の名前に束縛されます。
この一意の名前は表現の元に置き換えられます。
これにより、`dump` は次のように書くこともできます。
```lean
{{#example_decl Examples/Cat.lean dump}}
```
このバージョンの `dump` では、一度だけ使用される名前を導入することを避けられるため、プログラムを大幅に簡素化することができます。
Lean がネストした式コンテキストからリフトする `IO` アクションは _ネストされたアクション_ と呼ばれます。

`fileStream` も同じテクニックを使って簡略化することができます。
```lean
{{#example_decl Examples/Cat.lean fileStream}}
```
この場合、`handle` のローカル名もネストされたアクションを使って排除することができたかもしれませんが、その結果表現は長くて複雑になっていたでしょう。
ネストされたアクションを使うことはしばしば良いスタイルですが、中間結果に名前を付けることが依然として役立つことがあります。

しかし、ネストされたアクションはあくまで周囲の `do` ブロックで発生する `IO` アクションのための短い記法に過ぎないことを覚えておくことは重要です。
実行によって発生する副作用は同じ順番で発生し、副作用の実行は式の評価と交互には行われません。
これが混乱を招く例として、以下に実行されたことを世界に告げるデータを返すヘルパー定義を挙げてみましょう。
```lean
{{#example_decl Examples/Cat.lean getNumA}}

{{#example_decl Examples/Cat.lean getNumB}}
```
これらの定義は、ユーザー入力を検証したり、データベースを読んだり、ファイルを開いたりするかもしれないより複雑な `IO` コードの代わりを意図しています。

A の数が 5 の場合は `0` を、それ以外の場合は B の数を印刷するプログラムは以下のように書かれます。
```lean
{{#example_decl Examples/Cat.lean testEffects}}
```
しかし、このプログラムは意図されていたものよりも副作用（例えばユーザー入力へのプロンプトやデータベースの読み取りなど）を持っているかもしれません。
`getNumA` の定義は、それが常に `5` を返すことを明確にしており、したがってプログラムは B の数を読まないはずです。
しかし、プログラムを実行すると次の出力が得られます。
```output info
{{#example_out Examples/Cat.lean runTest}}
```
`getNumB` が実行されたのは、`test` がこの定義と等しいからです。
```lean
{{#example_decl Examples/Cat.lean testEffectsExpanded}}
```
これはネストされたアクションが _最も近い外側の_ `do` ブロックにリフトされるというルールによるものです。
`if` の分岐は `do` ブロックでそれ自体がステートメントでないため、暗黙のうちに `do` ブロックでラップされていませんでした—ステートメントは `a` を定義する `let` でした。
事実、そのようなラップはできなかったのです。なぜなら条件式の型は `Nat` であり、`IO Nat` ではないからです。

## `do` のための柔軟なレイアウト

Lean での `do` 式は空白に敏感です。
`do` 内の各 `IO` アクションまたはローカル束縛は、それぞれ独自の行で開始されることが期待されており、すべて同じインデントを持つべきです。
ほとんどすべての `do` の使用はこの方法で書かれるべきです。
しかし、まれに手動で空白やインデントを制御する必要がある場合や、多くの小さなアクションを単一行にまとめて便利と感じる場合もあります。
そのような場合、改行はセミコロンに置き換えることができ、インデントは中括弧に置き換えることができます。

例えば、以下のすべてのプログラムは等価です。
```lean
{{#example_decl Examples/Cat.lean helloOne}}

{{#example_decl Examples/Cat.lean helloTwo}}

{{#example_decl Examples/Cat.lean helloThree}}
```

慣用的な Lean コードでは `do` で中括弧を使うことは非常にまれです。

## `#eval` を使った `IO` アクションの実行

Lean の `#eval` コマンドは、`IO` アクションを実行するために使用することができるだけでなく、評価するためにも使用されます。
通常、Lean ファイルに `#eval` コマンドを追加すると、Lean は提供された式を評価し、結果として得られる値を文字列に変換し、ツールチップと情報ウィンドウにその文字列を表示します。
`IO` アクションは文字列に変換することができないため失敗するのではなく、`#eval` はそれらを実行し、それらの副作用を実行します。
実行の結果が `Unit` 値 `()` の場合、結果の文字列は表示されませんが、文字列に変換できる型である場合は、Lean は結果として得られる値を表示します。

これは、以前の `countdown` と `runActions` の定義を考えると、
```lean
{{#example_in Examples/HelloWorld.lean evalDoesIO}}
```
は以下を表示します。
```output info
{{#example_out Examples/HelloWorld.lean evalDoesIO}}
```
これは `IO` アクションを実行したことによって得られた出力であり、アクション自体の不透明な表現ではありません。
言い換えれば, `IO` アクションに対しては、`#eval` は提供された式を _評価_ だけでなく、結果として得られるアクション値を _実行_ します。

`#eval` を使って `IO` アクションを素早くテストすることは、プログラム全体をコンパイルして実行するよりもはるかに便利です。
しかし、いくつかの制限があります。
例えば、標準入力からの読み取りは単に空の入力を返すことになります。
さらに、`IO` アクションは Lean がユーザーに提供する診断情報を更新する必要があるたびに再実行され、これは予測不可能なタイミングで発生することがあります。
ファイルの読み書きを行うアクションは、例えば、不便なタイミングでそうするかもしれません。