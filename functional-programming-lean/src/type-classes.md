# オーバーローディングとタイプクラス

多くの言語では、組込みのデータ型は特別な扱いを受けます。
例えば、C言語やJavaでは、`+`を使用して`float`型や`int`型を加算できますが、サードパーティライブラリーの任意精度数値には使用できません。
同様に、数値リテラルは組み込み型では直接使用できますが、ユーザー定義の数値型ではそうはいきません。
他の言語では、_オーバーロード_ メカニズムを提供し、同じ演算子に新しい型に対する意味を与える機能があります。
C++やC#などの言語では、さまざまな組み込み演算子をオーバーロードでき、コンパイラは型チェッカーを使用して特定の実装を選択します。

数値リテラルや演算子に加えて、多くの言語は関数やメソッドのオーバーローディングを許可しています。
C++、Java、C#、Kotlinでは、引数の数や型が異なる複数のメソッド実装が許されています。
コンパイラは引数の数とその型を使って、どのオーバーロードが意図されたものかを判断します。

関数と演算子のオーバーローディングは重要な制限を持っています：ポリモーフィックな関数は、特定のオーバーロードが存在する型に対して誘導することができません。
例えば、文字列、バイト配列、ファイルポインタに対してオーバーロードされたメソッドが定義されている場合でも、これらのいずれかで動作する第二のメソッドを書く方法はありません。
代わりに、この第二のメソッド自体がオリジナルのメソッドの各型に対してオーバーロードされる必要があり、単一のポリモーフィックな定義ではなく多くのボイラープレートな定義が必要になります。
この制限のもう一つの結果として、いくつかの演算子（たとえばJavaにおける等価演算子）は、必ずしも意味があるわけではないにも関わらず、 _すべて_ の引数の組み合わせに対して定義されてしまいます。
プログラマーが非常に注意深くなければ、これによりプログラムが実行時にクラッシュしたり、静かに不正な結果を計算してしまうことになります。

Leanは、Haskellで先駆された_タイプクラス_ というメカニズムを使用してオーバーローディングを実装しており、ポリモーフィズムとうまく連携する方法で演算子、関数、リテラルのオーバーローディングを可能にします。
タイプクラスは、オーバーロード可能な操作のコレクションを説明します。
これらの操作を新しい型に対してオーバーロードするには、新しい型に対するそれぞれの操作の実装を含む_インスタンス_ を作成します。
たとえば、`Add`というタイプクラスが加算を許容する型を記述し、`Nat`に対する`Add`のインスタンスは`Nat`の加算の実装を提供します。

オブジェクト指向言語に慣れている人には、_クラス_ と_インスタンス_ の用語は混乱を招くかもしれません。なぜなら、それらはオブジェクト指向言語のクラスやインスタンスと密接な関係はありません。
しかし、共通のルーツを共有しています：日常言語では、用語 "クラス" はいくつかの共通属性を持つグループを指します。
オブジェクト指向プログラミングのクラスも確かに共通の属性を持つオブジェクトのグループを表しますが、言語レベルの特定のメカニズムを指す用語でもあります。
タイプクラスも、共通の属性を持つ型（具体的には、特定の操作の実装）を記述する手段ですが、オブジェクト指向プログラミングで見つかるクラスとは他に共通点はあまりありません。

Leanのタイプクラスは、JavaやC#の_インターフェイス_ にはるかに類似しています。
タイプクラスもインターフェイスも、型や型のコレクションに実装される概念的に関連する一連の操作を記述します。
同様に、タイプクラスのインスタンスは、実装されたインターフェイスによって指示されたJavaやC#クラスのコードに似ているのではなく、JavaやC#クラスのインスタンスに似ています。
JavaやC#のインターフェイスと異なり、タイプの作者がアクセスできないタイプクラスのインスタンスが与えられることがあります。
この点で、彼らはRustのトレイトに非常に似ています。