```markdown
# オーバーローディングとタイプクラス

多くの言語では、組み込みのデータ型は特別な扱いを受けています。
例えば、C言語やJavaでは、`+`を使用して`float`型や`int`型の数値を加算できますが、サードパーティライブラリの任意精度数値には適用できません。
同様に、数値リテラルは組み込み型では直接使用可能ですが、ユーザー定義の数値型では使用できない場合があります。
他の言語では、_オーバーロード_ 機構を提供することで、既存の演算子を新しい型に対する意味を持たせる機能を備えています。
C++やC#といった言語では、多様な組み込み演算子をオーバーロード可能にしており、コンパイラによる型チェックを利用して特定の実装を選択します。

数値リテラルや演算子と合わせて、多くの言語が関数やメソッドのオーバーローディングも許可しています。
C++、Java、C#、Kotlinでは、引数の数や型が異なる複数のメソッドの実装を容認しています。
コンパイラは、引数の数とその型を根拠にどのオーバーロードが意図されているかを判断します。

しかし、関数や演算子のオーバーローディングには大きな制約があります：ポリモーフィックな関数は特定のオーバーロードが存在する型に対して一般化することはできません。
たとえば、文字列、バイト配列、ファイルポインタに対してオーバーロードされたメソッドがあっても、これらどれかで動作する汎用的なメソッドを書く方法は存在しません。
この代わりに、その汎用メソッド自体をオリジナルのメソッドでサポートされる各型に対して再度オーバーロードする必要があり、これは単一のポリモーフィックな定義ではなく、多くのボイラープレートな定義を要求します。
この制限のもう一つの結果として、いくつかの演算子（例えばJavaの等価演算子）は、意味を成さない場合もありますが、_全て_ の引数の組み合わせに対して定義されてしまうことがあります。
プログラマが非常に注意深く行動しなければ、これによってプログラムが実行時にクラッシュするか、静かに不正確な結果を導出してしまう危険性があります。

Leanは、Haskellによって始められた_タイプクラス_ というメカニズムを用いてオーバーローディングを実装しており、ポリモーフィズムとうまく合わせて、演算子や関数、リテラルのオーバーローディングを可能にします。
タイプクラスは、オーバーロード可能な操作の集合を記述しています。
新しい型に対してこれらの操作をオーバーロードするには、新しい型に適合する各操作の実装を含む_インスタンス_ を生成します。
例えば、`Add`というタイプクラスが加算可能な型を規定しており、`Nat`型に対する`Add`のインスタンスは、`Nat`型の加算の実装を提供します。

オブジェクト指向言語に慣れ親しんでいる人々にとっては、_クラス_ と_インスタンス_ という用語は混乱を招くかもしれません。というのも、これらはオブジェクト指向言語におけるクラスやインスタンスとは異なる概念だからです。
しかし、これらは共通の起源を持っています：日常言語において "クラス" という用語は一般的にいくつかの共通属性を持つグループを指します。
オブジェクト指向プログラミングのクラスは、このような共通の属性を持つオブジェクトの集合を表しますが、それは特定の言語レベルのメカニズムを指す用語です。
タイプクラスも、共通の属性を持つ型（具体的には特定の操作の実装）を記述する方法ですが、オブジェクト指向プログラミングで見られるクラスとはまた異なります。

Leanのタイプクラスは、JavaやC#の_インターフェース_ に非常に似ています。
タイプクラスもインターフェースも、型や型の集合に実装されるべき概念的に関連する一連の操作を記述します。
同様に、タイプクラスのインスタンスは、JavaやC#のインターフェースに実装されるコードに似てはいますが、JavaやC#のクラスのインスタンスに似たものです。
ただし、JavaやC#のインターフェースと異なり、タイプクラスのインスタンスは、その型の著者がアクセスできない場合においても提供され得ます。
この点で、それらはRustのトレイトに非常に似ています。
```