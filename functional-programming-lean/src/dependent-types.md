# プログラミングにおける依存型

ほとんどの静的型付けプログラミング言語では、型の世界とプログラムの世界の間には隔たりが存在します。
型とプログラムはそれぞれ異なる文法を持ち、別々の時点で用いられます。
通常、型はコンパイル時にプログラムが特定の不変条件に従っていることを検証するために使われます。
一方プログラムは実行時に計算を行うために実装されます。
これらが相互作用する際は、型ケース演算子の「instance-of」チェックや、型チェッカーへのキャスト演算子によって実行時まで使用できない情報を提供する形で行われることが一般的です。
つまり、この相互作用では、型がプログラムの世界へ挿入され、限定された実行時の意味を持つようになるわけです。

しかし、Leanはこのような厳格な区分を設けていません。
Leanにおいては、プログラムが型を算出し、型にはプログラムを含むことができます。
プログラムを型に配置することにより、その完全な計算能力をコンパイル時に利用できますし、関数から型を返す能力により、型はプログラミングプロセスにおける第一級の市民となります。

_依存型_ とは、非型の式を含む型のことを意味します。
依存型の典型例としては、関数に名前付き引数を渡すことが挙げられます。
例えば、関数 `natOrStringThree` は、渡された `Bool` の値に応じて自然数か文字列のどちらかを返します。
```lean
{{#example_decl Examples/DependentTypes.lean natOrStringThree}}
```

依存型の他の例には以下のようなものがあります：
 * [ポリモーフィズムに関する導入セクション](getting-to-know/polymorphism.md)には、引数の値に依存する関数の返り値の型をもつ `posOrNegThree` が含まれます。
 * [`OfNat` 型クラス](type-classes/pos.md#literal-numbers)は使われる具体的な自然数リテラルに依存します。
 * 検証器の例で使われる [`CheckedInput` 構造体](functor-applicative-monad/applicative.md#validated-input)は、検証が発生した年に依存します。
 * [サブタイプ](functor-applicative-monad/applicative.md#subtypes)は特定の値に対する命題を含んでいます。
 * [配列のインデックス指定](props-proofs-indexing.md)の正当性に関する全ての関心のある命題が、値を含む型であり、したがって依存型であるとされています。

依存型は、型システムの能力を著しく拡張します。
引数の値に基づいて変化する戻り値の型を可能にし、その結果、他の型システムでは型付けが難しいプログラムを容易に作成することができます。
同時に、依存型は関数の返り値を制限する型シグネチャを可能にし、コンパイル時に強力な不変条件を強制することを許可します。

しかし、依存型を使ったプログラミングは非常に複雑になる可能性があり、関数型プログラミングを超えるスキルが必要になってきます。
表現豊かな仕様を満たすことは複雑となりがちで、実際には自らに束縛を課し、それによってプログラムを完成させることができないリスクもあります。
一方で、このプロセスを通じて新しい認識に到達することもありえ、それは達成可能な洗練された型によって表現されるでしょう。
この章では依存型プログラミングの表面をかい摘んでおり、それ自体が深いトピックで、本一冊に値する内容です。