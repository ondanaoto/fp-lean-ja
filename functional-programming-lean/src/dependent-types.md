# 依存型を用いたプログラミング

ほとんどの静的型付けプログラミング言語では、型の世界とプログラムの世界との間には隔たりがあります。
型とプログラムには異なる文法があり、異なる時点で使用されます。
型は通常、コンパイル時にプログラムが特定の不変条件に従っていることを検証するために使用されます。
プログラムは実行時に計算を行うために使用されます。
両者が相互作用するときは、"instance-of"チェックのような型ケース演算子や、ランタイムで検証されるまで他には利用不可能な情報を型チェッカーに提供するキャスト演算子の形で通常行われます。
言い換えると、この相互作用は型がプログラムの世界に挿入され、限定的な実行時意味を持つようになることから成ります。

Leanは、この厳格な分離を課しません。
Leanでは、プログラムが型を計算し、型がプログラムを含むことができます。
型にプログラムを配置することで、その完全な計算能力をコンパイル時に利用でき、関数から型を返す能力により、型はプログラミングプロセスにおいて第一級の参加者となります。

_依存型_とは、非型の式を含む型のことです。
依存型の一般的な源泉は、関数への名前付き引数です。
たとえば、関数 `natOrStringThree` は、渡された `Bool` に応じて自然数または文字列のいずれかを返します：
```lean
{{#example_decl Examples/DependentTypes.lean natOrStringThree}}
```

依存型のさらなる例としては以下のものがあります：
 * [ポリモーフィズムについての導入セクション](getting-to-know/polymorphism.md)には、関数の戻り値の型が引数の値に依存する `posOrNegThree` が含まれています。
 * [`OfNat` 型クラス](type-classes/pos.md#literal-numbers)は使用される具体的な自然数リテラルに依存しています。
 * 検証器の例で使用される [`CheckedInput` 構造](functor-applicative-monad/applicative.md#validated-input)は、検証が発生した年に依存しています。
 * [サブタイプ](functor-applicative-monad/applicative.md#subtypes)は特定の値を参照する命題を含んでいます。
 * [配列インデックス記法](props-proofs-indexing.md)の有効性を判断する命題を含む、本質的にすべての興味深い命題は値を含む型であり、したがって依存型です。

依存型は、型システムの能力を大幅に強化します。
引数の値に基づいて分岐する戻り値の柔軟性により、他の型システムでは容易に型を付けることができないプログラムを作成することができます。
同時に、依存型は関数から返される値を制限する型シグネチャを許可し、コンパイル時に強力な不変条件を強制することを可能にします。

しかし、依存型を用いたプログラミングはかなり複雑になり得ますし、関数型プログラミングを超える一連のスキルが必要です。
表現力に富んだ仕様は満たすことが複雑になることがあり、自分を結びつけてプログラムを完成させることができないというリスクが実際にあります。
一方で、このプロセスは新しい理解につながることがあり、それは達成可能な精緻化された型に表現されます。
この章では依存型プログラミングの表面を掻い摘んでいますが、それは独自の本一冊に値する深いトピックです。