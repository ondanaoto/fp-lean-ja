# 小休止: 戦術、帰納、そして証明

## 証明とユーザーインターフェースに関する注意

この本は、証明が一度に書かれてLeanに提出され、Leanが残された作業についてのエラーメッセージで返答するかのように証明のプロセスを提示しています。実際にLeanと対話するプロセスはもっと快適です。Leanはカーソルを通じて証明に関する情報を提供し、証明を簡単にする多くのインタラクティブな機能があります。詳細については、ご使用のLean開発環境のドキュメントを参照してください。

この本のアプローチは証明を段階的に構築し、その結果として現れるメッセージを示すことで、Leanが証明の執筆中にどのようなインタラクティブなフィードバックを提供するかを示していますが、それは専門家が使うプロセスよりもはるかに遅いです。同時に、不完全な証明が完全さに向かって進化することを見ることは、証明に関する有用な視点です。証明の執筆におけるスキルが向上するにつれて、Leanのフィードバックがエラーのようには感じられず、自身の思考プロセスをサポートするものと感じるようになるでしょう。インタラクティブなアプローチを学ぶことは非常に重要です。

## 再帰と帰納

前章の `plusR_succ_left` と `plusR_zero_left` という関数は、二つの視点から見ることができます。一方で、これらは命題に対する証拠を組み立てる再帰的関数で、他の再帰的関数がリスト、文字列、あるいは他のデータ構造を構築するようなものです。また他方で、これらは _数学的帰納法_ による証明に対応しています。

数学的帰納法は、以下の二ステップで自然数に対して命題を証明する技法です：
 1. 命題が \\( 0 \\) に対して成り立つことを示します。これを _基底ケース_ といいます。
 2. ある任意に選んだ数 \\( n \\) に対して命題が成り立つと仮定すると、 \\( n + 1 \\) に対しても成り立つことを示します。これを _帰納ステップ_ といい、\\( n \\) に対して命題が成立するという仮定を _帰納仮説_ といいます。

_全ての_ 自然数に対して個別に命題をチェックすることは不可能なため、帰納法は原理的には任意の特定の自然数に拡張できる証明を書く手段を提供します。例えば、数 3 に対する具体的な証明が必要であれば、まず基底ケースを使い、その後帰納ステップを三度用いて、0、1、2、そして最終的に 3 に対する命題を示すことによって構築することができます。このようにして、それは全ての自然数に対する命題を証明します。

## 帰納戦術

帰納法による証明を `congrArg` のような補助関数を使う再帰的関数として書くのは、証明の背後にある意図を表現するのに常にうまくいくわけではありません。再帰的関数は確かに帰納法の構造を持っていますが、それらはおそらく証明の _符号化_ とみなされるべきでしょう。さらに、Leanの戦術システムは、再帰的関数を明示的に書くことによって得られない証明の構築を自動化する数多くの機会を提供しています。Leanは証明全体を単一の戦術ブロックで実行する帰納 _戦術_ を提供します。裏で、Leanは帰納法の使用に対応する再帰的関数を構築します。

`plusR_zero_left` を帰納戦術で証明するには、まずその署名を書いて（これは本当に証明なので `theorem` を使います）、定義の本体として `by induction k` を使用します：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_1}}
```
その結果として生じるメッセージは、二つの目標があることを示しています：
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_1}}
```
戦術ブロックは、Leanの型チェッカーがファイルを処理する間に実行されるプログラムで、Cプリプロセッサマクロのようなずっと強力なものです。戦術は実際のプログラムを生成します。

戦術言語には多数の目標があり得ます。各目標は、いくつかの仮定を伴う型から成り立っています。これらは、プレースホルダーとしてのアンダースコアを使うことに類似しています。目標における型は証明されるべきものを表し、仮定はスコープ内にあり使用可能なものを表します。`case zero` のケースでは仮定はなく、型は `Nat.zero = Nat.plusR 0 Nat.zero` となります。これは定理のステートメントで `k` の代わりに `0` を使ったものです。`case succ` のケースでは、「n✝」と「n_ih✝」という名前の2つの仮定があります。裏で、`induction` 戦術は全体的な型を洗練する依存型のパターンマッチを作成し、「n✝」はパターンの中の `Nat.succ` への引数を表します。仮定 `n_ih✝` は、生成された関数を `n✝` に再帰的に呼び出した結果を表します。その型は定理全体の型であり、ただ `k` の代わりに `n✝` を使っています。「case succ」のゴールの一部として満たされるべき型は、全体の定理のステートメントであり、「k」の代わりに「Nat.succ n✝」が使われています。

`induction` 戦術の使用から生じる二つの目標は、数学的帰納法の説明における基底ケースと帰納ステップに対応しています。基底ケースは `case zero` です。`case succ` では、「n_ih✝」は帰納仮説に対応し、全体の「case succ」は帰納ステップです。

証明を書く次のステップは、順番に二つの目標に焦点を合わせることです。`do` ブロックで "nothing" を示すために `pure ()` を使うことができるように、戦術言語には "何もしない" というステートメント `skip` もあります。これは、戦術が必要であるがまだどれを使うべきかはっきりしないときに使用することができます。`induction` ステートメントの最後に `with` を追加することはパターンマッチングに似た構文を提供します：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_2a}}
```
二つの `skip` ステートメントにはそれぞれメッセージが関連付けられています。最初のものは基底ケースを示しています：
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_2a}}
```
二番目のものは帰納ステップを示しています：
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_2b}}
```
帰納ステップでは、ダガー付きのアクセスできない名前が `succ` の後に提供された名前、すなわち「n」と「ih」に置き換えられています。

`induction ... with` の後のケースはパターンではありません。それらはゴールの名前に続いてゼロ個以上の名前から成り立っています。名前はゴールに導入された仮定のために使用されます。ゴールが導入するよりも多くの名前を提供するとエラーとなります：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_3}}
```
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_3}}
```

基底ケースに焦点を当てると、`rfl` 戦術は再帰的関数内で使うのと同じようによく機能します：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_4}}
```
再帰的関数バージョンの証明では、型注釈が期待される型を理解しやすいものにしました。戦術言語では、ゴールを解決しやすくするために特定の方法で変換する多くの方法があります。`unfold` 戦術は、定義された名前をその定義に置き換えます：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_5}}
```
今、ゴールの等式の右側が `Nat.plusR 0 (Nat.succ n)` ではなく `Nat.plusR 0 n + 1` になりました：
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_5}}
```

関数群のような `congrArg` やオペレーターのような `▸` に訴える代わりに、等式の証明を使って証明ゴールを変換する戦術があります。最も重要なのは `rw` で、これは等式の証明のリストを受け取り、ゴールの左側を右側で置き換えます。これは `plusR_zero_left` の中でほとんど正しいことを行います：
```leantac
{{#example_in Examples/Induction.lean plusR_ind_zero_left_6}}
```
しかし、書き換えの方向が間違っていました。`n` を `Nat.plusR 0 n` で置き換えることにより、ゴールをより単純ではなく複雑にしました：
```output error
{{#example_out Examples/Induction.lean plusR_ind_zero_left_6}}
```
これは `rewrite` への呼び出しで `ih` の前に左矢印を配置することで修正できます。これは等式の右側を左側で置き換えるように指示します：
```leantac
{{#example_decl Examples/Induction.lean plusR_zero_left_done}}
```
この書き換えは等式の両側を同一にし、Leanは独自に `rfl` を処理してくれます。証明は完成です。

## 戦術ゴルフ

今までのところ、戦術言語はその真価を示していません。上記の証明は再帰的関数よりも短くなく、単に全Lean言語ではなくドメイン固有言語で書かれているだけです。しかし、戦術での証明はより短く、より簡単、そしてより保守しやすくある可能性があります。ゴルフのゲームでより低いスコアが良いのと同様に、戦術ゴルフでの証明でより短いのが良いです。

`plusR_zero_left` の帰納ステップは、簡約戦術 `simp` を使って証明することができます。`simp` を単独で使っても助けにはなりません：
```leantac
{{#example_in Examples/Induction.lean plusR_zero_left_golf_1}}
```
```output error
{{#example_out Examples/Induction.lean plusR_zero_left_golf_1}}
```
しかし、`simp` は定義群を使うように設定することができます。`simp` に `Nat.plusR` の定義を考慮に入れるように依頼すると、より簡単なゴールになります：
```leantac
{{#example_in Examples/Induction.lean plusR_zero_left_golf_2}}
```
```output error
{{#example_out Examples/Induction.lean plusR_zero_left_golf_2}}
```
特に、ゴールは現在帰納仮説と同一です。簡約化が単純な等式のステートメントを自動的に証明するだけでなく、`Nat.succ A = Nat.succ B` のようなゴールも `A = B` で置き換えるため、帰納仮説 `ih` がちょうど正しい型なので、`exact` 戦術がそれを使うべきであることを示すことができます：
```leantac
{{#example_decl Examples/Induction.lean plusR_zero_left_golf_3}}
```

しかし、「exact」の使用はややもろいです。証明を「ゴルフ」化する間に帰納仮説の名前が変更されることがあり、それによってこの証明が機能しなくなる可能性があります。`assumption` 戦術は、_全ての_ 仮定がそれに一致する場合に現在のゴールを解決します：
```leantac
{{#example_decl

```leantac
{{#example_decl Examples/Induction.lean plusR_zero_left_golf_done}}
```

このように、`assumption` 戦術を使用することで、ゴールの名前を覚える必要なく、現在のゴールに一致する任意の仮定を使って直ちに解決できます。これが、特に戦術ゴルフの文脈では好まれる理由です。証明のロバスト性を向上させ、将来の変更に対しても安定性を保つために役立つからです。

## まとめ

戦術による証明は、Leanの強力なインターフェイスを通じて、証明の構築を大いに自動化することができます。この章では、特に帰納法に焦点を当て、戦術を使用して証明を簡略化し、保守しやすくする方法を見てきました。

証明のプロセスはしばしば反復的であり、特定の戦術のセットを試すことから始まります。その後、少しずつ改善していき、よりコンパクトで理解しやすい証明へと進化させていくものです。

Lean における戦術言語は、日時点では、より堅牢で読みやすい証明を作成するために必要な柔軟性を提供します。しかし、戦術ゴルフのアプローチは、時として証明をより短くしようとするあまり、読みやすさや明確さを犠牲にする可能性もあるということを忘れてはいけません。状況に応じて適切なバランスを見つけることが、良い証明を構築する上での鍵となります。

各戦術の詳細や応用については、Leanのドキュメントや、詳細なチュートリアルを参照してください。実践を通じて、それぞれの戦術がどのような役割を果たすのか、どのように利用していくのかの感覚をつかむことができるでしょう。

証明者の皆様がLeanの戦術を使われる際には、この章で紹介したテクニックや戦術のアイデアが役に立つことを願っています。そして、それぞれの証明が少しずつでも洗練されていくことで、より強固で elegant(エレガント)な形で知識を積み上げていく喜びを感じていただければ幸いです。