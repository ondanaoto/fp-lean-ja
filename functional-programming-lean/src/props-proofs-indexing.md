# 休憩：命題、証明、および添字

多くの言語と同様に、Leanは配列やリストへの添字に四角い括弧を使用します。
たとえば、`woodlandCritters`が次のように定義されている場合：
```lean
{{#example_decl Examples/Props.lean woodlandCritters}}
```
個々の要素は抽出することができます：
```lean
{{#example_decl Examples/Props.lean animals}}
```
しかし、4番目の要素を抽出しようとすると、実行時エラーではなくコンパイル時エラーが発生します：
```lean
{{#example_in Examples/Props.lean outOfBounds}}
```
```output error
{{#example_out Examples/Props.lean outOfBounds}}
```
このエラーメッセージは、Leanが`3 < List.length woodlandCritters`であることを自動的に数学的に証明しようとしたが、それができなかったことを言っています。つまり、検索が安全であるということです。範囲外のエラーは一般的なバグの一種であり、Leanはプログラミング言語および定理証明者としての二重の性質を利用して、できるだけ多くのものを排除しようとしています。

これがどのように機能するかを理解するには、3つの重要なアイデア、すなわち命題、証明、および戦術について理解する必要があります。

## 命題と証明

_命題_ は、真か偽かのどちらかである文です。
以下はすべて命題です：

 * 1 + 1 = 2
 * 加法は可換である
 * 素数は無限に存在する
 * 1 + 1 = 15
 * パリはフランスの首都である
 * ブエノスアイレスは韓国の首都である
 * すべての鳥は飛べる

一方、意味不明の文は命題ではありません。
以下はどれも命題ではありません：

 * 1 + 緑 = アイスクリーム
 * すべての首都は素数である
 * 少なくと​​も1つのゴーグはフリープである

命題には2種類あります。一つは純粋に数学的であり、概念の定義のみに依存しているもの。もう一つは、世界についての事実です。
Leanのような定理証明者は、前者のカテゴリに関心があり、ペンギンの飛行能力や都市の法的地位については何も言うことはありません。

_証明_ は命題が真であると確信させる議論です。
数学的な命題に対するこれらの議論は、関連する概念の定義と論理的議論の規則を用いて行われます。
ほとんどの証明は人が理解するために書かれており、多くの面倒な詳細を省いています。
Leanのようなコンピュータ支援の定理証明者は、数学者が多くの詳細を省略して証明を書くことを可能にするように設計されており、ソフトウェアの責任は不足している明示的なステップを埋めることです。
これにより、見落としや間違いの可能性が減少します。

Leanでは、プログラムのタイプは、それをどのように操作できるかを記述します。
例えば、`Nat → List String`という型のプログラムは、`Nat`引数を取って文字列のリストを生成する関数です。
言い換えると、それぞれの型はその型のプログラムとして何が数えられるかを指定します。

Leanでは、命題は実際には型です。
それらはその声明が真であることの証拠として何が数えられるかを指定します。
その証拠を提供することで命題が証明されます。
一方、命題が偽であれば、この証拠を構築することは不可能になります。

例えば、命題「1 + 1 = 2」はLeanで直接書くことができます。
この命題の証拠はコンストラクタ`rfl`で、これは_反射律_の略です：
```lean
{{#example_decl Examples/Props.lean onePlusOneIsTwo}}
```
一方、`rfl`は偽の命題「1 + 1 = 15」を証明しません：
```lean
{{#example_in Examples/Props.lean onePlusOneIsFifteen}}
```
```output error
{{#example_out Examples/Props.lean onePlusOneIsFifteen}}
```
このエラーメッセージは、「1 + 1」が直接「2」に評価されるので、両側が既に同じ数字であるときに`rfl`が二つの式が等しいことを証明できることを示しています。これにより、`onePlusOneIsTwo`が受け入れられることになります。
ちょうど`Type`が`Nat`、`String`、`List (Nat × String × (Int → Float))`などのデータ構造と関数を表す型を記述するように、`Prop`は命題を記述します。

命題が証明されると、それを_定理_と呼びます。
Leanでは、定理を宣言する場合には`def`の代わりに`theorem`キーワードで宣言するのが慣例です。
これにより、読者はどの宣言が数学的証明として読まれるべきものか、どの宣言が定義として読まれるべきかを見分けることができます。
一般に、証明では、命題が真であることの証拠があるということが重要であり、提供されたのが_どの_証拠であるかはそれほど重要ではありません。
一方で、定義では、常に0を返す加法の定義は明らかに間違っているので、選ばれた値が非常に重要です。

以前の例は次のように書き換えることができます：
```lean
{{#example_decl Examples/Props.lean onePlusOneIsTwoProp}}
```

## 戦術

証明は通常、直接証拠を提供するのではなく_戦術_を使って書かれます。
戦術は、命題のための証拠を構築するための小さなプログラムです。
これらのプログラムは、証明されるべきステートメント（_ゴール_と呼ばれます）と、それを証明するために利用可能な前提を追跡する_証明状態_で動作します。
ゴールに対して戦術を実行すると、新しいゴールを含む新しい証明状態になります。
すべてのゴールが証明されたときに、証明は完了です。

戦術で証明を書くには、定義を`by`で始めます。
`by`を書くと、次のインデントされたブロックの終わりまでLeanが戦術モードに入ります。
戦術モードでは、Leanは現在の証明状態について継続的なフィードバックを提供します。
戦術で書かれた`onePlusOneIsTwo`はまだ非常に短いです：
```leantac
{{#example_decl Examples/Props.lean onePlusOneIsTwoTactics}}
```
`simp`戦術は「単純化」の略で、Lean証明の働き者です。
それはゴールをできるだけ単純な形に書き換え、証明の非常に小さな部分を扱います。
特に、それは単純な等式ステートメントを証明します。
舞台裏では、詳細な正式な証明が構築されていますが、`simp`を使うことでこの複雑さを隠します。

戦術は複数の理由で便利です：
 1. 多くの証明は、最小限の詳細まで書き出されると複雑で退屈であり、戦術はこれらの興味のない部分を自動化することができます。
 2. 戦術で書かれた証明は時間の経過とともにメンテナンスが容易です。柔軟な自動化は定義への小さな変更を容易にします。
 3. 単一の戦術が多くの異なる定理を証明することができるため、Leanは舞台裏で戦術を使用することができ、ユーザーが手動で証明を書く必要性から解放します。たとえば、配列の検索にはインデックスが範囲内であることの証明が必要であり、戦術はユーザーがそれについて心配する必要がないように、通常その証明を構築することができます。

舞台裏では、添字表記は検索操作が安全であることを証明するために戦術を使用しています。
この戦術は特定の算術同一性を考慮に入れて構成された`simp`です。