# 特別な型

データのメモリ内の表現を理解することは非常に重要です。
通常、データ型の定義からその表現を理解することができます。
各コンストラクタは、タグと参照カウントを含むヘッダーを持つメモリ内のオブジェクトに対応します。
コンストラクタの引数はそれぞれ、他のオブジェクトへのポインタによって表現されます。
言い換えると、`List`は本当にリンクリストであり、`structure`からフィールドを抽出することは実際にはポインタを追跡することに過ぎません。

しかし、このルールにはいくつかの重要な例外があります。
コンパイラによって特別に扱われる型がいくつかあります。
例えば、型`UInt32`は`Fin (2 ^ 32)`として定義されていますが、実行時には機械語に基づいた実際のネイティブ実装に置き換えられます。
同様に、`Nat`の定義は`List Unit`に似た実装を示唆していますが、実際の実行時表現では、十分に小さい数の場合は直接の機械語を使用し、大きい数の場合は効率的な任意精度算術ライブラリを使用します。
Leanコンパイラは、パターンマッチングを使用する定義からこの表現に適切な操作に変換し、足し算や引き算のような操作への呼び出しは、基盤となる算術ライブラリからの高速な操作にマップされます。
結局のところ、加算が加数のサイズに比例して時間がかかるべきではありません。

いくつかの型が特別な表現を持っているという事実は、それらを扱う際に注意が必要であることも意味しています。
これらの型のほとんどは、コンパイラによって特別に扱われる`structure`で構成されています。
これらの構造体では、コンストラクタやフィールドアクセサを直接使用することで、効率的な表現から証明に適した遅いものへの高価な変換を引き起こすことがあります。
例えば、`String`は文字のリストを含む構造体として定義されていますが、実行時の文字列表現はUTF-8を使用し、ポインタのリンクリストは使用しません。
文字のリストにコンストラクタを適用すると、UTF-8でそれらをエンコードしたバイト配列が作成され、構造体のフィールドにアクセスする際には、UTF-8表現をデコードしリンクリストを割り当てるために文字列の長さに比例する時間がかかります。
配列も同様に表現されます。
論理的な観点からは、配列は配列要素のリストを含む構造体ですが、実行時の表現は動的にサイズ変更可能な配列です。
実行時には、コンストラクタはリストを配列に変換し、フィールドアクセサは配列からリンクリストを割り当てます。
コンパイラによって、可能な場合は配列を変更しつつ新たに割り当てるのではなく、配列操作は効率の良いバージョンに置き換えられます。

コンパイルされたコードからは、型自体および命題の証明が完全に削除されます。
つまり、彼らは空間を取らず、証明の一部として実行された可能性がある計算も同様に削除されます。
これは、証明が証明に便利なインターフェイスを文字列や配列として帰納的に定義されたリストを利用し、プログラムが実行されている間に遅い変換ステップを課すことなく、それらについてのことを証明するために帰納法を使用することができることを意味します。
これらの組み込み型の場合、データの便利な論理的表現がプログラムが遅くなければならないということを意味しません。

構造型が単一の非型非証明フィールドのみを持っている場合、コンストラクタ自体が実行時に消え、その単一の引数に置き換えられます。
つまり、サブタイプは追加の間接層ではなく、その基礎となる型と同一に表現されます。
同様に、`Fin`はメモリ内で`Nat`であり、`Nat`や`String`の異なる使用を追跡するために単一フィールド構造を作成することができますが、パフォーマンスペナルティを支払うことはありません。
コンストラクタが非型非証明の引数を持たない場合、コンストラクタも消えてしまい、通常はポインタが使用される場所に定数値に置き換えられます。
これは、`true`、`false`、`none`がヒープ割り当てオブジェクトへのポインタではなく、定数値であることを意味します。

以下の型には特別な表現があります：

| 型                                     | 論理的表現                                                               | 実行時表現                               |
|----------------------------------------|----------------------------------------------------------------------|------------------------------------------|
| `Nat`                                  | 各`Nat.succ`から一つのポインタ                                        | 効率的な任意精度整数                      |
| `Int`                                  | 正か負かの値のコンストラクタを持つ和型、それぞれに`Nat`を含む           | 効率的な任意精度整数                      |
| `UInt8`, `UInt16`, `UInt32`, `UInt64`  | 適切な上限を持つ`Fin`                                                | 固定精度の機械整数                         |
| `Char`                                 | それが有効なコードポイントであるという証明とペアになった`UInt32`        | 通常の文字                               |
| `String`                               | `data`というフィールドで`List Char`を含む構造体                      | UTF-8エンコードされた文字列               |
| `Array α`                              | `data`というフィールドで`List α`を含む構造体                         | `α`の値へのポインターの圧縮配列           |
| `Sort u`                               | 型                                                                       | 完全に消去                                |
| 命題の証明                                 | 証拠の型として考慮される場合に提案されるデータ                           | 完全に消去                                |

## 演習

[`Pos`の定義](../type-classes/pos.html)は、Leanが`Nat`を効率的な型にコンパイルするという点を利用していません。
実行時には、基本的にリンクリストです。
代わりに、最初のセクションで説明されている[サブタイプに関する項](../functor-applicative-monad/applicative.md#subtypes)で説明されているように、Leanの高速な`Nat`型を内部的に使用できるサブタイプを定義することができます。
実行時には、その証明は消去されます。
その結果、この新たな`Pos`の表現は`Nat`と同一です。

命題`∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0`を証明した後で、この新しい`Pos`の表現の`ToString`および`Add`のインスタンスを定義します。次に、必要な定理を途中で証明しながら、`Mul`のインスタンスを定義してください。