# 概要

## 末尾再帰

末尾再帰とは、再帰呼び出しの結果をすぐに返し、他の方法で利用しない再帰のことです。
このような再帰呼び出しを _末尾呼び出し_ と呼びます。
末尾呼び出しは、関数呼び出し命令ではなくジャンプ命令にコンパイル可能であり、新しいスタックフレームを追加する代わりに現在のスタックフレームを再利用することができるという点で興味深いです。
言い換えれば、末尾再帰関数は実際にはループです。

再帰関数を高速化する一般的な方法は、その関数をアキュムレータ渡しスタイルで書き直すことです。
再帰呼び出しの結果を何に使用するかを呼び出しスタックで記憶するのではなく、_アキュムレータ_ と呼ばれる追加の引数を使用してこの情報を収集します。
例えば、リストを逆順にする末尾再帰関数のアキュムレータは、すでに見たリストエントリを逆順に含んでいます。

Leanでは、自分自身の末尾呼び出しだけがループに最適化されます。
つまり、互いに末尾呼び出しで終わる二つの関数は最適化されません。

## 参照カウントとインプレース更新

Java、C#、ほとんどのJavaScriptの実装で行われているトレース型ガーベージコレクションの代わりに、Leanはメモリ管理のために参照カウントを使用します。
これは、メモリ内の各値がそれを参照する他の値の数を追跡するフィールドを含み、実行時システムが参照が現れたり消えたりするにつれてこれらのカウントを維持することを意味します。
参照カウントはPython、PHP、Swiftでも使用されています。

新しいオブジェクトの割り当てを求められたとき、Leanの実行時システムは参照カウントがゼロに減少する既存のオブジェクトをリサイクルすることができます。
さらに、`Array.set`や`Array.swap`のような配列操作は、参照カウントが1の場合、変更されたコピーを割り当てるのではなく、配列を変更します。
`Array.swap`が配列に対する唯一の参照を持っている場合、プログラムの他の部分は配列がコピーされたのではなく変更されたとは認識できません。

Leanで効率的なコードを書くには、末尾再帰の使用と、大きな配列をユニークに使用することを確認する注意が必要です。
末尾呼び出しは関数の定義を検査することで識別できますが、値がユニークに参照されているかどうかを理解するには、プログラム全体を読む必要があるかもしれません。
デバッグヘルパー `dbgTraceIfShared`は、値が共有されていないことをチェックするプログラムの重要な位置で使用できます。

## プログラムの正しさを証明する

プログラムをアキュムレータ渡しスタイルで書き直したり、それを高速化するための他の変換を行ったりすると、理解が難しくなることがあります。
最適化されたバージョンに対する実行可能な仕様として、より明確に正しいと思われる元のバージョンを保持しておくと役立ちます。
ユニットテストなどの技術はLeanでも他の言語と同様にうまく機能しますが、Leanは機能の両バージョンが_全ての可能な_入力に対して同じ結果を返すことを完全に保証する数学的証明の使用も可能にします。

通常、二つの関数が等しいことを証明するには、関数外延性（`funext`戦術）を使用します。これは、ある二つの関数がすべての入力に対して同じ値を返す場合に等しいという原則です。
関数が再帰的である場合、その出力が同じであることを証明するためには通常帰納法が有効な方法です。
通常、関数の再帰的定義は、ある特定の引数に対して再帰呼び出しを行うので、この引数は帰納のための良い選択です。
場合によっては、帰納仮説が十分に強くありません。
この問題を解決するには、帰納仮説が十分に強いことを提供する、より一般的な定理の主張を構築する方法について考える必要があります。
特に、関数がアキュムレータ渡しバージョンと同等であることを証明するためには、任意の初期アキュムレータ値を元の関数の最終結果と関連付ける定理の主張が必要です。

## 安全な配列インデックス

`Fin n`型は、`n`より厳密に小さい自然数を表します。
`Fin`は"finite"（有限）の略です。
サブタイプと同様に、`Fin n`は`Nat`とこの`Nat`が`n`より小さいことの証明を含む構造です。
`Fin 0`の型の値は存在しません。

`arr`が`Array α`である場合、`Fin arr.size`は常に`arr`に適切なインデックスである数を含みます。
`Array.swap`のような組み込みの配列演算子の多くは、分離された証明オブジェクトではなく、`Fin`値を引数として取ります。

Leanは、`Fin`に対して最も有用な数値型クラスのインスタンスを提供します。
`Fin`の`OfNat`インスタンスは、提供された数値が`Fin`が許容するよりも大きい場合にコンパイル時に失敗するのではなく、剰余算術を実行します。

## 仮定の証明

実際に証明作業を行うことなく、あるステートメントが証明されたふりをすることが有用な場合があります。
これは、ステートメントの証明が、別の証明での書き換えや、配列アクセスが安全であることの決定、あるいは再帰的な呼び出しが元の引数よりも小さい値で行われることの示唆など、何らかのタスクに適しているかどうかを確認する場合に有用です。
何かを証明するために時間を費やした後で、別の証明がもっと役に立ったことがわかると非常にイライラします。

`sorry`戦術は、実際の証明が存在するかのようにLeanが一時的にステートメントを受け入れるようにします。
これは、C#で`NotImplementedException`を投げるスタブメソッドに類似していると見なされるかもしれません。
`sorry`を使用した証明では、Leanで警告が含まれます。

注意してください！
`sorry`戦術は_任意の_ステートメントを証明することができますが、偽のステートメントも証明してしまう可能性があります。
`3 < 2`を証明することで、配列の範囲外アクセスが実行時にプログラムを予期せずクラッシュする原因となる場合があります。
開発中に`sorry`を使用することは便利ですが、コードに残すことは危険です。

## 終了を証明する

再帰関数が構造的再帰を使用していない場合、Leanは自動的にそれが終了することを決定することはできません。
このような状況では、関数は単に`partial`とマークされるかもしれません。
しかし、関数が終了することの証明を提供することも可能です。

パーシャル関数には重要な欠点があります。それらは型チェック時や証明において展開できません。
これは、Leanの対話型定理証明機能がそれらに適用されないことを意味します。
さらに、期待される終了が常に実際には終了することを示すことで、バグのもう一つの潜在的な原因を取り除くことができます。

関数の最後に許可される`termination_by`句は、再帰関数が終了する理由を指定するために使用することができます。
この句は、関数の引数を、各再帰呼び出しで小さくなることが期待される式にマッピングします。
減少する可能性のある式の例には、配列内で増加するインデックスと配列のサイズとの差、各再帰呼び出しで半分に切られるリストの長さ、あるいは各再帰呼び出しで正確に1つだけが縮小するペアのリストがあります。

Leanには、一部の式が各呼び出しで減少することを自動的に判断する証明自動化が含まれていますが、多くの興味深いプログラムでは手動の証明が必要です。
これらの証明は、値ではなく証明を局所的に提供するための`let`のバージョンである`have`で提供することができます。

再帰関数を書く良い方法は、それらを`partial`と宣言し、テストでデバッグして正しい答えを返すまでにすることです。
その後、`partial`を取り除き、`termination_by`句に置き換えることができます。
Leanは、証明が必要であることを示す必要がある各再帰呼び出しにエラーハイライトを配置します。
これらの各ステートメントは、証明が`sorry`である`have`に配置することができます。
Leanがプログラムを受け入れてそれがテストにも合格していれば、最終段階はLeanが受け入れるのを可能にする定理を実際に証明することです。
このアプローチは、バグのあるプログラムが終了することを証明する時間を無駄にすることを防ぐのに役立ちます。