# ファンクター、アプリカティブファンクター、モナド

`Functor` と `Monad` は、まだ型引数を待機している型に対する操作を説明します。
これらを理解する一つの方法は、`Functor` は含まれるデータが変換可能なコンテナとして、そして `Monad` は副作用を持つプログラムのコーディング方法として説明することです。
しかし、この理解は不完全です。
結局のところ、`Option` は `Functor` と `Monad` の両方のインスタンスを持ち、同時にオプショナルな値と値の返却に失敗するかもしれない計算を表しています。

データ構造として見た場合、`Option` はヌラブル型や最大で一つのエントリを含むリストのようなものです。
制御構造の観点からは、`Option` は結果なしで早期終了するかもしれない計算を代表します。
通常、`Functor` インスタンスを使用するプログラムは、`Option` をデータ構造として使用していると考えるのが最も簡単ですが、`Monad` インスタンスを使用するプログラムは、早期失敗を許容するために `Option` を使用していると考えるのが最も簡単ですが、両方の観点を流暢に使い分けることは、関数型プログラミングに習熟する上で重要な部分です。

ファンクターとモナドとの間には、より深い関係があります。
結論として、_すべてのモナドはファンクターです_。
これを別の言い方で表すなら、モナドの抽象化はファンクターの抽象化よりも強力であるということです。なぜなら、すべてのファンクターがモナドであるわけではないからです。
さらに、アプリカティブファンクターと呼ばれる追加の中間抽象化があり、多くの興味深いプログラムを記述するのに十分な力を持ちながら、`Monad` インターフェースを使用できないライブラリに許可を与えます。
型クラス `Applicative` は、アプリカティブファンクターのオーバーロード可能な操作を提供します。
すべてのモナドはアプリカティブファンクターであり、すべてのアプリカティブファンクターはファンクターですが、その逆は成り立ちません。