# ファンクター、アプリカティブファンクター、モナド

`Functor`や`Monad`は、型の引数がまだ適用されていない型に対する操作を記述します。
これらを理解する一つの方法は、`Functor`をデータを変換できるコンテナとして、`Monad`を副作用を伴うプログラムのコーディング手法として捉えることです。
しかしながら、この理解は完全ではありません。
結局のところ、`Option`は`Functor`と`Monad`の両方のインスタンスを持ち、また、任意の値や計算が失敗して値を返さない可能性を表しています。

データ構造としてみた場合、`Option`はnull許容型や多くて一つのエントリを持つリストに似ています。
制御構造の観点から見ると、`Option`は結果が出ないまま早期終了する可能性のある計算を表していると言えます。
通常、`Functor`インスタンスを使うプログラムでは、`Option`をデータ構造として見る方が簡単です。一方で、`Monad`インスタンスを使うプログラムでは、早期に失敗する可能性を許容するために`Option`を使っていると考えることが簡単ですが、関数型プログラミングを習得する上で、これら両方の視点を自在に切り替える能力は非常に重要です。

ファンクターやモナドの間には、もっと深い関係があります。
一つの結論として、_すべてのモナドはファンクターでもあります_。
これを別の言い方をすると、モナドの抽象化はファンクターの抽象化よりも強力だということになります。なぜなら、すべてのファンクターがモナドというわけではないからです。
さらに、「アプリカティブファンクター」と呼ばれるもう一つの中間抽象化があります。これは、多くの興味深いプログラムを書くのに十分な強さを持ちつつ、`Monad`インターフェイスが使えないライブラリに対しても使用が許されます。
型クラス`Applicative`は、アプリカティブファンクターのオーバーロード可能な操作を提供しています。
すべてのモナドはアプリカティブファンクターであり、すべてのアプリカティブファンクターはファンクターですが、逆は成り立ちません。