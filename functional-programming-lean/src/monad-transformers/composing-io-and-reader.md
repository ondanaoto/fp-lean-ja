# IOとReaderの組み合わせ

リーダーモナドが便利であるとされるのは、アプリケーションの「現在の設定」を多くの再帰呼び出しを通じて渡す必要がある場合です。そのようなプログラムの例として、現在のディレクトリ及びそのサブディレクトリ内のファイルを再帰的にリストアップし、ツリー構造を文字で表示する`tree`というコマンドがあります。この章で紹介する`tree`コマンドのバージョンは、北米西海岸に生息する偉大なダグラスファーにちなんで`doug`と名付けられ、ディレクトリ構造を表示する際にユニコード枠線記号かそれに相当するASCII文字を選択できるようにします。

例えば、以下のコマンドは`doug-demo`という名前のディレクトリにいくつかのサブディレクトリと空のファイルを作成します：

```
$ cd doug-demo
$ mkdir -p a/b/c
$ mkdir -p a/d
$ mkdir -p a/e/f
$ touch a/b/hello
$ touch a/d/another-file
$ touch a/e/still-another-file-again
```

`doug`を実行すると、以下のようになります：

```
$ doug
```

## 実装

内部的に、`doug`は設定値をディレクトリ構造の再帰的なトラバース中に下へ伝播させます。この設定には2つのフィールドが含まれています：`useASCII`はユニコード枠線記号を使うかASCIIの縦線やダッシュを使うかを決定し、`currentPrefix`は出力の各行の先頭につける文字列を保持しています。ディレクトリが深くなるにつれてプレフィックス文字列は、そのディレクトリ内に居ることを示すマーカーとともに拡大されます。この設定は以下のような構造です：

```lean
-- Config構造体の例
```

この構造体は両方のフィールドにデフォルト値を持っています。デフォルトの`Config`はプレフィックスなしでユニコードを使用します。

`doug`を使うユーザーはコマンドライン引数を提供する必要があります。コマンドラインの使用に関する情報は以下の通りです：

```lean
-- コマンドライン引数の使用方法の例
```

それに応じて、コマンドライン引数のリストを解析して設定を構築することができます：

```lean
-- 引数からConfigを構築する例
```

`main`関数は、`dirTree`という内部のワーカー関数をラップしており、設定を使ってディレクトリ内容を表示します。`dirTree`を呼ぶ前に、`main`はコマンドライン引数を処理し、オペレーティングシステムに適切な終了コードを返す責任があります：

```lean
-- main関数の例
```

ディレクトリツリーに表示すべきでない全てのパスがあります。特に、`.`や`..`という名前のファイルはスキップされるべきで、実際にはナビゲーションに使われるためでありファイルではありません。表示すべきファイルには2種類あります：通常のファイルとディレクトリです：

```lean
-- Entry構造体の例
```

ファイルを表示すべきかどうかと、どの種類のエントリかを判断するために、`doug`は`toEntry`関数を使用します：

```lean
-- toEntry関数の例
```

`System.FilePath.components`関数は、パスをコンポーネントのリストに分割し、ディレクトリセパレータで分割された名前にします。最後のコンポーネントがない場合は、そのパスはルートディレクトリです。最後のコンポーネントが`.`や`..`など特殊なナビゲーションファイルであれば、そのファイルは除外されるべきです。それ以外の場合は、ディレクトリとファイルはそれぞれの構造体でラップされます。

Lean言語では、ディレクトリツリーが有限であると理解することはできません。実際には、いくつかのシステムは循環的なディレクトリ構造の作成を許可しています。したがって、`dirTree`関数は`partial`と宣言されています：

```lean
-- dirTree関数の例
```

`toEntry`への呼び出しはネストされたアクションです—括弧はアローとしての他の意味を持たせることができない位置で省略できます、例えば`match`の場合。ファイル名がツリー内のエントリに該当しない場合（例えば`..`のために）、`dirTree`は何もしません。通常のファイルを示している場合には、`dirTree`は現在の設定を用いて表示するヘルパー関数を呼びます。ディレクトリを指している場合は、ヘルパーで表示し、その後その内容を新しい設定で再帰的に表示します。

ファイルとディレクトリの名前を表示するためには、`showFileName`と`showDirName`が使われます：

```lean
-- showFileNameとshowDirName関数の例
```

これらのヘルパー関数は、ASCIIかユニコードの選択を扱う`Config`上の関数を呼び出します：

```lean
-- ファイル名とディレクトリ名を表示する関数の例
```

同様に、`Config.inDirectory`はプレフィックスをディレクトリマーカーで拡大する機能を提供します：

```lean
-- inDirectory関数の例
```

ディレクトリ内のコンテンツリストに対してIOアクションを繰り返すには`doList`関数を使用します。`doList`関数はリスト内の全てのアクションを実行し、返される値に基づいて制御フローを判断しませんので、`Monad`の全機能は不要であり、任意の`Applicative`を実行できます：

```lean
-- doList関数の例
```

## カスタムモナドの使用

この`doug`の実装は機能しますが、設定を手動で渡すことは冗長でエラーを引き起こしやすいです。タイプシステムは、間違った設定が下方向に渡されても、それをキャッチしません。リーダー効果は、再帰呼び出しの間毎回同じ設定が渡されることを保証し、コードをシンプルにするのに役立ちます。

`IO`のバージョンを持つカスタム`Config`モナドを作成することもできますが、最初にそのタイプとその`Monad`インスタンスを定義する必要があります。[`示されている例の評価者`](../monads/arithmetic.md#custom-environments)を参照してください：

```lean
-- ConfigIOタイプとそのMonadインスタンスの例
```

この`Monad`インスタンスと`Reader`用のそれとの違いは、`bind`が`next`を直接`result`からの値に適用する代わりに、`IO`モナドの`do`構文を使用していることです。`result`による任意の`IO`効果は、`next`が呼ばれる前に発生しなければならず、`IO`モナドの`bind`演算子によってこれが保証されます。`ConfigIO`タイプは基底の`IO`タイプが多型でないため、多型でもありません。

`ConfigIO`アクションを実行するには、設定を提供することによってIOアクションに変換することが含まれます：

```lean
-- ConfigIOアクションを実行する例
```

この関数は本来必要ありません。なぜなら、呼出し側は単に設定を直接提供することもできるからです。しかし、この操作に名前をつけることで、どのコードの部分がどのモナドで実行されるべきなのかを、より理解しやすくします。

次のステップとして、現在の設定にアクセスする手段を`ConfigIO`の一部として定義します：

```lean
-- 現在のConfigにアクセスするための例
```

これは`read`と似ていますが、その値を直接返すのではなく、`IO`の`pure`を使用して返します。ディレクトリに進入することは、より小さなプログラムの領域に対して変更された設定を局所的に限定するために再帰呼び出しのスコープで現在の設定を変更することを意味するので、設定を上書きする手段が必要です：

```lean
-- 設定を上書きする例
```

`doug`で使用される多くのコードは設定を必要としません。`doug`は標準ライブラリから通常のLeanのIOアクションを呼び出しますが、それらは確かに`Config`を必要としません。普通のIOアクションは`runIO`を使って実行できます。これは設定引数を無視します：

```lean
-- runIO関数の例
```

これらのコンポーネントがあれば、`showFileName`と`showDirName`は`ConfigIO`モナドを介して暗黙的に設定引数を受け取り、[ネストされたアクション](../hello-world/conveniences.md#nested-actions)を使用して設定を取得し、`runIO`を使用して`IO.println`の呼び出しを実行します：

```lean
-- showFileNameとshowDirName関数の中間バージョンの例
```

新しいバージョンの`dirTree`では、`toEntry`と`System.FilePath.readDir`への呼び出しは`runIO`でラップされています。また、再帰呼び出しに渡す新しい設定をプログラマがどれを渡すかを追跡する代わりに、それは`locally`を使用して変更された設定をプログラムの小さなエリアに自然に限定し、それが有効な設定となります：

```lean
-- dirTreeの中間バージョンの例
```

新しいバージョンの`main`は`ConfigIO.run`を使用して初期設定と一緒に`dirTree`を呼び出します：

```lean
-- mainの中間バージョンの例
```

このカスタムモナドは設定を手動ですることに対して多くの利点を持ちます：

 1. 設定を変更することなく渡すことを保証する方が簡単になります（変更を望む場合除く）。
 2. 設定を次に渡すという心配がディレクトリ内容の印刷の心配からより明確に分離されます。
 3. プログラムが大きくなったとしても、設定のロジックを変更しても、これらの中間層を書き換える必要はありません。

しかし、いくつかの明らかな欠点もあります：

 1. プログラムが進化してモナドにより多くの機能が必要になるにつれて、`locally`や`currentConfig`などの基本演算子を更新する必要があります。
 2. 通常のIOアクションを`runIO`でラップすることは騒々しく、プログラムの流れを邪魔します。
 3. モナドインスタンスを手作業で作成することは繰り返しであり、それを異なるモナドに追加するためのリーダー効果は文書化とコミュニケーションのためのオーバーヘッドを必要とします。

_モナド変換器_と呼ばれるテクニックを使用することで、これらの欠点に対処ることができます。モナド変換器は一つのモナドを引数として取り、新しいモナドを返します。モナド変換器には以下のものが含まれます：

 1. 変換器自体（通常は型から型への関数です）。
 2. 内部型が既にモナドであることを前提とする`Monad`インスタンス。