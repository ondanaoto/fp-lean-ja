# 要約

## モナドの組み合わせ

スクラッチからモナドを書く際には、モナドに各々のエフェクトを追加する方法を記述する設計パターンが存在します。
リーダーエフェクトは、モナドのタイプがリーダーの環境からの関数によって追加されます。状態エフェクトは、初期状態から最終状態と組にされた値までの関数を含めることによって追加されます。失敗や例外は、戻り値の型に和型を加えることによって追加され、ログやその他の出力は、戻り値の型に積型を含めることによって追加されます。
既存のモナドも、それらの効果を新しいモナドに含めるために、戻り値の型の一部にすることができます。

これらの設計パターンは、_モナドトランスフォーマー_を定義することによって、再利用可能なソフトウェアコンポーネントのライブラリーに作り変えられます。モナドトランスフォーマーはある基本モナドにエフェクトを追加します。
モナドトランスフォーマーは、よりシンプルなモナドタイプを引数として取り、強化されたモナドタイプを返します。
最低限、モナドトランスフォーマーは以下のインスタンスを提供すべきです：
 1. 内部の型が既にモナドであると仮定する`Monad`インスタンス
 2. 内部モナドから変換されたモナドへのアクションを翻訳する`MonadLift`インスタンス
 
モナドトランスフォーマーは多型の構造物や帰納的データタイプとして実装されることがありますが、たいていは、根底にあるモナドタイプから強化されたモナドタイプへの関数として実装されます。

## エフェクトのための型クラス

特定のエフェクトを実装する一般的な設計パターンは、そのエフェクトを持つモナドを定義し、それを別のモナドに追加するためのモナドトランスフォーマーを定義し、そのエフェクトへの汎用インターフェースを提供する型クラスを定義することです。
これにより、プログラムは必要とするエフェクトだけを指定するように書かれ、呼び出し側が正しいエフェクトを持つ任意のモナドを提供することができます。

ときには、補助的な型情報（例えば、状態を提供するモナドにおける状態の型、または例外を提供するモナドにおける例外の型）は出力パラメータとして、ときにはそうではありません。
出力パラメータは、各種エフェクトを一度だけ使用する簡単なプログラムにとって最も有用ですが、同じプログラム内で同じエフェクトが複数回使用される場合には、型チェッカーが早すぎる段階で間違った型にコミットしてしまうリスクがあります。
したがって、一般的なパラメータバージョンの型クラスと、`-Of`で終わる名前の型クラスの両方が通常提供されます。

## モナドトランスフォーマーは交換可能ではない

モナドにトランスフォーマーの順序を変更すると、そのモナドを使用するプログラムの意味を変更する可能性があるということを注目することが重要です。
例えば、`StateT`と`ExceptT`の順序を変更することで、例外が投げられたときに状態変更が失われるプログラム、または変更が保持されるプログラムのどちらかが生じる可能性があります。
ほとんどの命令型言語では後者のみを提供しているが、モナドトランスフォーマーによる柔軟性の増加は、手を差し伸べてタスクに適した種類を選ぶための考えと注意を要求します。

## モナドトランスフォーマーのための`do`表記

Leanの`do`ブロックは、ブロックを特定の値で終了させる早期リターン、ローカルに変更可能な変数、`break`と`continue`を持つ`for`ループ、そして単一分岐の`if`文をサポートしています。
これはLeanを使って証明を書く際に邪魔になるかのように思えるかもしれませんが、実際にはこれはモナドトランスフォーマーの特定の一般的な使用方法にとってより便利な構文に過ぎません。
その裏では、`do`ブロックが書かれているモナドはこれらの追加エフェクトをサポートするために`ExceptT`と`StateT`の適切な使用によって変換されています。