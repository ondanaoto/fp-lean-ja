# 型クラスとポリモーフィズム

任意の関数のオーバーロードに対して動作する関数を書くことは有用である。
例えば、`ToString`のインスタンスを持つ任意の型に対して機能する`IO.println`がそれにあたる。
これは必要なインスタンスを角括弧で示すことによって表される：`IO.println`の型は`{{#example_out Examples/Classes.lean printlnType}}`である。
この型は、`IO.println`が自動的にLeanによって決定されるべき型`α`の引数を受け取り、`α`に対する`ToString`インスタンスが利用可能でなければならないことを示している。
それは`IO`アクションを返す。

## ポリモーフィック関数の型の確認

暗黙の引数を取る関数や型クラスを使用する関数の型をチェックするには、いくつか追加の構文が必要です。
単に書く
```lean
{{#example_in Examples/Classes.lean printlnMetas}}
```
これはメタ変数を含む型を生み出す：
```output info
{{#example_out Examples/Classes.lean printlnMetas}}
```
これは、Leanが暗黙の引数を発見することに最善を尽くしており、メタ変数の存在は、型情報の十分な発見がまだなされていないことを示している。
関数のシグネチャを理解するためには、関数名の前にアットサイン(`@`)を付けてこの機能を抑制することができる：
```lean
{{#example_in Examples/Classes.lean printlnNoMetas}}
```
```output info
{{#example_out Examples/Classes.lean printlnNoMetas}}
```
この出力では、インスタンス自体に`inst`という名前が与えられている。
さらに、`Type`の後には`u_1`があり、これはまだ導入されていないLeanの機能を使用している。
今のところ、`Type`へのこれらのパラメータを無視してください。

## インスタンス暗黙の引数を用いたポリモーフィック関数の定義

リスト内のすべてのエントリを合計する関数には二つのインスタンスが必要です：`Add`はエントリを追加することを可能にし、空のリストのためにあるべき値として`0`の`OfNat`インスタンスが提供されます：
```lean
{{#example_decl Examples/Classes.lean ListSum}}
```
この関数は`Nat`のリストについて使用することができます：
```lean
{{#example_decl Examples/Classes.lean fourNats}}

{{#example_in Examples/Classes.lean fourNatsSum}}
```
```output info
{{#example_out Examples/Classes.lean fourNatsSum}}
```
しかし、`Pos`数字のリストには使用できません：
```lean
{{#example_decl Examples/Classes.lean fourPos}}

{{#example_in Examples/Classes.lean fourPosSum}}
```
```output error
{{#example_out Examples/Classes.lean fourPosSum}}
```

角括弧内の必要なインスタンスの仕様は_インスタンス暗黙の引数_と呼ばれます。
裏側では、すべての型クラスが各オーバーロードされた操作のためのフィールドを持つ構造を定義しています。
インスタンスはその構造型の値であり、各フィールドには実装が含まれています。
呼び出し場所で、Leanは各インスタンス暗黙の引数に対して渡すインスタンス値を見つける責任を持ちます。
通常の暗黙の引数とインスタンス暗黙の引数との最も重要な違いは、Leanが引数値を見つけるために使用する戦略です。
通常の暗黙の引数の場合、Leanはプログラムが型チェッカーを通過するために単一のユニークな引数値を見つけるために_単一化_と呼ばれる技術を使用します。
このプロセスは、関数の定義と呼び出し場所に関与する特定の型のみに依存しています。
インスタンス暗黙の引数の場合、Leanは代わりにインスタンス値の組み込みテーブルを参照します。

`Pos`の`OfNat`インスタンスが自然数`n`を自動的な暗黙の引数として取ったように、インスタンスは自身もまたインスタンス暗黙の引数を取ることがあります。
[多相性に関するセクション](../getting-to-know/polymorphism.md)では、多相的な点の型が提示されました：
```lean
{{#example_decl Examples/Classes.lean PPoint}}
```
点の加算は下層の`x`と`y`フィールドを加算するべきである。
したがって、`PPoint`の`Add`インスタンスにはこれらのフィールドが持つ型の`Add`インスタンスが必要です。
言い換えれば、`PPoint`のための`Add`インスタンスは`α`に対する更なる`Add`インスタンスを必要とします：
```lean
{{#example_decl Examples/Classes.lean AddPPoint}}
```
Leanが2点の加算に遭遇すると、このインスタンスを探し出し見つけます。
その後、`Add α`インスタンスについてさらに探索を行います。

このように構築されたインスタンス値は型クラスの構造型の値です。
成功した再帰的なインスタンス探索は、他の構造値への参照を持つ構造値を結果とします。
`Add (PPoint Nat)`のインスタンスは、見つかった`Add Nat`のインスタンスへの参照を含んでいます。

この再帰的探索プロセスは、型クラスが単なるオーバーロードされた関数よりもはるかに多くの力を提供することを意味しています。
多相的なインスタンスのライブラリは、コンパイラが望ましい型だけを与えられて独自に組み立てるコードのビルディングブロックのセットです。
インスタンス引数を取る多相関数は、シーンの背後でヘルパー関数を組み立てるために型クラス機構に対する潜在的な要求です。
APIのクライアントは、必要なすべての部品を手作業で組み立てる負担から解放されます。

## メソッドと暗黙の引数

`{{#example_in Examples/Classes.lean ofNatType}}`の型は驚くかもしれない。
それは`{{#example_out Examples/Classes.lean ofNatType}}`であり、この場合、`Nat`引数`n`は明示的な関数引数として現れる。
しかし、メソッドの宣言では、`ofNat`は単に型`α`を持っている。
このような相違は、型クラスを宣言することが実際に以下のことをもたらすためです：

 * 各オーバーロードされた操作の実装を含む構造型
 * クラスと同じ名前の名前空間
 * インスタンスからその実装を取得するための、クラスの名前空間内の各メソッドに対する関数

これは、新しい構造を宣言することでアクセサ関数も宣言される方法に類似しています。
主な違いは、構造のアクセサは構造値を明示的な引数として取るのに対し、型クラスメソッドはLeanによって自動的に発見されるべきインスタンス値をインスタンス暗黙として取る点です。

Leanがインスタンスを見つけるためには、その引数が利用可能である必要があります。
これは、型クラスの各引数がメソッドに対して引数であり、インスタンスの前に発生しなければならないことを意味します。
これらの引数が暗黙であると、Leanがその値を発見する作業を行うため便利です。
例として、`{{#example_in Examples/Classes.lean addType}}`は型`{{#example_out Examples/Classes.lean addType}}`を持ちます。
この場合、型引数`α`は、`Add.add`への引数がユーザーが意図した型についての情報を提供するため、暗黙である可能性があります。
この型はその後、`Add`インスタンスを検索するために使用することができます。

しかし、`ofNat`の場合、特定の`Nat`リテラルが他の引数の一部として現れることはありません。
これは、Leanにとって暗黙の引数`n`を解明する際に使用する情報がないことを意味します。
結果は非常に不便なAPIになるでしょう。
したがって、これらのケースでは、クラスのメソッドに対して明示的な引数をLeanは使用します。

## 練習問題

### 偶数リテラル

[前のセクションの練習問題](pos.md#even-numbers)で偶数データ型のための`OfNat`のインスタンスを書き、再帰的なインスタンス探索を使ってください。
基本インスタンスには、`OfNat Even 0`の代わりに`OfNat Even Nat.zero`と書く必要があります。

### 再帰的なインスタンス探索の深さ

Leanコンパイラが再帰的なインスタンス探索を試みる回数には制限があります。
これは前の練習で定義された偶数リテラルの大きさに制限をもたらします。
その限界が何であるかを実験的に決定してください。