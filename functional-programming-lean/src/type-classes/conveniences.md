# 追加の便利機能

## インスタンスのコンストラクタ構文

背後では、型クラスは構造型であり、インスタンスはこれらの型の値です。
唯一の違いは、Leanが型クラスについての追加情報、たとえばどのパラメータが出力パラメータであるかなどを格納し、インスタンスが検索用に登録されているということです。
構造型を持つ値は通常 `⟨...⟩` 構文または中括弧とフィールドを用いて定義されますが、インスタンスは通常 `where` を使用して定義されます。しかし、両方の構文は両方の定義で機能します。

たとえば、森林アプリケーションでは以下のように木を表現するかもしれません：
```lean
{{#example_decl Examples/Classes.lean trees}}
```
これら三つの構文は等価です。

同様に、型クラスのインスタンスをすべての三つの構文を使用して定義することができます：
```lean
{{#example_decl Examples/Classes.lean Display}}
```

一般的に、`where` 構文はインスタンスに使用すべきであり、中括弧の構文は構造に使用すべきです。
`⟨...⟩` 構文は、構造型が名前付きのフィールドを持つタプルと非常に似ている場合に有効であり、その瞬間に名前が重要ではないときに強調するのに便利です。
しかし、他の代替手段を使用することが理にかなっている状況もあります。
特に、ライブラリがインスタンス値を構築する機能を提供する場合があります。
インスタンス宣言の `:=` の後にこの機能への呼び出しを配置することは、このような機能を使用する最も簡単な方法です。

## 例

Leanのコードを実験する際には、`#eval` や `#check` コマンドよりも定義を使用する方が便利です。
まず、定義は出力を生成しないため、読者の注目を最も興味深い出力に集中させるのに役立ちます。
次に、ほとんどのLeanプログラムは型シグネチャから始める方が、プログラムそのものを書きながらLeanがより多くの支援を提供し、より良いエラーメッセージを与えることができます。
一方で、Leanが提供された式から型を決定できる場合には、`#eval` と `#check` を使用する方が簡単です。
さらに、`#eval` は `ToString` や `Repr` のインスタンスを持たない型の式、例えば関数と一緒には使用できません。
最後に、複数ステップの `do` ブロックや、`let`-式、およびその他の複数行にまたがる構文形式は、`#eval` や `#check` で型注釈を付けるのが特に難しくなります。なぜなら、必要な括弧が予測しにくいからです。

これらの問題を解決するため、Leanはソースファイルでの例の明示的な表示をサポートしています。
例は名前を持たない定義のようなものです。
例えば、コペンハーゲンの緑地に一般的に見られる鳥の空でないリストは以下のように書かれるかもしれません：
```lean
{{#example_decl Examples/Classes.lean birdExample}}
```

例は引数を受け入れることで関数を定義することが可能です：
```lean
{{#example_decl Examples/Classes.lean commAdd}}
```
これにより、裏側で関数が作成されますが、この関数には名前がなく、呼び出すことはできません。
それでも、これは、いくつかの与えられた型の任意の値または不明な値を使用してライブラリがどのように使用され得るかを示すのに有用です。
ソースファイルでは、`example` 宣言はライブラリのコンセプトを説明するコメントと一緒に使用するのが最も適しています。