# 概要

## タイプクラスとオーバーロード

タイプクラスは、Leanにおける関数や演算子のオーバーロードのための機構です。
多相的な関数は複数の型に使用することができますが、どの型を使用しても同じ方法で振る舞います。
たとえば、2つのリストを結合する多相的な関数は、リストのエントリの型にかかわらず使用できますが、特定の型に基づいて異なる振る舞いをすることはできません。
一方でタイプクラスでオーバーロードされた演算は、複数の型に対して使用することができます。
しかし、各型はオーバーロードされた演算のための独自の実装が必要です。
これにより、提供された型に基づいて振る舞いが異なることを意味します。

_タイプクラス_ は名前、パラメータ、およびオーバーロード可能な演算の名前と型が含まれる数個の項目からなる本体を持ちます。
名前はオーバーロードされた演算に参照するための方法であり、パラメータは定義のどの側面をオーバーロードすることができるかを決定し、本体はオーバーロード可能な演算の名前と型シグネチャを提供します。
タイプクラスの各オーバーロード可能な演算は、そのタイプクラスの_メソッド_ と呼ばれます。
タイプクラスは、他のメソッドに関していくつかのメソッドのデフォルト実装を提供することがあり、これは実装者が必要でない場合に手動で各オーバーロードを定義する手間を省くことができます。

タイプクラスの _インスタンス_ は、特定のパラメータに対するメソッドの実装を提供します。
インスタンスは多相的であり、場合によってはさまざまなパラメータで機能し、特定の型に対してより効率的なバージョンが存在する場合には、デフォルトメソッドのより具体的な実装を任意で提供することもできます。

タイプクラスのパラメータは、_入力パラメータ_（デフォルト）、または `outParam` によって示される _出力パラメータ_ のいずれかです。
Leanは入力パラメータがもはやメタ変数でなくなるまでインスタンスの検索を開始しませんが、出力パラメータはインスタンスを検索しながら解決されることがあります。
タイプクラスのパラメータは、型である必要はありません。通常の値でもよいのです。
自然数リテラルをオーバーロードするために使用される `OfNat` タイプクラスは、オーバーロードされる `Nat` 自体をパラメータとして取り、インスタンスが許可される数字を制限することができます。

インスタンスは `@[default_instance]` 属性でマークすることができます。
インスタンスがデフォルトインスタンスである場合、型のメタ変数の存在により、Leanがインスタンスが見つからないと失敗するであろうときに、それがフォールバックとして選ばれます。

## 一般的な構文のためのタイプクラス

Leanの多くの中置演算子はタイプクラスでオーバーライドされています。
たとえば、加算演算子は `Add` というタイプクラスに対応しています。
これらの演算子の多くは、異種バージョンを持っており、その場合、2つの引数が同じ型である必要はありません。
これらの異種演算子は、クラスの名前が `H` で始まるバージョンを使用してオーバーロードされます。たとえば `HAdd` のように。

インデックス構文は、証明を伴う `GetElem` というタイプクラスを使用してオーバーロードされます。
`GetElem` は2つの出力パラメータを持ち、それらはコレクションから抽出される要素の型とコレクションのインデックス値が範囲内であると考えられることを決定するために使用できる関数です。
この証拠は命題によって記述され、配列インデックスが使用される際に、Leanはこの命題を証明しようと試みます。
Leanがコンパイル時にリストや配列アクセス操作が範囲内であることを確認できない場合、インデックス操作に `?` を追加することで、実行時にチェックを延期することができます。

## ファンクター

ファンクターは、マッピング操作をサポートする多相型です。
このマッピング操作は、「場所に応じて」すべての要素を変換し、他の構造は変更しません。
たとえば、リストはファンクターであり、マッピング操作はリスト内のエントリを落としたり、複製したり、混ぜたりすることはありません。

ファンクターは `map` を持っていることで定義されていますが、Leanの `Functor` タイプクラスには、多相型変数によって与えられるすべての値を同じ新しい値で置き換えるために、定数関数を値にマッピングする責任を持つ追加のデフォルトメソッドが含まれています。
いくつかのファンクターにとって、これは全体の構造を渡るよりも効率的に行うことができます。

## インスタンスの派生

多くのタイプクラスには非常に標準的な実装があります。
たとえば、ブール等価クラス `BEq` は通常、両方の引数が同じコンストラクターで構築されているかどうかを先に確認し、その後すべての引数が等しいかどうかを確認することによって実装されます。
これらのクラスのインスタンスは_自動的に_ 作成することができます。

帰納的型や構造を定義するとき、宣言の最後に `deriving` 節を追加すると、インスタンスが自動的に作成されます。
さらに、データ型の定義の外に `deriving instance ... for ...` コマンドを使用することで、インスタンスが生成されるように指示することができます。
派生可能なインスタンスを持つ各クラスには特別な取り扱いが必要であるため、すべてのクラスが派生可能なわけではありません。

## 強制変換

強制変換は、通常コンパイル時のエラーになるであろうものから、一方の型から別の型にデータを変換する関数の呼び出しを挿入することで、Leanが回復することを可能にします。
たとえば、任意の型 `α` から型 `Option α` への強制変換により、値を `some` コンストラクタを使わずに直接書くことが可能になり、`Option` をオブジェクト指向言語の nullable 型のように機能させることができます。

強制変換には複数の種類があります。
それらは異なる種類のエラーから回復することができ、それらはそれぞれ独自のタイプクラスによって表されます。
`Coe` クラスは型エラーから回復するために使用されます。
Leanが型 `α` の式を型 `β` が期待されるコンテキストで持っている場合、Leanは最初に `α` を `β` に変換する強制変換のチェーンを繋ぎ合わせることを試み、これが不可能であるときのみエラーを表示します。
`CoeDep` クラスは、強制される特定の値を追加のパラメータとして取り、さらにその値に対してタイプクラス検索を行うことを可能にするか、インスタンスでコンストラクターを使用して変換の範囲を制限することを可能にします。
`CoeFun` クラスは、関数適用をコンパイルする際の「関数ではない」エラーを補足し、関数位置にある値が可能であれば実際の関数に変換されることを可能にします。