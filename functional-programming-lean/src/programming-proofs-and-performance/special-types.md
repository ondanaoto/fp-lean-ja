# 特殊な型

メモリ内でデータがどのように表現されるかを理解することは非常に重要です。
通常、データ型の定義からその表現を理解することができます。
各コンストラクタは、タグと参照カウントを含んだヘッダーを持つメモリ内のオブジェクトに対応します。
コンストラクタの引数は、他のオブジェクトへのポインターによってそれぞれ表現されます。
つまり、`List`は実際に連結リストであり、`structure`からフィールドを取り出すことは、実際にポインターをたどることを意味します。

しかしながら、このルールにはいくつかの重要な例外があります。
コンパイラによって特別に扱われる型がいくつか存在します。
例えば、型`UInt32`は`Fin (2 ^ 32)`として定義されますが、実行時にはマシンワードに基づく実際のネイティブ実装に置き換えられます。
同様に、`Nat`の定義は`List Unit`に似た実装を示唆しているものの、実際の実行時表現では、十分に小さい数値については即時のマシンワードを使用し、より大きな数値については効率的な任意精度の算術ライブラリを使用します。
Leanのコンパイラは、パターンマッチングを使用した定義からこの表現に対応する演算へと変換し、加算や減算などの演算への呼び出しは、下層の算術ライブラリの高速な演算にマップされます。
結局のところ、加算には加数のサイズに比例して時間がかかるべきではありません。

いくつかの型に特別な表現があるという事実は、それらを扱う際に注意が必要であることを意味します。
これらの型のほとんどは、コンパイラによって特別に扱われる`structure`で構成されています。
これらの構造体では、コンストラクタやフィールドアクセサを直接使用することで、効率的な表現から証明に便利ながら遅いものへの高価な変換がトリガーされる可能性があります。
例えば、`String`は文字のリストを含む構造体として定義されますが、実行時の文字列の表現はUTF-8を使用し、文字へのポインターの連結リストは使用しません。
文字のリストにコンストラクタを適用すると、UTF-8でエンコードされたバイト配列が生成され、構造のフィールドにアクセスすると、文字列の長さに比例する時間がかかり、UTF-8表現をデコードし、連結リストを割り当てます。
配列も同様に表現されます。
論理的な観点からは、配列は配列要素のリストを含む構造ですが、実行時表現は動的サイズの配列です。
実行時には、コンストラクタはリストを配列に変換し、フィールドアクセサは配列から連結リストを割り当てます。
さまざまな配列操作はコンパイラによって効率的なバージョンに置き換えられ、可能な場合は新しいものを割り当てる代わりに配列を変更します。

型自身と命題の証明は、コンパイルされたコードから完全に消去されます。
言い換えれば、彼らはスペースを取らず、証明の一部として行われたかもしれない計算も同様に消去されます。
これは、証明がインダクティブに定義されたリストとしての文字列や配列への便利なインターフェイスを利用することができ、それらについてのことを証明するために帰納法を使用できることを意味し、プログラム実行中に遅い変換ステップを課すことはありません。
これらの組み込み型の場合、データの便利な論理的表現はプログラムが遅くなることを示唆しません。

構造体型が単一の非型非証明フィールドのみを有する場合は、コンストラクタ自体は実行時に消え、その単一の引数に置き換えられます。
言い換えれば、サブタイプは間接参照の余分な層を持つのではなく、その基礎となる型に同一のものとして表現されます。
同様に、`Fin`はメモリ内でただの`Nat`であり、`Nat`または`String`の異なる使用を追跡するために単一フィールド構造を作成することができますが、パフォーマンスペナルティは発生しません。
コンストラクタに非型非証明引数がない場合は、コンストラクタも消えて定数値に置き換えられ、その他の場合はポインタが使用される場所に定数値が置かれます。
これは、`true`、`false`、および`none`がヒープ割り当てオブジェクトへのポインターではなく、定数値であることを意味します。

次の型には特別な表現があります：

| 型                                    | 論理的表現                                                                              | 実行時表現                               |
|---------------------------------------|---------------------------------------------------------------------------------------|-------------------------------------------|
| `Nat`                                 | 各`Nat.succ`から1つのポインター                                                         | 効率的な任意精度整数                      |
| `Int`                                 | 正または負の値に対するコンストラクタを持つ和型                                           | 効率的な任意精度整数                      |
| `UInt8`, `UInt16`, `UInt32`, `UInt64` | 適切な上限を持つ`Fin`                                                                   | 固定精度のマシン整数                      |
| `Char`                                | 有効なコードポイントであることの証明と組み合わさった`UInt32`                           | 通常の文字                               |
| `String`                              | `data`というフィールドに`List Char`を含む構造体                                         | UTF-8エンコードされた文字列              |
| `Array α`                             | `data`というフィールドに`List α`を含む構造体                                            | `α`値へのポインターの詰まった配列        |
| `Sort u`                              | 型                                                                                      | 完全に消去                               |
| 命題の証明                            | 証拠としての型の提案されたデータ                                                        | 完全に消去                               |

## 練習問題

[`Pos`の定義](../type-classes/pos.html)は、Leanが`Nat`を効率的な型にコンパイルするという利点を活用していません。
実行時には、基本的に連結リストです。
代わりに、Leanの高速な`Nat`型を内部で使用できるサブタイプを定義することができます。これは[サブタイプに関する最初のセクション](../functor-applicative-monad/applicative.md#subtypes)で説明されています。
実行時には、証明は消去されます。
結果として得られる構造には単一のデータフィールドのみがあり、この新しい表現の`Pos`は`Nat`と同一です。

定理 `∀ {n k : Nat}, n ≠ 0 → k ≠ 0 → n + k ≠ 0` を証明した後、この新しい`Pos`の表現の`ToString`および`Add`のインスタンスを定義します。そして、必要な定理を証明しながら、`Mul`のインスタンスを定義します。