# 要約

## 末尾再帰

末尾再帰とは、再帰コールの結果が直ちに返される再帰プログラムのことです。これらの再帰コールは _末尾コール_ と呼ばれます。
末尾コールは面白い性質を持っており、コール命令ではなくジャンプ命令にコンパイルされ、新しいフレームをスタックにプッシュする代わりに、現行のスタックフレームを再利用できます。
言い換えれば、末尾再帰関数は実質的にループです。

再帰関数を速くする一般的な方法は、それを累積引数形式で書き直すことです。
再帰コールの結果を処理するためにコールスタックを使う代わりに、_累積変数_ と呼ばれる追加の引数を使ってこの情報を集めます。
例えば、リストを逆にする末尾再帰関数の累積変数は、逆順になった既に見たリストエントリを含んでいます。

Leanでは、自己末尾コールのみがループに最適化されます。
言い換えれば、お互いに末尾コールで終わる二つの関数が最適化されることはありません。

## 参照カウントとその場アップデート

Java、C#、そして多くのJavaScript実装で行われているようなトレース型ガベージコレクタを使用する代わりに、Leanではメモリ管理のために参照カウントを使います。
これはメモリ内の各値が、いくつの他の値に参照されているかを追跡するフィールドを持ち、ランタイムシステムが参照が現れたり消えたりするときにこれらのカウントを維持するということを意味します。
参照カウントはPython、PHP、Swiftでも使用されています。

新しいオブジェクトを割り当てるように求められたとき、Leanのランタイムシステムは参照カウントがゼロに減少している既存のオブジェクトを再利用することができます。
また、`Array.set` や `Array.swap` のような配列操作は、参照カウントが1の場合に配列を変更することができ、変更されたコピーを割り当てるのではなく配列を突然変異させます。
`Array.swap`が配列に対する唯一の参照を持っている場合、プログラムの他の部分では配列がコピーされたのか変更されたのかを判断することができません。

効率的なコードをLeanで書くには、末尾再帰を使用し、大きな配列がユニークに使われていることを確認する注意が必要です。
末尾コールは関数の定義を検査することによって特定できますが、値がユニークに参照されているかどうかを理解するためには、プログラム全体を読む必要があります。
デバッグヘルパー `dbgTraceIfShared` はプログラムの重要な位置で値が共有されていないことをチェックするために使うことができます。

## プログラムの正しさを証明する

累積引数スタイルでプログラムを書き直したり、実行を速める他の変換を行ったりすることは、プログラムを理解しづらくすることがあります。
明らかに正しいとされる元のプログラムのバージョンを保持し、最適化されたバージョンの実行仕様として使用することが有益である場合があります。
単体テストなどの技術はLeanでも他言語と同じように機能しますが、Leanはすべての可能な入力に対して両方のバージョンの関数が同じ結果を返すことを完全に保証する数学的な証明を使うことができます。

通常、二つの関数が等しいことを証明するには関数の外延性（`funext` タクティック）を使用します。これは、任意の入力に対して同じ値を返す二つの関数は等しいという原理です。
関数が再帰的である場合、その出力が同じである事を証明するために通常、帰納法が有効な方法です。
通常、関数の再帰的定義は特定の引数で再帰コールを行います；この引数は帰納法で使うのに良い選択です。
場合によっては、帰納法の仮説が十分強くありません。
この問題を解決するには、より一般的な定理のステートメントをどのように構築するかについての考えが通常必要です。その定理のステートメントは十分に強い帰納法の仮説を提供する必要があります。
特に、関数が累積引数バージョンに等しいことを証明するには、任意の初期累積値が元の関数の最終結果にどのように関連しているかを示す定理のステートメントが必要です。

## 安全な配列インデックス

型 `Fin n` は `n` より厳格に小さい自然数を表します。
`Fin` は "finite"（有限）の略です。
サブタイプと同様に、`Fin n` は `Nat` を含み、この `Nat` が `n` より小さいという証明を持つ構造体です。
`Fin 0` のタイプには値がありません。

`arr` が `Array α` の場合、`Fin arr.size` は常に `arr` に適したインデックスの数字を含んでいます。
`Array.swap` などの組み込みの配列オペレーターは分離された証明オブジェクトではなく、`Fin` の値を引数として取ります。

Leanは `Fin` のためにほとんどの有用な数値型クラスのインスタンスを提供します。
`Fin` の `OfNat` インスタンスは `Fin` が受け入れることができる数よりも大きい数字が提供された場合にコンパイル時に失敗するのではなく、モジュラー算術を実行します。

## 暫定的な証明

証明を実際に行うことなく、ある声明が証明されたと仮定することは便利な場合があります。
これは、別の証明での書き換えに適していることや、配列アクセスが安全であることを決定すること、または再帰コールが元の引数よりも小さい値で行われることを示すことなどのタスクに対して、証明が適しているかどうかを確かめる際に有用です。
実際には他の証明がより役立つことが判明した場合に証明に時間を費やすことは非常にイライラすることです。

`sorry` タクティックはLeanが本物の証明であるかのように声明を暫定的に受け入れるようにさせます。
これはC#で `NotImplementedException` を投げるスタブメソッドに似ているとみなすことができます。
`sorry` を使って依存する証明にはLeanで警告が含まれます。

注意してください！
`sorry` タクティックは _任何の_ 声明を証明できます、偽の声明でさえも。
`3 < 2` を証明すると、配列アクセスがランタイムまで残り、プログラムが予期せずクラッシュする原因となる可能性があります。
`sorry` を使うことは開発中に便利ですが、コードに残しておくことは危険です。

## 終了証明

再帰関数が構造再帰を使用していない場合、Leanは自動的にそれが終了するかどうかを決定することができません。
これらの状況では、関数はただ `partial` とマークされるかもしれません。
しかし、関数が終了することの証明を提供することも可能です。

部分関数は重要な欠点を持っています：彼らは型検査や証明の間に展開されることはありません。
これは、Leanの対話型定理証明者としての価値を彼らに適用することができないことを意味します。
さらに、終了すると期待される関数が常に終了することを示すことによって、バグの潜在的な源泉をひとつ減らすことができます。

関数の終わりに許される `termination_by` 節を使って、再帰関数がなぜ終了するかの理由を指定することができます。
この節は関数の引数を各再帰コールに対してより小さいと期待される式にマッピングします。
減少するかもしれない式の例には、配列への成長するインデックスと配列のサイズとの差、各再帰コールで半分に切られたリストの長さ、または再帰コールの度に正確に一方が縮小するペアのリストがあります。

Leanはいくつかの式が各呼び出しで減少することを自動的に決定できる証明の自動化を含んでいますが、多くの興味深いプログラムは手作業による証明を必要とします。
これらの証明は値ではなく証明を地元で提供するための `let` のバージョンである `have` で提供することができます。

再帰関数を書く良い方法は、それらを `partial` と宣言し、テストでデバッグすることで彼らが正しい答えを返すまでにします。
それから、`partial` を除去し `termination_by` 節で置き換えることができます。
Leanは各再帰コールに対して、証明が必要な警告を表示します、その中には証明が必要なステートメントが含まれます。
これらのステートメントは `have` に配置され、証明は `sorry` です。
Leanがプログラムを受け入れ、それがまだそのテストをパスする場合、最後のステップはLeanがそれを受け入れることを可能にする定理を実際に証明することです。
このアプローチは、バグのあるプログラムが終了することを証明する時間を無駄にすることを防ぐことができます。