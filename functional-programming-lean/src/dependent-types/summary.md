```markdown
# 概要

## 依存型

型が関数呼び出しや通常のデータコンストラクタのような非型コードを含む依存型は、型システムの表現力を大幅に増加させます。
引数の_value_から型を_compute_する能力は、関数の戻り値の型が提供された引数に基づいて変化することを意味します。
これは例えば、データベースのスキーマや特定のクエリに依存したデータベースクエリの結果型を、クエリの結果に対する潜在的に失敗するキャスト操作を必要とせずに持たせるために使用することができます。
クエリが変わると、それを実行した結果として得られる型も変わり、即時のコンパイル時のフィードバックを可能にします。

関数の戻り値の型が値に依存する場合、パターンマッチングによる値の分析は型が_refined_される結果をもたらし、値を表すための変数がパターン内のコンストラクタに置き換えられます。
関数の型シグネチャは、戻り値の型が引数値にどのように依存しているかを文書化し、パターンマッチングは潜在的な引数ごとに戻り値の型がどのように達成されるかを説明します。

型の中に現れる通常のコードは型チェック中に実行されますが、無限ループする可能性がある`partial`関数は呼び出されません。
ほとんどの場合、この計算は[この本の最初に紹介された](../getting-to-know/evaluating.md)通常の評価のルールに従い、式がその値によって逐次置き換えられるまで続き、最終的な値が見つかります。
型チェック中の計算は、実行時の計算と重要な違いがあります：型内のいくつかの値は、まだ未知の_variables_の可能性があります。
これらの場合、パターンマッチングは「スタック」状態になり、特定のコンストラクタが選択されるまで、例えばパターンマッチングによって、進行しません。
型レベルの計算は、プログラムの十分に知られている部分だけを評価し、他の部分を放置する部分評価の一種と見なすことができます。

## ユニバースパターン

依存型を扱う際の一般的なパターンは、型システムの特定のサブセットを区切ることです。
例えば、データベースクエリライブラリは可変長文字列、固定長文字列、あるいは特定の範囲の数値を返すことができますが、関数、ユーザ定義のデータ型、または`IO`アクションを返すことはありません。
型システムのドメイン固有のサブセットは、まず希望する型の構造に一致するコンストラクタを持つデータ型を定義することによって、そしてその後、このデータ型の値をオーソドックスな型に解釈する関数を定義することによって定義されます。
コンストラクタは問題の型の_codes_として参照され、この全体のパターンはしばしば_Tarski風のユニバース_あるいはコンテキストが明確な場合は単に_ユニバース_と呼ばれることがあります。

カスタムユニバースは、興味のある各型に対してインスタンスを定義する型クラスを定義する代替手段です。
型クラスは拡張可能ですが、拡張性が常に望まれるわけではありません。
カスタムユニバースを定義することは、直接型を使用することに対していくつかの利点があります：
 * ユニバース内の_any_型に対して機能する汎用操作（例えば等価性テストやシリアライゼーション）は、コード上での再帰によって実装することができます。
 * 外部システムに受け入れられる型を正確に表現することができ、コードデータ型の定義は何が期待されるかを文書化するために役立ちます。
 * Leanのパターンマッチング完全性チェッカーは、忘れられたコードがないことを保証する一方で、型クラスに基づくソリューションは、欠けているインスタンスのエラーをクライアントコードに委ねます。

## 索引付きファミリー

データ型は、二つの別々の種類の引数を取ることができます：_パラメータ_はデータ型の各コンストラクタ内で同一ですが、_インデックス_はコンストラクタ間で変化することがあります。
特定のインデックスの選択に対して、データ型の一部のコンストラクタのみが利用可能になります。
例として、`Vect.nil`は長さのインデックスが`0`の場合にのみ利用でき、`Vect.cons`は長さのインデックスがある`n+1`に対してのみ利用できます。
パラメータは通常、データ型宣言のコロンの前に名前付きの引数として書かれ、インデックスは関数型のコロン後の引数として表現されますが、Leanはコロン後の引数がパラメータとして使用される場合を推論することができます。

索引付きファミリは、コンパイラによってチェックされるデータ間の複雑な関係を表現することを可能にします。
データ型の不変条件は直接エンコードされ、暫定的な方法でさえそれらを破る方法はありません。
コンパイラにデータ型の不変条件について情報を提供することは、大きな利点をもたらします：コンパイラは今やプログラマーにそれを満たすために何をしなければならないかを伝えることができるのです。
アンダースコアによるコンパイル時エラーの戦略的な使用は、Leanにプログラミング思考プロセスの一部を委ねることができ、プログラマーの心を他のことに向けるために開放することが可能です。

しかし、索引付きファミリを使って不変条件をエンコードすることは困難を引き起こす可能性があります。
まず第一に、それぞれの不変条件を持つデータ型が必要で、それには独自のサポートライブラリも必要です。
`List.append`と`Vect.append`は交換可能ではありません。
これはコードの重複を引き起こす可能性があります。
第二に、索引付きファミリを便利に使うためには、型中で使用される関数の再帰構造が型チェックされているプログラムの再帰構造と一致する必要があります。
索引付きファミリでのプログラミングは、正しい偶然が起こるように手配する芸術です。
偶然が欠けている場合には、等価性証明に依存して回避することは可能ですが、難しく、さらにそれは暗号のような正当性を持つプログラムでいっぱいになることをもたらします。
第三に、型チェック中に大きな値で複雑なコードを実行することは、コンパイル時に遅延を引き起こす可能性があります。
複雑なプログラムでこれらの遅延を避けるには、特殊な技術が要求されることがあります。

## 定義上の等価性と命題上の等価性

Leanの型チェッカーは、時々、二つの型を交換可能とみなすべきかをチェックする必要があります。
型は任意のプログラムを含むことができるため、それは任意のプログラムの等価性をチェックする能力を持たなければなりません。
しかしながら、任意のプログラムを完全に一般的な数学的等価性でチェックするための効率的なアルゴリズムは存在しません。
この問題を解決するため、Leanには二つの等価性の概念が含まれています：

 * _定義上の等価性_は、基本的には計算と束縛変数のリネーミングを無視した構文表現の等価性をチェックする等価性の下限近似です。Leanは、それが必要な状況において自動的に定義上の等価性をチェックします。

 * _命題上の等価性_は、プログラマーによって明示的に証明され、明示的に呼び出される必要があります。それに見返りとして、Leanは証明が有効であり、呼び出しが正しい目標を達成していることを自動的にチェックします。

これら二つの等価性の概念はプログラマーとLean自体との間の労働の分離を表しています。
定義上の等価性は単純ですが自動的であり、一方命題上の等価性は手動ですが表現力があります。
命題上の等価性は、型レベルの計算でそうでなければスタックしてしまうプログラムを解除するために使用することができます。

しかし、型レベルの計算を解除するために命題上の等価性を頻繁に使用することは、通常はコードの臭いを発散します。
それは通常、偶然性がよくエンジニアリングされていないことを意味し、タイプとインデックスを再設計するか、必要な不変条件を強制するために異なる技術を使用する方が通常は良いアイデアです。
代わりに、プログラムが仕様を満たしていることを証明するためや、サブタイプの一部として命題上の等価性を使用するときには、疑わしくないことになります。
```