# 型

型はプログラムを、計算することのできる値に基づいて分類します。型はプログラムの中で多くの役割を果たします：

 1. 値がメモリ内でどのように表現されるかについてコンパイラが決定を下すのを可能にします。

 2. プログラマが他者に自分の意図を伝える助けとなり、関数の入出力に関する軽量な仕様として機能し、プログラムがそれに従うことをコンパイラが保証できます。

 3. 数値を文字列に加算するなどの様々な潜在的なミスを防ぎ、プログラムに必要なテストの数を減らします。

 4. Leanコンパイラが補助コードの生成を自動化するのを助け、ボイラープレートを削減することができます。

Leanの型システムは異常なほど表現力が高いです。
型は「このソート関数はその入力の順列を返す」のような強い仕様や、「この関数は引数の値に応じて異なる戻り値を持つ」のような柔軟な仕様をエンコードすることができます。
型システムは、数学定理を証明するための完全な論理としても使うことができます。
この最先端の表現力は、簡素な型の必要性をなくすものではありませんが、より高度な特徴を使うための前提としてこれらの簡素な型を理解することが必要です。

Lean内の全てのプログラムは型を持たなければなりません。特に、評価が行われる前には全ての式が型を持っていなければなりません。ここまでの例では、Lean自身が型を発見することができましたが、時には明示的に型を指定する必要があります。これはコロン演算子を用いて行われます：

```lean
#eval {{#example_in Examples/Intro.lean onePlusTwoType}}
```

ここでの `Nat` は _自然数_ の型であり、任意精度の符号なし整数です。
Leanでは、`Nat` が非負の整数リテラルのデフォルトの型です。
このデフォルトの型が常に最適な選択であるとは限りません。
例えばC言語では、符号なし整数の減算で結果がゼロ未満になる場合、最大表現可能数に対するアンダーフローによって減算されます。
しかし、`Nat` は任意に大きな符号なし数を表現できるため、アンダーフローする最大の数が存在しません。
そのため、`Nat` 上の減算は、答えがそうでなければ負になる場合には `0` を返します。
例えば、

```lean
#eval {{#example_in Examples/Intro.lean oneMinusTwo}}
```

は `-1` ではなく `{{#example_out Examples/Intro.lean oneMinusTwo}}` と評価されます。負の整数を表すことができる型を使うには直接指定します：

```lean
#eval {{#example_in Examples/Intro.lean oneMinusTwoInt}}
```

この型を使うと、結果は期待通り `{{#example_out Examples/Intro.lean oneMinusTwoInt}}` になります。

式の型を評価せずに確認するには、`#eval` の代わりに `#check` を使います。例えば：

```lean
{{#example_in Examples/Intro.lean oneMinusTwoIntType}}
```

は実際に減算を行わずに `{{#example_out Examples/Intro.lean oneMinusTwoIntType}}` を報告します。

プログラムに型を与えることができない場合、`#check` および `#eval` からエラーが返されます。例えば：

```lean
{{#example_in Examples/Intro.lean stringAppendList}}
```

は以下の出力をします

```output error
{{#example_out Examples/Intro.lean stringAppendList}}
```

``String.append`` の第二引数は文字列が期待されるのに対し、文字列のリストが提供されたためです。