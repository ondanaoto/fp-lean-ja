# 要約

## 式の評価

Leanでは、式が評価されるときに計算が行われます。
これは通常の数学的な式のルールに従います：サブ式は通常の演算の順序に従ってその値に置き換えられ、全体の式が値になるまで置き換えが行われます。
`if`や`match`を評価する際には、条件やマッチ対象の値が見つかるまで、分岐内の式は評価されません。

変数に値が与えられると、その変数は決して変わりません。
数学と同様ですが、ほとんどのプログラミング言語とは異なり、Leanの変数は値に新しい値を書き込むアドレスではなく、単に値のプレースホルダーです。
変数の値は、`def`によるグローバル定義、`let`によるローカル定義、関数への名前付き引数、またはパターンマッチングから得られることがあります。

## 関数

Leanの関数は第一級の値であり、他の関数への引数として渡したり、変数に保存したり、他の値と同様に使用することができます。
Leanの関数は正確に1つの引数を取ります。
複数の引数を取る関数をエンコードするために、Leanはカリー化と呼ばれる技術を使用します。ここでは、最初の引数を提供すると、残りの引数を期待する関数が返されます。
引数を取らない関数をエンコードするために、Leanは`Unit`型を使用します。これは可能な限り情報量の少ない引数です。

関数を作成するには主に3つの方法があります：
1. 無名関数は`fun`を使用して書かれます。
   例えば、`Point`のフィールドを交換する関数は`{{#example_in Examples/Intro.lean swapLambda}}`として書くことができます。
2. 非常に単純な無名関数は、中央に点`·`を1つ以上置いた括弧内に書かれます。
   各中央の点は関数への引数となり、括弧はその本体を区切ります。
   例えば、引数から1を引く関数は`{{#example_out Examples/Intro.lean subOneDots}}`として書く代わりに`{{#example_in Examples/Intro.lean subOneDots}}`として書くことができます。
3. 引数リストを追加するか、パターンマッチング記法を使用して`def`または`let`を使用して関数を定義することができます。

## 型

Leanはすべての式に型があることを確認します。
`Int`、`Point`、`{α : Type} → Nat → α → List α`、`Option (String ⊕ (Nat × String))`などの型は、式に最終的に見つかる可能性のある値を記述します。
他の言語と同様に、Leanの型はプログラムの軽量な仕様を表現し、Leanコンパイラによってチェックされるため、特定のクラスのユニットテストが不要になります。
ほとんどの言語とは異なり、Leanの型は任意の数学も表現でき、プログラミングと定理証明の世界を統合します。
Leanを定理証明に使用することはこの本の範囲をほとんど超えていますが、_[Theorem Proving in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)_ にはこのトピックに関する詳細情報が含まれています。

ある式は複数の型を持つことができます。
例えば、`3`は`Int`または`Nat`になることができます。
Leanでは、これは同じ方法で書かれたが、`Nat`型と`Int`型の2つの別々の式として理解されるべきです。同じものの2つの異なる型ではありません。

Leanは時々自動的に型を決定することができますが、型はしばしばユーザーによって提供される必要があります。
これはLeanの型システムが非常に表現力豊かだからです。
Leanが型を見つけることができても、望ましい型を見つけるとは限りません—`3`は`Int`として使用することを意図しているかもしれませんが、さらなる制約がなければLeanは`Nat`型を与えます。
一般的に、非常に明白な型を除いて、ほとんどの型を明示的に書くことが良いアイデアです。
これにより、Leanのエラーメッセージが改善され、プログラマーの意図がより明確になります。

いくつかの関数やデータ型は型を引数として取ります。
それらは _多相的_ と呼ばれます。
多相性は、リストのエントリの型に関係なくリストの長さを計算するようなプログラムを可能にします。
型はLeanで第一級であるため、多相性には特別な構文は必要ありません。したがって、型は他の引数と同じように渡されます。
関数型で引数に名前を付けることにより、後の型がその引数を参照することができ、その関数に引数を適用した型は、引数の名前を引数の値で置き換えることによって見つかります。

## 構造体と帰納型

新しいデータ型は、`structure`または`inductive`機能を使用してLeanに導入することができます。
これらの新しい型は、定義がそれ以外に同一であっても、他の型と同等であるとは見なされません。
データ型には、その値がどのように構築されるかを説明する _コンストラクタ_ があり、各コンストラクタはいくつかの引数を取ります。
Leanのコンストラクタはオブジェクト指向言語のコンストラクタとは異なります：Leanのコンストラクタはデータの不活性な保持者であり、割り当てられたオブジェクトを初期化するアクティブなコードではありません。

通常、`structure`は積型（つまり、任意の数の引数を取る1つのコンストラクタを持つ型）を導入するために使用され、`inductive`は和型（つまり、多くの異なるコンストラクタを持つ型）を導入するために使用されます。
`structure`で定義されたデータ型は、コンストラクタの各引数に対して1つのアクセサ関数が提供されます。
構造体と帰納型の両方は、コンストラクタ内に格納されている値を公開するパターンマッチングで消費することができます。これは、コンストラクタを呼び出すために使用される構文のサブセットを使用します。
パターンマッチングは、値を作成する方法を知っていることは、それを消費する方法を知っていることを意味します。

## 再帰

定義が再帰的であるとは、定義されている名前が定義自体で使用されることを意味します。
Leanはプログラミング言語であると同時にインタラクティブな定理証明者でもあるため、再帰的な定義には特定の制限があります。
Leanの論理的な側面では、循環的な定義は論理的な矛盾につながる可能性があります。

再帰的な定義がLeanの論理的な側面を損なわないようにするために、Leanはすべての再帰関数が呼び出されるどんな引数に対しても終了することを証明できる必要があります。
実際には、これは再帰的な呼び出しがすべて入力の構造的に小さい部分に対して行われることを意味します。これにより、常にベースケースに向かって進行が保証されます。または、ユーザーが関数が常に終了するという他の証拠を提供する必要があります。
同様に、帰納型の再帰的な型は、型からの関数を引数として取るコンストラクタを持つことが許されていません。これは、終了しない関数をエンコードする可能性があるためです。