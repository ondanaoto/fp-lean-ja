# 要旨

## 式の評価

Leanでは、式を評価すると計算が行われます。
これは通常の数学的な式のルールに従い、サブ式が値に置き換えられ、操作の通常の順序に従って、式全体が値になるまで進む過程です。
`if` や `match` を評価する場合、分岐内の式は条件またはマッチ対象の値が得られるまで評価されません。

変数に一度値が与えられると、それは決して変わることはありません。
数学のように（しかし多くのプログラミング言語とは異なり）、Leanの変数は単に値のプレースホルダーであり、新しい値を書き込むアドレスではありません。
変数の値は、`def` を使ったグローバル定義、`let` を使ったローカル定義、関数への名前付き引数、またはパターンマッチングから得ることができます。

## 関数

Leanの関数は第一級の値であり、つまり他の関数への引数として渡されたり、変数に保存したり、他のどんな値と同じように使用することができます。
Leanの関数は正確にひとつの引数を取ります。
複数の引数を取る関数をエンコードするために、Leanはカリー化と呼ばれる技術を使用し、最初の引数を提供することで残りの引数を期待する関数を返します。
引数を取らない関数をエンコードするために、Leanは`Unit`型を使用します。これは最も情報量の少ない可能な引数です。

関数を作成する主な3つの方法は次のとおりです：
1. 匿名関数は `fun` を使用して書かれます。
   例えば、`Point` のフィールドを交換する関数は `{{#example_in Examples/Intro.lean swapLambda}}` として書かれることができます。
2. 非常に単純な匿名関数は、一つまたは複数の中点 `·` を括弧内に置いて書かれます。
   各中点は関数への引数となり、括弧はその本体を区切ります。
   例えば、引数から1を引く関数は、`{{#example_out Examples/Intro.lean subOneDots}}` ではなく `{{#example_in Examples/Intro.lean subOneDots}}` として書かれるかもしれません。
3. `def` や `let` を使用して、引数リストを追加したり、パターンマッチング記法を使用することで関数を定義することができます。

## 型

Leanは、すべての式が型を持っていることを確認します。
`Int`、`Point`、`{α : Type} → Nat → α → List α`、`Option (String ⊕ (Nat × String))` などの型は、式に最終的に見つかる可能性のある値を記述します。
他の言語のように、Leanの型はプログラムに対して軽量の仕様を表し、これによってLeanコンパイラーによってチェックされ、特定のクラスのユニットテストの必要性がなくなります。
しかしほとんどの言語とは異なり、Leanの型では任意の数学を表現することもでき、プログラミングと定理証明の世界を統一します。
本書では主にLeanを使用して定理を証明することは範囲外ですが、_[Theorem Proving in Lean 4](https://leanprover.github.io/theorem_proving_in_lean4/)_ にはこのトピックに関する詳細情報が含まれています。

ある式には複数の型が与えられることがあります。
例えば、`3` は `Int` または `Nat` になり得ます。
Leanでは、これを同じ方法で書かれた `Nat` 型と `Int` 型の2つの別々の式として理解すべきであり、別々の型である同一のものとは考えないほうが良いです。

Leanは時々自動的に型を決定することができますが、しばしばユーザーによって型を提供される必要があります。
これはLeanの型システムが非常に表現力豊かであるからです。
Leanが型を見つけることができたとしても、望ましい型を見つけるとは限りません。`3`が`Int`として使われることを意図していても、それ以上の制約がなければLeanは`Nat`の型を与えます。
一般に、非常に明白な型を除き、ほとんどの型を明示的に書くことが賢明です。
これによりLeanのエラーメッセージが改善され、プログラマーの意図がより明確になります。

いくつかの関数やデータ型は型を引数として取ります。
これらは _多相的_ であると呼ばれます。
多相性は、リストの種類に関係なくリストの長さを計算するなどのプログラムを可能にします。
型はLeanでは第一級であるので、多相性は特別な構文を必要とせず、他の引数と同様に渡されます。
関数型に引数に名前を付けると、後の型がその引数を参照することができるようになり、その関数に引数を適用した型は、引数の名前を引数の値に置き換えることによって見つかります。

## 構造体と帰納型

新しいデータ型は、`structure` や `inductive` 機能を使用してLeanに導入することができます。
これらの新しい型は、定義が他と同一であったとしても、他のいかなる型とも等価だとは考えられません。
データ型には、その値を構築する方法を説明する _コンストラクタ_ があり、各コンストラクタはいくつかの引数を取ります。
Leanのコンストラクタはオブジェクト指向言語のコンストラクタと同じではありません：Leanのコンストラクタはデータの不活性な保持者であり、割り当てられたオブジェクトを初期化するアクティブなコードではありません。

典型的には、`structure` は積型（つまり、任意の数の引数を取るただ1つのコンストラクタを持つ型）を導入するために使用され、`inductive` は和型（つまり、多くの異なるコンストラクタを持つ型）を導入するために使用されます。
`structure` で定義されたデータ型は、コンストラクタの各引数に対して一つのアクセサ関数が提供されます。
構造体および帰納型データ型は、それらのコンストラクタに保持される値を露出するパターンマッチングを使用して消費することができ、パターンマッチングはそのコンストラクタを呼び出すために使用された構文の一部を使用します。
パターンマッチングは、値を作成する方法を知っていれば、それを消費する方法を知ることを意味します。

## 再帰

定義が再帰的であるとは、定義されている名前がその定義自体で使用されるときを指します。
Leanはプログラミング言語に加えて対話型定理証明器であるため、再帰的な定義にはある制限が課されます。
Leanの論理的な側面では、循環的な定義は論理的な矛盾につながる可能性があります。

再帰的な定義がLeanの論理的側面を損なうことがないように、Leanは、それがどのような引数で呼び出されても、すべての再帰的な関数が終了することを証明できなければなりません。
実践的には、これは再帰的な呼び出しがすべて入力の構造的に小さい部分に対して行われることを意味し、これにより常に基底ケースに向かって進行することが保証されるか、またはユーザーが関数が絶えず終了することを証明する他の何らかの証拠を提供しなければなりません。
同様に、帰納型は、型 _から_ 関数を引数として取るコンストラクタを持つことが許可されていません。なぜなら、これにより非終了する関数をエンコードすることができるからです。

```