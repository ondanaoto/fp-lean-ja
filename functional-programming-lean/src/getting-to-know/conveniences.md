```markdown
# 追加の便利機能

Leanには、プログラムをより簡潔にするための便利機能が数多く含まれています。

## 自動的な暗黙の引数

Leanで多相関数を書くとき、通常はすべての暗黙の引数を列挙する必要はありません。
代わりに、単に言及することが可能です。
Leanがその型を判断できる場合は、自動的に暗黙の引数として挿入されます。
言い換えれば、以前の`length`の定義：
```lean
{{#example_decl Examples/Intro.lean lengthImp}}
```
は、`{α : Type}`を書かずに以下のように記述できます：
```lean
{{#example_decl Examples/Intro.lean lengthImpAuto}}
```
これは、多くの暗黙の引数を取る高度に多相的な定義を大幅に簡略化することができます。

## パターンマッチングによる定義

`def`を使って関数を定義する際、引数に名前を付けてただちにパターンマッチングで使用することがよくあります。
例えば、`length`では、`xs`という引数が`match`内でのみ使用されます。
このような場面では、引数に名前を付けることなく、`match`式のケースを直接記述することができます。

最初のステップは、引数の型をコロンの右側に移動し、返り値の型が関数の型になるようにすることです。
例えば、`length`の型は`List α → Nat`です。
次に、`:=`の代わりにパターンマッチの各ケースを置き換えます：
```lean
{{#example_decl Examples/Intro.lean lengthMatchDef}}
```

この構文は複数の引数を取る関数を定義するのにも使用できます。
この場合、そのパターンはコンマで区切られます。
例えば、`drop`は数\\( n \\)とリストを取り、リストから最初の\\( n \\)項目を削除したものを返します。
```lean
{{#example_decl Examples/Intro.lean drop}}
```

名前付きの引数とパターンを同じ定義で使用することもできます。
例えば、デフォルト値とオプショナル値を取り、オプショナル値が`none`の場合にデフォルトを返す関数は次のように書けます：
```lean
{{#example_decl Examples/Intro.lean fromOption}}
```
この関数は標準ライブラリでは`Option.getD`と呼ばれ、ドット記法を使って呼び出すことができます：
```lean
{{#example_in Examples/Intro.lean getD}}
```
```output info
{{#example_out Examples/Intro.lean getD}}
```
```lean
{{#example_in Examples/Intro.lean getDNone}}
```
```output info
{{#example_out Examples/Intro.lean getDNone}}
```

## ローカル定義

計算では、中間的なステップに名前を付けることがしばしば有用です。
多くの場合、中間値はそれ自体で有用な概念を表しており、明示的に名前を付けることでプログラムを読みやすくすることができます。
他の場合、中間値は複数回使用されます。
他のほとんどの言語と同じように、Leanでは同じコードを2回記述すると計算が2回行われますが、変数に結果を保存すると計算の結果が保存され再利用されます。

例えば、`unzip`はペアのリストをペアのリストに変換する関数です。
ペアのリストが空の場合、`unzip`の結果は空のリストのペアです。
ペアのリストの先頭にペアがある場合、そのペアの2つのフィールドはリストの残りの部分のunzipの結果に追加されます。
この`unzip`の定義はその説明に完全に従っています：
```lean
{{#example_decl Examples/Intro.lean unzipBad}}
```
残念ながら問題があります：このコードは必要以上に遅いです。
リストのペアの各エントリは2回の再帰呼び出しにつながり、この関数は指数的な時間を要します。
しかし、両方の再帰呼び出しは同じ結果になるため、再帰呼び出しを2回行う理由はありません。

Leanでは、`let`を使用することで再帰呼び出しの結果に名前を付け、保存することができます。
ローカル定義に使われる`let`は`def`を使ったトップレベル定義に似ています：ローカルで定義される名前、必要に応じて引数、型シグネチャがあり、その後に`:=`に続く本体が続きます。
ローカル定義が有効な式（`let`式の_body_と呼ばれる）は新しい行に書かれ、その行はファイル内の`let`キーワードのカラム以下である必要があります。
例えば、`unzip`では`let`を次のように使用できます：
```lean
{{#example_decl Examples/Intro.lean unzip}}
```
単一行に`let`を使用するには、ローカル定義を本体からセミコロンで区切ります。

ローカル定義には、データ型のすべてのケースに一致する足りなるときにパターンマッチングを使用することもできます。
`unzip`のケースでは、再帰呼び出しの結果はペアです。
ペアには単一のコンストラクタしかないため、`unzipped`という名前をペアパターンで置き換えることができます：
```lean
{{#example_decl Examples/Intro.lean unzipPat}}
```
`let`とパターンを慎重に使用することで、手作業でアクセサ呼び出しを書くよりもコードが読みやすくなることがあります。

`let`と`def`の最大の違いは、再帰的な`let`定義は`let rec`と書くことによって明示的に示されなければならないことです。
例えば、リストを逆順にする一つの方法は再帰的なヘルパー関数を使用することです。この定義でのように：
```lean
{{#example_decl Examples/Intro.lean reverse}}
```
ヘルパー関数は入力リストを下に進むと、一度に一つのエントリを`soFar`に移動します。
入力リストの終わりに到達すると、`soFar`は入力の逆順バージョンを含んでいます。