<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>例: モナドでの算術 - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Leanにおける関数型プログラミング</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">イントロダクション</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">謝辞</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> Leanの基本を学ぶ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 式の評価</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 関数と定義</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-patterns-and-pattern.html"><strong aria-hidden="true">1.5.</strong> データタイプ、パターン、そして再帰</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html"><strong aria-hidden="true">1.6.</strong> 多相性</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> プログラムの実行</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> ステップバイステップ</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> プロジェクトの始め方</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 実例:cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 小休止: 命題、証明、そして索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> オーバーロードと型クラス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正の数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 型クラスと多相性</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> インスタンス検索の制御</a></li><li class="chapter-item expanded "><a href="../type-classes/arrays-and-indexing.html"><strong aria-hidden="true">4.4.</strong> 配列とインデックス化</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 標準クラス</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 強制変換</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> モナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/monad-type-class.html"><strong aria-hidden="true">5.1.</strong> モナド型クラス</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic-in-monads.html" class="active"><strong aria-hidden="true">5.2.</strong> 例: モナドでの算術</a></li><li class="chapter-item expanded "><a href="../monads/do-notation-for-monads.html"><strong aria-hidden="true">5.3.</strong> モナド用do記法</a></li><li class="chapter-item expanded "><a href="../monads/io-monad.html"><strong aria-hidden="true">5.4.</strong> IOモナド</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 関手、アプリカティブ関手、そしてモナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/structure-and-inheritance.html"><strong aria-hidden="true">6.1.</strong> 構造と継承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-functors.html"><strong aria-hidden="true">6.2.</strong> アプリカティブ関手</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> アプリカティブの契約</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 代替物</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete-definitions.html"><strong aria-hidden="true">6.6.</strong> 完全な定義</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> モナドトランスフォーマ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> IOとReaderの組み合わせ</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers-kit.html"><strong aria-hidden="true">7.2.</strong> モナド構築キット</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order-of-monad-transformers.html"><strong aria-hidden="true">7.3.</strong> モナドトランスフォーマの並び順</a></li><li class="chapter-item expanded "><a href="../monad-transformers/enhanced-do.html"><strong aria-hidden="true">7.4.</strong> doの機能強化</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依存型を使用したプログラミング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> インデックス付きファミリー</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙デザインパターン</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries-examples.html"><strong aria-hidden="true">8.3.</strong> 実例: 型指定されたクエリ</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> インデックス、パラメータ、そして宇宙レベル</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls-of-programming-with-dependent-types.html"><strong aria-hidden="true">8.5.</strong> 依存型を使ったプログラミングの落とし穴</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 小休止: 戦術、帰納、そして証明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> プログラミング、証明、そしてパフォーマンス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 末尾再帰</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 同一性の証明</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-and-termination.html"><strong aria-hidden="true">10.3.</strong> 配列と終了性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> その他の不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全な配列インデックス</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 挿入ソートと配列の変更</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊な型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">次のステップ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="例-モナドでの算術"><a class="header" href="#例-モナドでの算術">例: モナドでの算術</a></h1>
<p>モナドは、副作用を含むプログラムを副作用を持たない言語でエンコードする方法です。
これを読むと、純粋な関数型プログラムが重要な何かを欠いており、通常のプログラムを書くためにプログラマが苦労して飛び跳ねなければならないという認識にすぐさま飛びつきそうです。
しかしながら、<code>Monad</code> APIを使用することは、プログラムに構文上のコストを課しますが、2つの重要な利益をもたらします：</p>
<ol>
<li>プログラムは、それが使用する副作用について、その型で正直でなければなりません。型シグネチャを一目見るだけで、プログラムが行うことの_全て_が分かり、入力内容や返り値だけではありません。</li>
<li>全ての言語が同じ副作用を提供するわけではありません。例えば、例外を持つ言語だけ、その他の言語は<a href="https://www2.cs.arizona.edu/icon/">Iconの複数の値にわたって検索する</a>など独特のエキゾチックな副作用や、SchemeやRubyの継続を持っています。モナドは_任意_の副作用をエンコードできるため、プログラマは、言語開発者が提供したものに固執するのではなく、特定のアプリケーションに最適なものを選択できます。</li>
</ol>
<p>様々なモナドで意味をなすプログラムの一例は算術表現の評価者です。</p>
<h3 id="算術表現"><a class="header" href="#算術表現">算術表現</a></h3>
<p>算術表現は、リテラルな整数または2つの表現に適用された原始的な２項演算子のいずれかです。演算子は加算、減算、乗算、および除算です：</p>
<pre><code class="language-lean">inductive Expr (op : Type) where
  | const : Int → Expr op
  | prim : op → Expr op → Expr op → Expr op


inductive Arith where
  | plus
  | minus
  | times
  | div
</code></pre>
<p>表現 <code>2 + 3</code> は以下のように表されます：</p>
<pre><code class="language-lean">open Expr in
open Arith in
def twoPlusThree : Expr Arith :=
  prim plus (const 2) (const 3)
</code></pre>
<p>そして <code>14 / (45 - 5 * 9)</code> は以下のように表されます：</p>
<pre><code class="language-lean">open Expr in
open Arith in
def fourteenDivided : Expr Arith :=
  prim div (const 14) (prim minus (const 45) (prim times (const 5) (const 9)))
</code></pre>
<h3 id="表現の評価"><a class="header" href="#表現の評価">表現の評価</a></h3>
<p>表現には除算が含まれるため、ゼロでの除算は未定義のため、評価は失敗する可能性があります。
失敗を表す一つの方法は <code>Option</code> を使用することです：</p>
<pre><code class="language-lean">def evaluateOption : Expr Arith → Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= fun v1 =&gt;
    evaluateOption e2 &gt;&gt;= fun v2 =&gt;
    match p with
    | Arith.plus =&gt; pure (v1 + v2)
    | Arith.minus =&gt; pure (v1 - v2)
    | Arith.times =&gt; pure (v1 * v2)
    | Arith.div =&gt; if v2 == 0 then none else pure (v1 / v2)
</code></pre>
<p>この定義は二項演算子の両方の分岐の評価から失敗を伝播するために <code>Monad Option</code> インスタンスを使用しています。
しかしながら、関数は副表現の評価と副表現の結果に二項演算子を適用する２つの関心事を混在させています。
これは2つの関数に分割することで改善できます：</p>
<pre><code class="language-lean">def applyPrim : Arith → Int → Int → Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; if y == 0 then none else pure (x / y)

def evaluateOption : Expr Arith → Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= fun v1 =&gt;
    evaluateOption e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p><code>#eval evaluateOption fourteenDivided</code> を実行すると <code>none</code> となりますが、これはあまり有用なエラーメッセージではありません。
<code>&gt;&gt;=</code> を使用して <code>none</code> コンストラクタを明示的に扱うのではなく、コードが書かれているため、失敗時にエラーメッセージを提供するためには小さな修正だけが必要です：</p>
<pre><code class="language-lean">def applyPrim : Arith → Int → Int → Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)


def evaluateExcept : Expr Arith → Except String Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateExcept e1 &gt;&gt;= fun v1 =&gt;
    evaluateExcept e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p>唯一の違いは、型シグネチャが <code>Option</code> ではなく <code>Except String</code> を参照していること、および失敗する場合は <code>Except.error</code> を使用することです。
<code>evaluate</code> をそのモナドについて多相的にし、それに <code>applyPrim</code> を引数として渡すことで、単一の評価者はエラーメッセージの形式の両方を報告することができます：</p>
<pre><code class="language-lean">def applyPrimOption : Arith → Int → Int → Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      none
    else pure (x / y)

def applyPrimExcept : Arith → Int → Int → Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def evaluateM [Monad m] (applyPrim : Arith → Int → Int → m Int): Expr Arith → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyPrim e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applyPrim e2 &gt;&gt;= fun v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p><code>applyPrimOption</code> を使用すると、<code>evaluate</code> の最初のバージョンと同じように動作します：</p>
<pre><code class="language-lean">#eval evaluateM applyPrimOption fourteenDivided
</code></pre>
<pre><code class="language-output info">none
</code></pre>
<p>同じように、<code>applyPrimExcept</code> で使用するとエラーメッセージバージョンと同じように動作します：</p>
<pre><code class="language-lean">#eval evaluateM applyPrimExcept fourteenDivided
</code></pre>
<pre><code class="language-output info">Except.error &quot;Tried to divide 14 by zero&quot;
</code></pre>
<p>コードはまだ改善される可能性があります。
関数 <code>applyPrimOption</code> と <code>applyPrimExcept</code> は除算の扱いだけが異なりますが、評価者への別のパラメータを抽出することによって異なることを示すことができます：</p>
<pre><code class="language-lean">def applyDivOption (x : Int) (y : Int) : Option Int :=
    if y == 0 then
      none
    else pure (x / y)

def applyDivExcept (x : Int) (y : Int) : Except String Int :=
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def applyPrim [Monad m] (applyDiv : Int → Int → m Int) : Arith → Int → Int → m Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; applyDiv x y

def evaluateM [Monad m] (applyDiv : Int → Int → m Int): Expr Arith → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyDiv e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applyDiv e2 &gt;&gt;= fun v2 =&gt;
    applyPrim applyDiv p v1 v2
</code></pre>
<p>このリファクタリングされたコードでは、２つのコードパスが失敗の扱いにおいてのみ異なることが完全に明らかとなっています。</p>
<h3 id="更なる副作用"><a class="header" href="#更なる副作用">更なる副作用</a></h3>
<p>失敗と例外は評価者で作業する際に興味深い唯一の種類の副作用ではありません。
除算の唯一の副作用は失敗ですが、他の基本的な演算子を表現に加えることは他の副作用を表現する可能性があります。</p>
<p>最初のステップは、プリミティブのデータ型から除算を抽出するという追加のリファクタリングです：</p>
<pre><code class="language-lean">inductive Prim (special : Type) where
  | plus
  | minus
  | times
  | other : special → Prim special

inductive CanFail where
  | div
</code></pre>
<p>名前 <code>CanFail</code> は除算によって導入された副作用が潜在的な失敗であることを示唆しています。</p>
<p>二つ目のステップは、<code>evaluateM</code> への除算の処理アーギュメントのスコープを拡大して、特別な演算子を処理することができるようにすることです：</p>
<pre><code class="language-lean">def divOption : CanFail → Int → Int → Option Int
  | CanFail.div, x, y =&gt; if y == 0 then none else pure (x / y)

def divExcept : CanFail → Int → Int → Except String Int
  | CanFail.div, x, y =&gt;
    if y == 0 then
      Except.error s!&quot;Tried to divide {x} by zero&quot;
    else pure (x / y)

def applyPrim [Monad m] (applySpecial : special → Int → Int → m Int) : Prim special → Int → Int → m Int
  | Prim.plus, x, y =&gt; pure (x + y)
  | Prim.minus, x, y =&gt; pure (x - y)
  | Prim.times, x, y =&gt; pure (x * y)
  | Prim.other op, x, y =&gt; applySpecial op x y

def evaluateM [Monad m] (applySpecial : special → Int → Int → m Int): Expr (Prim special) → m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applySpecial e1 &gt;&gt;= fun v1 =&gt;
    evaluateM applySpecial e2 &gt;&gt;= fun v2 =&gt;
    applyPrim applySpecial p v1 v2
</code></pre>
<h4 id="副作用無し"><a class="header" href="#副作用無し">副作用無し</a></h4>
<p>型 <code>Empty</code> はコンストラクタを持たず、値もない、ScalaやKotlinの <code>Nothing</code> 型のようです。
ScalaとKotlinでは、<code>Nothing</code> はプログラムをクラッシュさせる関数や、例外を投げる、または常に無限ループに陥る計算を表すことができます。
関数またはメソッドへの <code>Nothing</code> 型の引数は、適切な引数値が決して存在しないため、使用されないコードを指示します。
Leanは無限ループや例外をサポートしていませんが、<code>Empty</code> は型システムに対して関数を呼び出すことができないことを示唆するために依然として役立ちます。
型のコンストラクタを持たない式 <code>E</code> の場合、構文 <code>nomatch E</code> はLeanに現在の式が結果を返す必要がないことを示唆します、なぜならそれは決して呼び出され得ないからです。</p>
<p><code>Empty</code> を <code>Prim</code> へのパラメータとして使用する場合、<code>Prim.plus</code>、<code>Prim.minus</code>、<code>Prim.times</code> を超えた追加のケースがないことを示します。<code>Empty</code> の型の値を <code>Prim.other</code> コンストラクタに配置することは不可能であるためです。
二つの整数に <code>Empty</code> 型の演算子を適用する関数が呼び出されることは決してないため、結果を返す必要はありません。
したがって、どんなモナドでも使用できます：</p>
<pre><code class="language-lean">def applyEmpty [Monad m] (op : Empty) (_ : Int) (_ : Int) : m Int :=
  nomatch op
</code></pre>
<p>これは <code>Id</code>、アイデンティティモナドと一緒に使用され、全く副作用のない表現を評価することができます：</p>
<pre><code class="language-lean">open Expr Prim in
#eval evaluateM (m := Id) applyEmpty (prim plus (const 5) (const (-14)))
</code></pre>
<pre><code class="language-output info">-9
</code></pre>
<h4 id="非決定的探索"><a class="header" href="#非決定的探索">非決定的探索</a></h4>
<p>ゼロでの除算に遭遇した際に単に失敗する代わりに、異なる入力を試してバックトラックすることも理にかなっています。
適切なモナドを与えられた場合、全く同じ <code>evaluateM</code> は失敗しない解の_セット_に対して非決定的探索を実行することができます。
この場合、除算に加えて、非失敗の結果を探索する間にいずれかの引数を選択するように評価者に指示する式言語への <code>choose</code> 関数の追加が必要です。</p>
<p>評価者の結果は今や値のマルチセットであり、単一の値ではありません。
マルチセットへの評価規則は以下の通りです：</p>
<ul>
<li>定数 \( n \) はシングルトンセット \( {n} \) に評価されます。</li>
<li>除算以外の算術演算子は演算子のデカルト積の各ペアに対して呼び出され、したがって \( X + Y \) は \( \{ x + y \mid x ∈ X, y ∈ Y \} \) に評価されます。</li>
<li>除算 \( X / Y \) は \( \{ x / y \mid x ∈ X, y ∈ Y, y ≠ 0\} \) に評価されます。つまり、\( Y \) の全ての \( 0 \) の値は省かれます。</li>
<li>選択 \( \mathrm{choose}(x, y) \) は \( \{ x, y \} \) に評価されます。</li>
</ul>
<p>たとえば、\( 1 + \mathrm{choose}(2, 5) \) は \( \{ 3, 6 \} \) に評価され、\(1 + 2 / 0 \) は \( \{\} \) に評価され、\( 90 / (\mathrm{choose}(-5, 5) + 5) \) は \( \{ 9 \} \) に評価されます。
真のセットの代わりにマルチセットを使用することは、要素の一意性のチェックを省略することでコードを単純化します。</p>
<p>非決定的な影響を表すモナドは、回答がない状況と、少なくとも1つの回答とそれ以外の全ての回答がある状況を表すことができなければなりません：</p>
<pre><code class="language-lean">inductive Many (α : Type) where
  | none : Many α
  | more : α → (Unit → Many α) → Many α
</code></pre>
<p>このデータ型は <code>List</code> と非常によく似ています。
違いは、<code>cons</code> がリストの残りを保存するところで、<code>more</code> が次の値を要求時に計算する関数を保存している点です。
これは <code>Many</code> の消費者が見つけた結果のいくつかを得た時点で探索を止めることができることを意味します。</p>
<p>単一の結果はこれ以上の結果を返さない <code>more</code> コンストラクタで表されます：</p>
<pre><code class="language-lean">def Many.one (x : α) : Many α := Many.more x (fun () =&gt; Many.none)
</code></pre>
<p>２つのマルチセットの結果のユニオンは、最初のマルチセットが空かどうかを調べることによって計算できます。
それが空の場合、２つ目のマルチセットがユニオンです。
それが空でない場合、ユニオンは最初のマルチセットの最初の要素に続いて最初のマルチセットの残りと２つ目のマルチセットのユニオンで構成されます：</p>
<pre><code class="language-lean">def Many.union : Many α → Many α → Many α
  | Many.none, ys =&gt; ys
  | Many.more x xs, ys =&gt; Many.more x (fun () =&gt; union (xs ()) ys)
</code></pre>
<p>開始する検索プロセスで値のリストがあると便利なことがあります。
<code>Many.fromList</code> はリストを結果のマルチセットに変換します：</p>
<pre><code class="language-lean">def Many.fromList : List α → Many α
  | [] =&gt; Many.none
  | x :: xs =&gt; Many.more x (fun () =&gt; fromList xs)
</code></pre>
<p>同様に、検索が指定された後に、いくつかの値または全ての値を抽出すると便利なことがあります：</p>
<pre><code class="language-lean">def Many.take : Nat → Many α → List α
  | 0, _ =&gt; []
  | _ + 1, Many.none =&gt; []
  | n + 1, Many.more x xs =&gt; x :: (xs ()).take n

def Many.takeAll : Many α → List α
  | Many.none =&gt; []
  | Many.more x xs =&gt; x :: (xs ()).takeAll
</code></pre>
<p><code>Monad Many</code> インスタンスには <code>bind</code> 演算子が必要です。
非決定的な検索で２つの操作を連続するには、最初のステップから全ての可能性を取り、それぞれに残りのプログラムを実行し、結果のユニオンを取ることが含まれます。
言い換えると、最初のステップが３つの可能な答えを返す場合、それぞれについて次のステップを試みる必要があります。
２つ目のステップは各入力に対していくつでも答えを返すことができるので、ユニオンを取ることは全探索空間を表します。</p>
<pre><code class="language-lean">def Many.bind : Many α → (α → Many β) → Many β
  | Many.none, _ =&gt;
    Many.none
  | Many.more x xs, f =&gt;
    (f x).union (bind (xs ()) f)
</code></pre>
<p><code>Many.one</code> と <code>Many.bind</code> はモナド契約を遵守します。
<code>Many.bind (Many.one v) f</code> が <code>f v</code> と同じであることを確認するために、式を可能な限り評価してみます：</p>
<pre><code class="language-lean">Many.bind (Many.one v) f
===&gt;
Many.bind (Many.more v (fun () =&gt; Many.none)) f
===&gt;
(f v).union (Many.bind Many.none f)
===&gt;
(f v).union Many.none
</code></pre>
<p>空のマルチセットは <code>union</code> の右のアイデンティティであり、答えは <code>f v</code> と等価です。すべての関数 <code>f</code> について、<code>fun x =&gt; f x</code> は <code>f</code> と同じなので、最初の部分の契約が満たされます。
<code>Reader.bind r Reader.pure</code> が <code>r</code> と同じであることをチェックするには、同様の技術が機能します：</p>
<pre><code class="language-lean">Reader.bind r Reader.pure
===&gt;
fun env =&gt; Reader.pure (r env) env
===&gt;
fun env =&gt; (fun _ =&gt; (r env)) env
===&gt;
fun env =&gt; r env
</code></pre>
<p>リーダアクション <code>r</code> 自体が関数であるため、これは <code>r</code> と同じです。
結合性をチェックするために、<code>Reader.bind (Reader.bind r f) g</code> と <code>Reader.bind r (fun x =&gt; Reader.bind (f x) g)</code> の両方に対して同じことを行います：</p>
<pre><code class="language-lean">Reader.bind (Reader.bind r f) g
===&gt;
fun env =&gt; g ((Reader.bind r f) env) env
===&gt;
fun env =&gt; g ((fun env' =&gt; f (r env') env') env) env
===&gt;
fun env =&gt; g (f (r env) env) env
</code></pre>
<pre><code class="language-lean">Reader.bind r (fun x =&gt; Reader.bind (f x) g)
===&gt;
Reader.bind r (fun x =&gt; fun env =&gt; g (f x env) env)
===&gt;
fun env =&gt; (fun x =&gt; fun env' =&gt; g (f x env') env') (r env) env
===&gt;
fun env =&gt; (fun env' =&gt; g (f (r env) env') env') env
===&gt;
fun env =&gt; g (f (r env) env) env
</code></pre>
<p>したがって、<code>Monad (Reader ρ)</code> インスタンスが正当化されています：</p>
<pre><code class="language-lean">instance : Monad (Reader ρ) where
  pure x := fun _ =&gt; x
  bind x f := fun env =&gt; f (x env) env
</code></pre>
<p>式評価器に渡されるカスタム環境は、ペアのリストとして表現できます：</p>
<pre><code class="language-lean">abbrev Env : Type := List (String × (Int → Int → Int))
</code></pre>
<p>例えば、<code>exampleEnv</code> には最大値と剰余の機能が含まれています：</p>
<pre><code class="language-lean">def exampleEnv : Env := [(&quot;max&quot;, max), (&quot;mod&quot;, (· % ·))]
</code></pre>
<p>Leanにはすでに <code>List.lookup</code> という関数があり、キーに対応する値をペアのリストから見つけるため、<code>applyPrimReader</code> は環境内にカスタム関数が存在するかどうかをチェックするだけで十分です。もし関数が見知らぬものであれば <code>0</code> を返します：</p>
<pre><code class="language-lean">def applyPrimReader (op : String) (x : Int) (y : Int) : Reader Env Int :=
  read &gt;&gt;= fun env =&gt;
  match env.lookup op with
  | none =&gt; pure 0
  | some f =&gt; pure (f x y)
</code></pre>
<p><code>evaluateM</code> を <code>applyPrimReader</code> と式を使って使用すると、環境を期待する関数の結果が得られます。
幸いにも、<code>exampleEnv</code> が使用できます：</p>
<pre><code class="language-lean">open Expr Prim in
#eval evaluateM applyPrimReader (prim (other &quot;max&quot;) (prim plus (const 5) (const 4)) (prim times (const 3) (const 2))) exampleEnv
</code></pre>
<pre><code class="language-output info">9
</code></pre>
<p><code>Many</code> のように、<code>Reader</code> はほとんどの言語でエンコードするのが困難な効果の一例ですが、型クラスとモナドを使うことで他のどんな効果と同じくらい便利になります。
Common Lisp、Clojure、Emacs Lispで見られる動的または特別な変数は、<code>Reader</code> のように使用できます。
同様に、SchemeやRacketのパラメータオブジェクトは、<code>Reader</code> に完全に対応している効果です。
Kotlinのコンテキストオブジェクトの慣用句は同様の問題を解決することができますが、それは自動的に関数引数を渡す手段であるため、この慣用句は言語の効果よりもリーダモナドとしてのエンコーディングに似ています。</p>
<h2 id="練習"><a class="header" href="#練習">練習</a></h2>
<h3 id="契約のチェック"><a class="header" href="#契約のチェック">契約のチェック</a></h3>
<p><code>State σ</code> と <code>Except ε</code> についてモナド契約をチェックしてください。</p>
<h3 id="失敗を伴うリーダー"><a class="header" href="#失敗を伴うリーダー">失敗を伴うリーダー</a></h3>
<p>リーダーモナドの例を適応させて、カスタムオペレータが定義されていない場合に失敗を示すことができるようにしてください。つまり、ゼロを単に返すのではなく、これらの定義を与えられた場合に：</p>
<pre><code class="language-lean">def ReaderOption (ρ : Type) (α : Type) : Type := ρ → Option α

def ReaderExcept (ε : Type) (ρ : Type) (α : Type) : Type := ρ → Except ε α
</code></pre>
<p>次のことを行います：</p>
<ol>
<li>適切な <code>pure</code> と <code>bind</code> 関数を書く</li>
<li>これらの関数が <code>Monad</code> 契約を満たすことを確認する</li>
<li><code>ReaderOption</code> と <code>ReaderExcept</code> のための <code>Monad</code> インスタンスを書く</li>
<li>適切な <code>applyPrim</code> 演算子を定義し、いくつかの例題の式に <code>evaluateM</code> でテストする</li>
</ol>
<h3 id="トレース評価器"><a class="header" href="#トレース評価器">トレース評価器</a></h3>
<p><code>WithLog</code> 型は、評価器と共に使用されることで、特定の操作のオプションのトレースを追加することができます。
特に、<code>ToTrace</code> 型は、与えられたオペレータをトレースする信号として機能することができます：</p>
<pre><code class="language-lean">inductive ToTrace (α : Type) : Type where
  | trace : α → ToTrace α
</code></pre>
<p>トレース評価器の場合、式は型 <code>Expr (Prim (ToTrace (Prim Empty)))</code> を持つべきです。これは、追跡されたそれぞれのバージョンと増やされた追加、減少、および乗算の表現内のオペレータであり、内部の引数が <code>Empty</code> は <code>trace</code> の中にそれ以上の特別なオペレータがないことを示すためです。</p>
<p>以下を行います：</p>
<ol>
<li><code>Monad (WithLog logged)</code> インスタンスを実装する</li>
<li>トレースされたオペレータをその引数に適用する <code>applyTraced</code> 関数を書き、型 <code>ToTrace (Prim Empty) → Int → Int → WithLog (Prim Empty × Int × Int) Int</code> で運用する</li>
</ol>
<p>この練習が正しく完了している場合、</p>
<pre><code class="language-lean">open Expr Prim ToTrace in
#eval evaluateM applyTraced (prim (other (trace times)) (prim (other (trace plus)) (const 1) (const 2)) (prim (other (trace minus)) (const 3) (const 4)))
</code></pre>
<p>は次の結果になります：</p>
<pre><code class="language-output info">{ log := [(Prim.plus, 1, 2), (Prim.minus, 3, 4), (Prim.times, 3, -1)], val := -3 }
</code></pre>
<p>ヒント：結果のログには <code>Prim Empty</code> の型の値が表示されることがあります。<code>#eval</code> の結果としてそれらを表示するためには、以下のインスタンスが必要です：</p>
<pre><code class="language-lean">deriving instance Repr for WithLog
deriving instance Repr for Empty
deriving instance Repr for Prim
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../monads/monad-type-class.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../monads/do-notation-for-monads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../monads/monad-type-class.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../monads/do-notation-for-monads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
