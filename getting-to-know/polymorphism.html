<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>多相性 - Functional Programming in Lean</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">
        <link rel="stylesheet" href="../pygments.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Leanにおける関数型プログラミング</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">イントロダクション</a></li><li class="chapter-item expanded affix "><a href="../acknowledgments.html">謝辞</a></li><li class="chapter-item expanded "><a href="../getting-to-know.html"><strong aria-hidden="true">1.</strong> Leanの基本を学ぶ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-to-know/evaluating.html"><strong aria-hidden="true">1.1.</strong> 式の評価</a></li><li class="chapter-item expanded "><a href="../getting-to-know/types.html"><strong aria-hidden="true">1.2.</strong> 型</a></li><li class="chapter-item expanded "><a href="../getting-to-know/functions-and-definitions.html"><strong aria-hidden="true">1.3.</strong> 関数と定義</a></li><li class="chapter-item expanded "><a href="../getting-to-know/structures.html"><strong aria-hidden="true">1.4.</strong> 構造体</a></li><li class="chapter-item expanded "><a href="../getting-to-know/datatypes-patterns-and-pattern.html"><strong aria-hidden="true">1.5.</strong> データタイプ、パターン、そして再帰</a></li><li class="chapter-item expanded "><a href="../getting-to-know/polymorphism.html" class="active"><strong aria-hidden="true">1.6.</strong> 多相性</a></li><li class="chapter-item expanded "><a href="../getting-to-know/conveniences.html"><strong aria-hidden="true">1.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../getting-to-know/summary.html"><strong aria-hidden="true">1.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../hello-world.html"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../hello-world/running-a-program.html"><strong aria-hidden="true">2.1.</strong> プログラムの実行</a></li><li class="chapter-item expanded "><a href="../hello-world/step-by-step.html"><strong aria-hidden="true">2.2.</strong> ステップバイステップ</a></li><li class="chapter-item expanded "><a href="../hello-world/starting-a-project.html"><strong aria-hidden="true">2.3.</strong> プロジェクトの始め方</a></li><li class="chapter-item expanded "><a href="../hello-world/cat.html"><strong aria-hidden="true">2.4.</strong> 実例:cat</a></li><li class="chapter-item expanded "><a href="../hello-world/conveniences.html"><strong aria-hidden="true">2.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../hello-world/summary.html"><strong aria-hidden="true">2.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../props-proofs-indexing.html"><strong aria-hidden="true">3.</strong> 小休止: 命題、証明、そして索引</a></li><li class="chapter-item expanded "><a href="../type-classes.html"><strong aria-hidden="true">4.</strong> オーバーロードと型クラス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../type-classes/pos.html"><strong aria-hidden="true">4.1.</strong> 正の数</a></li><li class="chapter-item expanded "><a href="../type-classes/polymorphism.html"><strong aria-hidden="true">4.2.</strong> 型クラスと多相性</a></li><li class="chapter-item expanded "><a href="../type-classes/out-params.html"><strong aria-hidden="true">4.3.</strong> インスタンス検索の制御</a></li><li class="chapter-item expanded "><a href="../type-classes/arrays-and-indexing.html"><strong aria-hidden="true">4.4.</strong> 配列とインデックス化</a></li><li class="chapter-item expanded "><a href="../type-classes/standard-classes.html"><strong aria-hidden="true">4.5.</strong> 標準クラス</a></li><li class="chapter-item expanded "><a href="../type-classes/coercion.html"><strong aria-hidden="true">4.6.</strong> 強制変換</a></li><li class="chapter-item expanded "><a href="../type-classes/conveniences.html"><strong aria-hidden="true">4.7.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../type-classes/summary.html"><strong aria-hidden="true">4.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../monads.html"><strong aria-hidden="true">5.</strong> モナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/monad-type-class.html"><strong aria-hidden="true">5.1.</strong> モナド型クラス</a></li><li class="chapter-item expanded "><a href="../monads/arithmetic-in-monads.html"><strong aria-hidden="true">5.2.</strong> 例: モナドでの算術</a></li><li class="chapter-item expanded "><a href="../monads/do-notation-for-monads.html"><strong aria-hidden="true">5.3.</strong> モナド用do記法</a></li><li class="chapter-item expanded "><a href="../monads/io-monad.html"><strong aria-hidden="true">5.4.</strong> IOモナド</a></li><li class="chapter-item expanded "><a href="../monads/conveniences.html"><strong aria-hidden="true">5.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../monads/summary.html"><strong aria-hidden="true">5.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../functor-applicative-monad.html"><strong aria-hidden="true">6.</strong> 関手、アプリカティブ関手、そしてモナド</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../functor-applicative-monad/structure-and-inheritance.html"><strong aria-hidden="true">6.1.</strong> 構造と継承</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-functors.html"><strong aria-hidden="true">6.2.</strong> アプリカティブ関手</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/applicative-contract.html"><strong aria-hidden="true">6.3.</strong> アプリカティブの契約</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/alternative.html"><strong aria-hidden="true">6.4.</strong> 代替物</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/universes.html"><strong aria-hidden="true">6.5.</strong> 宇宙</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/complete-definitions.html"><strong aria-hidden="true">6.6.</strong> 完全な定義</a></li><li class="chapter-item expanded "><a href="../functor-applicative-monad/summary.html"><strong aria-hidden="true">6.7.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../monad-transformers.html"><strong aria-hidden="true">7.</strong> モナドトランスフォーマ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monad-transformers/reader-io.html"><strong aria-hidden="true">7.1.</strong> IOとReaderの組み合わせ</a></li><li class="chapter-item expanded "><a href="../monad-transformers/transformers-kit.html"><strong aria-hidden="true">7.2.</strong> モナド構築キット</a></li><li class="chapter-item expanded "><a href="../monad-transformers/order-of-monad-transformers.html"><strong aria-hidden="true">7.3.</strong> モナドトランスフォーマの並び順</a></li><li class="chapter-item expanded "><a href="../monad-transformers/enhanced-do.html"><strong aria-hidden="true">7.4.</strong> doの機能強化</a></li><li class="chapter-item expanded "><a href="../monad-transformers/conveniences.html"><strong aria-hidden="true">7.5.</strong> 追加の便利な機能</a></li><li class="chapter-item expanded "><a href="../monad-transformers/summary.html"><strong aria-hidden="true">7.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../dependent-types.html"><strong aria-hidden="true">8.</strong> 依存型を使用したプログラミング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dependent-types/indexed-families.html"><strong aria-hidden="true">8.1.</strong> インデックス付きファミリー</a></li><li class="chapter-item expanded "><a href="../dependent-types/universe-pattern.html"><strong aria-hidden="true">8.2.</strong> 宇宙デザインパターン</a></li><li class="chapter-item expanded "><a href="../dependent-types/typed-queries-examples.html"><strong aria-hidden="true">8.3.</strong> 実例: 型指定されたクエリ</a></li><li class="chapter-item expanded "><a href="../dependent-types/indices-parameters-universes.html"><strong aria-hidden="true">8.4.</strong> インデックス、パラメータ、そして宇宙レベル</a></li><li class="chapter-item expanded "><a href="../dependent-types/pitfalls-of-programming-with-dependent-types.html"><strong aria-hidden="true">8.5.</strong> 依存型を使ったプログラミングの落とし穴</a></li><li class="chapter-item expanded "><a href="../dependent-types/summary.html"><strong aria-hidden="true">8.6.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../tactics-induction-proofs.html"><strong aria-hidden="true">9.</strong> 小休止: 戦術、帰納、そして証明</a></li><li class="chapter-item expanded "><a href="../programs-proofs.html"><strong aria-hidden="true">10.</strong> プログラミング、証明、そしてパフォーマンス</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion.html"><strong aria-hidden="true">10.1.</strong> 末尾再帰</a></li><li class="chapter-item expanded "><a href="../programs-proofs/tail-recursion-proofs.html"><strong aria-hidden="true">10.2.</strong> 同一性の証明</a></li><li class="chapter-item expanded "><a href="../programs-proofs/arrays-and-termination.html"><strong aria-hidden="true">10.3.</strong> 配列と終了性</a></li><li class="chapter-item expanded "><a href="../programs-proofs/inequalities.html"><strong aria-hidden="true">10.4.</strong> その他の不等式</a></li><li class="chapter-item expanded "><a href="../programs-proofs/fin.html"><strong aria-hidden="true">10.5.</strong> 安全な配列インデックス</a></li><li class="chapter-item expanded "><a href="../programs-proofs/insertion-sort.html"><strong aria-hidden="true">10.6.</strong> 挿入ソートと配列の変更</a></li><li class="chapter-item expanded "><a href="../programs-proofs/special-types.html"><strong aria-hidden="true">10.7.</strong> 特殊な型</a></li><li class="chapter-item expanded "><a href="../programs-proofs/summary.html"><strong aria-hidden="true">10.8.</strong> 要約</a></li></ol></li><li class="chapter-item expanded "><a href="../next-steps.html">次のステップ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Lean</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="多相性"><a class="header" href="#多相性">多相性</a></h1>
<p>Leanにおいてもほとんどの言語と同様に、型は引数を取ることができます。
例えば、型 <code>List Nat</code> は自然数のリストを、<code>List String</code> は文字列のリストを、<code>List (List Point)</code> は点のリストのリストを表しています。
これはC#やJavaのような言語での <code>List&lt;Nat&gt;</code>、<code>List&lt;String&gt;</code>、あるいは <code>List&lt;List&lt;Point&gt;&gt;</code> によく似ています。
Leanでは関数に引数を渡すのに空白を使うのと同様に、型に引数を渡すのにも空白を使います。</p>
<p>関数型プログラミングにおいて、「<em>多相性（polymorphism）</em>」という用語は通常、型を引数として取るデータ型や定義を指します。
これはオブジェクト指向プログラミングコミュニティにおける用語の使い方とは異なります。オブジェクト指向プログラミングでは、スーパークラスの一部の振る舞いをオーバーライドするサブクラスを指しています。
この書籍では、「多相性」という言葉は常に最初の意味で使います。
これらの型引数は、データ型または定義内で使用され、引数の名前を他の型に置換することで、同じデータ型や定義を任意の型で使用することを可能にします。</p>
<p><code>Point</code> 構造体は <code>x</code> および <code>y</code> のフィールドが <code>Float</code> であることを要求します。
しかし、各座標に特定の表現を要求するものは何もありません。
型を引数として取る多相的な <code>Point</code> バージョン、それを <code>PPoint</code> と呼びますが、これはその両方のフィールドの型として引数の型を使用することができます。</p>
<pre><code class="language-lean">structure PPoint (α : Type) where
  x : α
  y : α
deriving Repr
</code></pre>
<p>関数定義の引数が定義された直後に書かれるのと同様に、構造体の引数は構造体の名前の直後に書かれます。
型引数の名前としてギリシャ文字を使用するのがLeanでは慣例ですが、それ以上に具体的な名前が思いつかない場合に限ります。
<code>Type</code> は他の型を記述する型ですので、<code>Nat</code>、<code>List String</code>、および <code>PPoint Int</code> はすべて <code>Type</code> 型を持っています。</p>
<p><code>List</code> と同様に、<code>PPoint</code> は特定の型を引数として提供することで使用できます。</p>
<pre><code class="language-lean">def natOrigin : PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }
</code></pre>
<p>この例では、両方のフィールドが <code>Nat</code> であることが期待されます。
関数がその引数変数を引数値に置き換えて呼び出されるように、<code>PPoint</code> に型 <code>Nat</code> を引数として提供すると、そのフィールド <code>x</code> と <code>y</code> の型が <code>Nat</code> になる構造体が得られます。これは引数名 <code>α</code> が引数型 <code>Nat</code> に置き換えられるからです。
型はLeanにおける普通の式なので、多相的型（<code>PPoint</code> のような）に引数を渡す際に特殊な構文は必要ありません。</p>
<p>定義もまた、型を引数として取ることができ、多相的になります。
<code>replaceX</code> 関数は <code>PPoint</code> の <code>x</code> フィールドを新しい値に置き換えます。
<code>replaceX</code> が <em>任意</em> の多相的な点で機能するためには、それ自体が多相的でなければなりません。
これは最初の引数が点のフィールドの型であり、後続の引数が最初の引数の名前を参照することで達成されます。</p>
<pre><code class="language-lean">def replaceX (α : Type) (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>言い換えれば、<code>point</code> と <code>newX</code> の型の引数が <code>α</code> を述べるとき、それらは <em>最初に提供された型であるどの型を指している</em> のです。
これは関数引数の名前がその関数の本体中に提供されたとき値を参照する方法と似ています。</p>
<p>これは <code>replaceX</code> の型をLeanにチェックさせた後、<code>replaceX Nat</code> の型をチェックさせることで確認できます。</p>
<pre><code class="language-lean">#check (replaceX)
</code></pre>
<pre><code class="language-output info">replaceX : (α : Type) → PPoint α → α → PPoint α
</code></pre>
<p>この関数型は最初の引数の <em>名前</em> を含み、型内の後続の引数はこの名前を参照します。
関数適用の値は、関数の本体内で提供される引数値に引数名を置き換えて見つかるように、関数適用の型は、関数の戻り型で提供される引数値に引数名を置き換えて見つかります。
最初の引数 <code>Nat</code> を提供することで、型の残りの部分にあるすべての <code>α</code> の出現が <code>Nat</code> に置き換えられます：</p>
<pre><code class="language-lean">#check replaceX Nat
</code></pre>
<pre><code class="language-output info">replaceX Nat : PPoint Nat → Nat → PPoint Nat
</code></pre>
<p>残りの引数が明示的に名付けられていないため、追加の引数が提供されてもさらなる置換は発生しません。</p>
<pre><code class="language-lean">#check replaceX Nat natOrigin
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin : Nat → PPoint Nat
</code></pre>
<pre><code class="language-lean">#check replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">replaceX Nat natOrigin 5 : PPoint Nat
</code></pre>
<p>型を引数として渡したという事実は、それを評価する能力には何の影響も与えません。</p>
<pre><code class="language-lean">#eval replaceX Nat natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>多相的な関数は、名前付きの型引数を取り、後続の型が引数の名前を参照することによって機能します。
しかし、名前を付けることができるという特別なことは型引数にはありません。
前向きおよび後ろ向きのサインを示すデータ型が与えられた場合：</p>
<pre><code class="language-lean">inductive Sign where
  | pos
  | neg
</code></pre>
<p>サインが引数である関数を書くことができます。
引数が前向きの場合、関数は <code>Nat</code> を返し、後ろ向きの場合は <code>Int</code> を返します：</p>
<pre><code class="language-lean">def posOrNegThree (s : Sign) : match s with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
  match s with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)
</code></pre>
<p>型は第一級であり、Lean言語の通常のルールを使用して計算できるため、データ型に対するパターンマッチングによって計算することができます。
Leanがこの関数をチェックするとき、関数の本体での <code>match</code> 式を型での <code>match</code> 式に対応させることによって、<code>pos</code> の場合には <code>Nat</code> を予想される型とし、<code>neg</code> の場合には <code>Int</code> を予想される型とすることを使用します。</p>
<p><code>posOrNegThree</code> を <code>Sign.pos</code> に適用すると、関数の本体と戻り型にある引数名 <code>s</code> が <code>Sign.pos</code> に置き換えられます。
式とその型の両方で評価が行われることができます：</p>
<pre><code class="language-lean">(posOrNegThree Sign.pos : match Sign.pos with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((match Sign.pos with
  | Sign.pos =&gt; (3 : Nat)
  | Sign.neg =&gt; (-3 : Int)) :
 match Sign.pos with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((3 : Nat) : Nat)
===&gt;
3
</code></pre>
<h2 id="連結リスト"><a class="header" href="#連結リスト">連結リスト</a></h2>
<p>Leanの標準ライブラリには、<code>List</code> と呼ばれる正統的な連結リストのデータ型が含まれており、それを使用するのに便利な特殊な構文があります。
リストは角括弧で書かれます。
例えば、10未満の素数を含むリストは次のように書けます:</p>
<pre><code class="language-lean">def primesUnder10 : List Nat := [2, 3, 5, 7]
</code></pre>
<p>背後では、<code>List</code> は次のように定義された帰納的なデータ型です:</p>
<pre><code class="language-lean">inductive List (α : Type) where
  | nil : List α
  | cons : α → List α → List α
</code></pre>
<p>標準ライブラリにある実際の定義は少し異なりますが、まだ紹介されていない機能を使用しているためです。しかし、本質的には非常に似ています。
この定義によれば、<code>List</code> は<code>PPoint</code> と同様に単一の型を引数として取ります。
この型はリストに格納されるエントリの型です。
コンストラクタに従って、<code>List α</code> は <code>nil</code> または <code>cons</code> で作成できます。
コンストラクタ <code>nil</code> は空のリストを表し、<code>cons</code> コンストラクタは空でないリストに使用されます。
<code>cons</code> の最初の引数はリストの頭部であり、二番目の引数はその尾部です。
\( n \) 個のエントリを含むリストには \( n \) 個の <code>cons</code> コンストラクタが含まれ、最後のものには <code>nil</code> がその尾部になります。</p>
<p><code>primesUnder10</code> の例は、<code>List</code> のコンストラクタを直接使用してより明確に書くことができます:</p>
<pre><code class="language-lean">def explicitPrimesUnder10 : List Nat :=
  List.cons 2 (List.cons 3 (List.cons 5 (List.cons 7 List.nil)))
</code></pre>
<p>これら二つの定義は完全に同等ですが、<code>primesUnder10</code> の方が <code>explicitPrimesUnder10</code> より読みやすいです。</p>
<p><code>List</code> を消費する関数は、<code>Nat</code> を消費する関数とほとんど同じように定義できます。
実際には、連結リストを考えるときには、それぞれの <code>succ</code> コンストラクタに余分なデータフィールドがぶら下がっている <code>Nat</code> としてそれを考えることができます。
この観点から、リストの長さを計算することは、それぞれの <code>cons</code> を <code>succ</code> に置き換え、最後の <code>nil</code> を <code>zero</code> に置き換えるプロセスです。
<code>replaceX</code> がポイントのフィールドの型を引数として取ったように、<code>length</code> はリストのエントリの型を引数として取ります。
たとえば、リストが文字列を含む場合、最初の引数は <code>String</code> です: <code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]</code>.
次のように計算すべきです:</p>
<pre><code>length String [&quot;Sourdough&quot;, &quot;bread&quot;]
===&gt;
length String (List.cons &quot;Sourdough&quot; (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (length String (List.cons &quot;bread&quot; List.nil))
===&gt;
Nat.succ (Nat.succ (length String List.nil))
===&gt;
Nat.succ (Nat.succ Nat.zero)
===&gt;
2
</code></pre>
<p><code>length</code> の定義は、リストエントリ型を引数として取るため多相的であり（多相性）、それ自体を参照するため再帰的です（再帰性）。
一般的に、関数はデータの形に従います：再帰的なデータ型は再帰的な関数を導き、多相的なデータ型は多相的な関数を導きます。</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | List.nil =&gt; Nat.zero
  | List.cons y ys =&gt; Nat.succ (length α ys)
</code></pre>
<p>変数の名前は <code>xs</code> や <code>ys</code> のように慣例的に使用され、不明な値のリストを意味します。
名前に <code>s</code> が付いていることで、それらが複数形であることを示し、それゆえ &quot;exes&quot; や &quot;whys&quot; と発音されるので、&quot;x s&quot; や &quot;y s&quot; ではなく発音されます。</p>
<p>リストの関数を読みやすくするために、<code>[]</code> のブラケット表記を <code>nil</code> に一致するパターンマッチに使用し、<code>cons</code> の代わりに接頭辞 <code>::</code> を使うことができます：</p>
<pre><code class="language-lean">def length (α : Type) (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length α ys)
</code></pre>
<h2 id="暗黙の引数"><a class="header" href="#暗黙の引数">暗黙の引数</a></h2>
<p><code>replaceX</code> や <code>length</code> は使用するのにやや官僚的です。なぜなら、型の引数は通常、後続の値によって一意に決定されるからです。
実際、ほとんどの言語ではコンパイラが自動的に型の引数を決定することができ、時々ユーザからの助けを必要とします。
Leanでも同様です。
関数定義時に、丸括弧の代わりに中括弧で引数を宣言することで引数を <em>暗黙的な</em> ものにすることができます。
たとえば、暗黙的な型引数を持つ <code>replaceX</code> のバージョンは以下のようになります：</p>
<pre><code class="language-lean">def replaceX {α : Type} (point : PPoint α) (newX : α) : PPoint α :=
  { point with x := newX }
</code></pre>
<p>それは <code>natOrigin</code> を明示的に <code>Nat</code> を提供せず使用できます。なぜならLeanは後続の引数から <code>α</code> の値を <em>推論</em> できるからです：</p>
<pre><code class="language-lean">#eval replaceX natOrigin 5
</code></pre>
<pre><code class="language-output info">{ x := 5, y := 0 }
</code></pre>
<p>同様に、<code>length</code> を再定義してエントリ型を暗黙的に取ることができます：</p>
<pre><code class="language-lean">def length {α : Type} (xs : List α) : Nat :=
  match xs with
  | [] =&gt; 0
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>この <code>length</code> 関数は <code>primesUnder10</code> に直接適用できます：</p>
<pre><code class="language-lean">#eval length primesUnder10
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>標準ライブラリでは、Leanはこの関数を <code>List.length</code> と呼びます。これは、構造体のフィールドアクセスに使用されるドット構文がリストの長さを見つけるためにも使用できることを意味します：</p>
<pre><code class="language-lean">#eval primesUnder10.length
</code></pre>
<pre><code class="language-output info">4
</code></pre>
<p>Leanが常に暗黙の引数を見つけることができるわけではないため、C#やJavaと同様に、時には型引数を明示的に指定する必要があります。これらの場合、名前を使って提供することができます。
例えば、整数リスト専用の <code>List.length</code> を使用する場合、<code>α</code> を <code>Int</code> に設定して指定することができます：</p>
<pre><code class="language-lean">#check List.length (α := Int)
</code></pre>
<pre><code class="language-output info">List.length : List Int → Nat
</code></pre>
<h2 id="組み込みデータ型のさらなる活用"><a class="header" href="#組み込みデータ型のさらなる活用">組み込みデータ型のさらなる活用</a></h2>
<p>リストに加えて、Leanの標準ライブラリには様々なコンテキストで使用できる他の構造体や帰納的データ型が含まれています。</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p>全てのリストに最初のエントリが存在するわけではありません。一部のリストは空です。
コレクション上の操作は、探しているものを見つけられないことがあります。
例えば、リスト内の最初のエントリを探す関数が、そのようなエントリを見つけられない場合があるのです。
そのため、最初のエントリがない場合の信号を送る方法が必要です。</p>
<p>多くの言語には <code>null</code> 値があり、これは値が存在しないことを表します。
既存の型に特別な <code>null</code> 値を装備する代わりに、Leanは <code>Option</code> というデータ型を提供しており、他の型に欠落値の指標を備え付けます。
例えば、<code>Option Int</code> は <code>Int</code> のnull許容型を表し、<code>Option (List String)</code> は文字列のリストのnull許容型を表します。
新しい型を導入してnull可能性を表すことで、型システムは <code>null</code> のチェックを忘れることがないように保証します。なぜなら、<code>Option Int</code> は <code>Int</code> が期待されるコンテキストで使用することはできないからです。</p>
<p><code>Option</code> には、それぞれ非nullバージョンとnullバージョンを表す <code>some</code> および <code>none</code> という2つのコンストラクタがあります。
非nullコンストラクタである <code>some</code> には下層の値が含まれますが、<code>none</code> には引数がありません：</p>
<pre><code class="language-lean">inductive Option (α : Type) : Type where
  | none : Option α
  | some (val : α) : Option α
</code></pre>
<p><code>Option</code> 型は、C# や Kotlin などの言語における nullable 型ととても似ていますが、同一ではありません。
これらの言語では、ある型（例えば<code>Boolean</code>）が常にその型の実際の値（<code>true</code> および <code>false</code>）を指す場合、<code>Boolean?</code> や <code>Nullable&lt;Boolean&gt;</code> の型は追加で <code>null</code> 値を許容します。
型チェッカーと他のツールがnullのチェックを覚えているのを助けるこのシステムの追跡は非常に有用です。また、型署名を介してnull可能性を明示的に記述するAPIは、そうでないものよりも情報が豊富です。
しかし、これらのnullableな型は、Leanの <code>Option</code> と一つ非常に重要な方法で異なります。それは、複数のオプションの層を許さないということです。
<code>Option (Option Int)</code> を <code>none</code>、<code>some none</code>、または <code>some (some 360)</code> を使って構築することができます。
一方、C#は <code>?</code> を非null許容型にのみ加えることができるために、複数のnull許容層を禁じていますが、Kotlinは <code>T??</code> を <code>T?</code> と同等とみなしています。
この微妙な違いは実際にはほとんど関連性がありませんが、時々重要になることがあります。</p>
<p>リストの最初のエントリを、存在する場合に限って探すには <code>List.head?</code> を使用します。
クエスチョンマークは名称の一部であり、C# や Kotlin での nullable 型を示すクエスチョンマークの使用とは関係ありません。
<code>List.head?</code> の定義において、リストの尾部を表すためにアンダースコアが使用されています。
パターンでは、アンダースコアは一切のものにマッチしますが、マッチしたデータを参照するための変数を導入することはありません。
アンダースコアを代わりに名前として使用することで、入力の一部が無視されることを明確に読者に伝える方法です。</p>
<pre><code class="language-lean">def List.head? {α : Type} (xs : List α) : Option α :=
  match xs with
  | [] =&gt; none
  | y :: _ =&gt; some y
</code></pre>
<p>ヒント: コンテンツは多すぎるため、翻訳プロセスはここで完了していません。次に進むには、追加の指示をお願いします。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../getting-to-know/datatypes-patterns-and-pattern.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../getting-to-know/conveniences.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../getting-to-know/datatypes-patterns-and-pattern.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../getting-to-know/conveniences.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
